{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":0},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default_bak.png","path":"img/default_bak.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"d67681d1181dbb5e894ce122f9c70b3d69e766df","modified":1667096948882},{"_id":"source/_posts/跨域问题和CORS.md","hash":"5f3ca313434aba284dbbba3625e6e100d07c8e45","modified":1667269015793},{"_id":"source/img/favicon.ico","hash":"9a41635c3a4914203da4be0c41df1662f4b64f92","modified":1667096705348},{"_id":"source/_posts/算法/leetcode/1011.D天内送达包裹的能力.md","hash":"16e5f0d631766f4b5c2a2c74585aac8a32956a53","modified":1667270012172},{"_id":"source/_posts/算法/leetcode/1091.二进制矩阵中的最短路径.md","hash":"0c9a93c0e16bca933def384407a9e91022ebdd84","modified":1667270011947},{"_id":"source/_posts/算法/leetcode/120.三角形最小路径和.md","hash":"3362e4c342fb6fd58516429020a7f4ac588db85d","modified":1667270227736},{"_id":"source/_posts/算法/leetcode/122.买卖股票的最佳时机 II.md","hash":"4d0bb19908a4998bfa4ac26e9918405497dd1a06","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/125. 验证回文串.md","hash":"5bcdbb2fec0817423969f0cf6dcdbaebee170757","modified":1667270012173},{"_id":"source/_posts/算法/leetcode/130.被围绕的区域.md","hash":"471f0e90d72cc17534f43c772e03f819b654c795","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/1334.阈值距离内邻居最少的城市.md","hash":"b8868f6fef4543c7162fc6ece2457b6ccfe4489b","modified":1667270012173},{"_id":"source/_posts/算法/leetcode/136.邻值查找.md","hash":"8e0c0349e0fb9641e3ec562d2252d7d964b684e7","modified":1667270012173},{"_id":"source/_posts/算法/leetcode/146.LRU缓存.md","hash":"8f4672448ed3e57ded14e419f7dae6c9f84a5e28","modified":1667270247293},{"_id":"source/_posts/算法/leetcode/152.乘积最大子数组.md","hash":"8b9164165e7beff2a8c432627d935d6c0fa6baac","modified":1667270011947},{"_id":"source/_posts/算法/leetcode/154. 寻找旋转排序数组中的最小值 2.md","hash":"194cb9d61f1941fb1d1b51b6459c48675e7d7be0","modified":1667270011697},{"_id":"source/_posts/算法/leetcode/1584.连接所有点的最小费用.md","hash":"0fd6f5dc16e2516a3738e4879e20cfd450fbb8a8","modified":1667270316533},{"_id":"source/_posts/算法/leetcode/17.电话号码的字母组合.md","hash":"36f79437a536693ec8ba8eef51edd41f92029446","modified":1667270011692},{"_id":"source/_posts/算法/leetcode/18.四数之和.md","hash":"c6e728de6344ed05b364710f568e49ff41868f06","modified":1667270012172},{"_id":"source/_posts/算法/leetcode/198.打家劫舍.md","hash":"68d98b30174c2bff8eda4f104da68b6eef45896e","modified":1667270268236},{"_id":"source/_posts/算法/leetcode/200.岛屿数量.md","hash":"cca8a07bbf9f893dc2a1100b9d43a0aba8dc3a2c","modified":1667270011697},{"_id":"source/_posts/算法/leetcode/208.实现 Trie (前缀树).md","hash":"e94944fca720d1713ab51a5cde21ef4dbcc41548","modified":1667270012191},{"_id":"source/_posts/算法/leetcode/210.课程表2.md","hash":"b5ea48eb270a6b7aebfb26725d90a367ca402a67","modified":1667270012173},{"_id":"source/_posts/.DS_Store","hash":"d329ace94c98d5b7e4f5593be7803815f4442f55","modified":1667062744337},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1667060275137},{"_id":"source/_posts/算法/.DS_Store","hash":"4b811c9d52d25be6d0bcf9906f6d4ea108c6b70b","modified":1667062751662},{"_id":"source/_posts/算法/leetcode/22.括号生成.md","hash":"702667a8be8852466573d5504ea07b29a9249d6b","modified":1667270012172},{"_id":"source/_posts/算法/leetcode/23. 合并K个升序链表.md","hash":"d668d89675043823d41cc6c14f842084f70404d4","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/239.滑动窗口最大值.md","hash":"4607d5b5301a6e566965b99b3c67f62d431c64fe","modified":1667270011947},{"_id":"source/_posts/算法/leetcode/279.完全平方数.md","hash":"b563489ba9a57762358016f8991d30526abbc744","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/297.二叉树的序列化与反序列化.md","hash":"b51386478a646084355cfa59c4a02664385f456c","modified":1667270130046},{"_id":"source/_posts/算法/leetcode/300.最长递增子序列.md","hash":"14a3eed1d079b037ba94eb3266ba6e22b62318b2","modified":1667270012173},{"_id":"source/_posts/算法/leetcode/322.零钱兑换.md","hash":"60c19ea458b3d132228feb3febd62af1b5f0873e","modified":1667270011697},{"_id":"source/_posts/算法/leetcode/327.区间的个数.md","hash":"9994f24d5c28c92bc59063627a088ba9270bc8f1","modified":1667270011948},{"_id":"source/_posts/算法/leetcode/337.打家劫舍 III.md","hash":"0ba87e059f41916977eb556871986f3e5bf3f508","modified":1667270012172},{"_id":"source/_posts/算法/leetcode/34.在排序数组中查找元素的第一个和最后一个位置.md","hash":"f3b1ba51275cf2f6c289928934d5bdc49079139f","modified":1667270012173},{"_id":"source/_posts/算法/leetcode/394. 字符串解码.md","hash":"4a0643800a6c1221e44f54e7a4de415c28ee394b","modified":1667270011947},{"_id":"source/_posts/算法/leetcode/433.最小基因变化.md","hash":"284872bccae79d255394daf6226ece747446198a","modified":1667270012172},{"_id":"source/_posts/算法/leetcode/45. 跳跃游戏 II.md","hash":"8e0dbc23fa71508eedac076bb734519bdffc6c01","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/450.删除二叉搜索树中的节点.md","hash":"cbe6af186faae206a8218e59b9b69cbf3ebcc849","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/50.x的n次幂.md","hash":"3eed16388a60ab170807546a26b62e87fa607094","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/47.全排列2.md","hash":"b1c22ff59996abdacd8f62f2364d24547c2cbf7c","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/51.N皇后问题.md","hash":"c96c6337b0fa2f62fd1781d4c2894cee80ea88ea","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/516.最大回文子序列.md","hash":"1c42d44f358423ca973505224561c18a7588e93b","modified":1667270300579},{"_id":"source/_posts/算法/leetcode/518.零钱兑换 II.md","hash":"f87d152c6b8d41b1d3053838f3d85df40dfd2fcd","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/53.最大子序和.md","hash":"3bb8d7cb9cbddc3415ecb82949628c8c2bccaf34","modified":1667270012173},{"_id":"source/_posts/算法/leetcode/547.省份数量.md","hash":"704084c84739126fa3099747a69ae726343bd0d5","modified":1667270012191},{"_id":"source/_posts/算法/leetcode/56.合并区间.md","hash":"4b652199a3b7dc7fe5e0892def32d8765be47c8a","modified":1667270011947},{"_id":"source/_posts/算法/leetcode/560. 和为 K 的子数组.md","hash":"20dd80e70d8bf439b79c8191263d93793e714dd8","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/673.最长递增子序列的个数.md","hash":"5607aaea70d68f57bea4cee9da17777e5b0679f1","modified":1667270011692},{"_id":"source/_posts/算法/leetcode/684.冗余链接.md","hash":"1fce7aebc66bc514832cba880d35c9b679649f0b","modified":1667270011947},{"_id":"source/_posts/算法/leetcode/685.冗余链接2.md","hash":"47ed003a6ebb393de77eab4c22ad2c3bbc6ccd32","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/699. 掉落的方块.md","hash":"5fd0f17df148f2c1c74ed4f7d9405dc56b679a5f","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/704.二分查找.md","hash":"d8ebb3f1c09972cfe23ddf22e953be5523321800","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/72.编辑距离.md","hash":"6d1c51a43751bde96583e6208caf300d031d8b32","modified":1667270011928},{"_id":"source/_posts/算法/leetcode/743. 网络延迟.md","hash":"9bdf2b691ca57ebd405c1eea2341493ae2840780","modified":1667270011693},{"_id":"source/_posts/算法/leetcode/77.组合.md","hash":"6756e6562fb697b012d5602c05ee705ad5d74f4b","modified":1667270011947},{"_id":"source/_posts/算法/leetcode/721.账户合并.md","hash":"b8218edd88e22ec8031ca808bf86dba2eac4dfef","modified":1667270012173},{"_id":"source/_posts/算法/leetcode/78.子集.md","hash":"1ec59eb989ca250691f23d358985f72736c593ea","modified":1667270012173},{"_id":"source/_posts/算法/leetcode/8.字符串转换整数 (atoi).md","hash":"44236f2a3a24983dd36a323c715c54bd3d79b3cd","modified":1667270152998},{"_id":"source/_posts/算法/leetcode/918.环形子数组的最大和.md","hash":"aed76ed3ea97128fb19fbf1ed32ebd04cc462b85","modified":1667270011692},{"_id":"source/_posts/算法/leetcode/98.验证二叉搜索树.md","hash":"de141c9243401f539a130168bb2680b149d56358","modified":1667270011693},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1667060275199},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1667060275146},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1667060275147},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1667060275146},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1667060275149},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1667060275149},{"_id":"themes/fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1667060275149},{"_id":"themes/fluid/_config.yml","hash":"88d57ef0d6f354aae8a529c19cfbd05bdb01e9a1","modified":1667270559052},{"_id":"themes/fluid/package.json","hash":"0bc354a01c5e6e9de43bf67456dc16c59d400139","modified":1667060275170},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1667060275150},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1667060275151},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1667060275151},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1667060275151},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1667060275152},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1667060275151},{"_id":"themes/fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":1667060275152},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1667060275151},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1667060275167},{"_id":"themes/fluid/README_en.md","hash":"8c874f309e346fffa392e174385b5cc08510f218","modified":1667060275149},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1667060275168},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1667060275168},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1667060275167},{"_id":"themes/fluid/layout/index.ejs","hash":"b15d13877827e99e0ff783a6b13b13cca90bfe8c","modified":1667060275168},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1667060275168},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1667060275169},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1667060275168},{"_id":"themes/fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":1667060275169},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1667060275169},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1667060275169},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1667060275147},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1667060275148},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1667060275148},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1667060275149},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1667060275152},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1667060275153},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"5d23a032789a0ee121bd9f071d1500d2b84a7503","modified":1667060275151},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"a591fedbc5759fb00152304f9ea486dfba3a246a","modified":1667060275153},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1667060275148},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1667060275148},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1667060275148},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":1667060275160},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1667060275161},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1667060275160},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"776949aa697dffd54e9b1957d9245028879509a3","modified":1667060275161},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1667060275162},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1667060275162},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1667060275167},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1667060275172},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1667060275167},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1667060275163},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1667060275172},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1667060275173},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1667060275170},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1667060275173},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1667060275173},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1667060275174},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1667060275174},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1667060275174},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1667060275174},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"43620b0944ffb67ea1fa6cc838f65a7351222eb0","modified":1667060275175},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1667060275175},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1667060275175},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1667060275176},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1667060275176},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1667060275176},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1667060275176},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1667060275177},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1667060275177},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1667060275175},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1667060275178},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1667060275178},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1667060275178},{"_id":"themes/fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1667060275177},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1667060275175},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1667060275203},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1667060275202},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1667060275203},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1667060275204},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1667060275204},{"_id":"themes/fluid/source/img/default.png","hash":"bab8864a2793d74e04401d37023d83c71df46b91","modified":1667060275205},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1667060275209},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1667060275208},{"_id":"themes/fluid/source/js/boot.js","hash":"2848f8eb5081a7f0550fbd76dc06d3ff877f1913","modified":1667060275210},{"_id":"themes/fluid/source/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1667060275211},{"_id":"themes/fluid/source/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1667060275211},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1667060275213},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1667060275212},{"_id":"themes/fluid/source/js/plugins.js","hash":"9f11b514d02a6eb57cb2ae5f5fc653d87d18afc4","modified":1667271348110},{"_id":"themes/fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1667060275214},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1667060275176},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1667060275217},{"_id":"themes/fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1667060275215},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1667060275153},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1667060275154},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1667060275155},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1667060275154},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1667060275155},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1667060275159},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1667060275158},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1667060275159},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1667060275159},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1667060275153},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1667060275159},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1667060275161},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1667060275162},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1667060275161},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":1667060275162},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1667060275209},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1667060275163},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1667060275164},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"953552425f0b86c98d1026fdb04e716fdff356e7","modified":1667060275163},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1667060275164},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"cbcf6905f4990a22895a848e29dd4c05592a9043","modified":1667060275164},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1667060275164},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"94c1ce6e312932e876886ba24b082ae34515a038","modified":1667060275165},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"3b3b0be9f7624ff72fbb2da6ae3663adcfb7d118","modified":1667060275165},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1667060275165},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1667060275166},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1667060275166},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"e836e545afa13e6af7a79c8e6dd0cd095e3b0020","modified":1667147225846},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"e74fb49526ddb14fee2c6360a560d17f57262ef7","modified":1667060275166},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1667060275166},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"91a1de823492d9225f9daa3ef59efbca345456a0","modified":1667060275167},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"326b5ca8e8e77e827d841fc454aca2d8a76b9284","modified":1667123207503},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1667060275166},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1667060275170},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1667060275171},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1667060275171},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1667060275171},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1667060275171},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1667060275171},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1667060275172},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1667060275179},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1667060275180},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1667060275201},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"6622160087b47cdbbb0acde5ae24f83362c478f6","modified":1667060275202},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1667060275181},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1667060275181},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"99e8e25e84d513b869a17140f63a5c1e48a0e7e1","modified":1667060275188},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1667060275188},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1667060275189},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1667060275186},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1667060275186},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1667060275186},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1667060275187},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1667060275191},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1667060275192},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1667060275193},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"7054d79c9d5966fc57baf0adcdf3b19275987b62","modified":1667060275194},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1667060275195},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1667060275195},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1667060275196},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1667060275200},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1667060275182},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1667060275182},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1667060275182},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1667060275183},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1667060275183},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"7ce911b6e2e1befcfc2d6ac1292e1dde96ea47b9","modified":1667060275184},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1667060275183},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"896179810e1ee986208ae2d57a44719f6b839bde","modified":1667060275183},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1667060275183},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1667060275184},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1667060275184},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1667060275185},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1667060275184},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1667060275185},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"16dec741794dde71f2e523b9c8499b088bc3b9b2","modified":1667100119938},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1667060275186},{"_id":"themes/fluid/source/img/default_bak.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1667060275207},{"_id":"public/local-search.xml","hash":"f3ff3f1d282437e307c96299db152c3b022f4ee6","modified":1668006781371},{"_id":"public/archives/index.html","hash":"40e1adf55abb3260ab2cba5bc6d5c5e7a93459f3","modified":1668006781371},{"_id":"public/archives/page/2/index.html","hash":"876fd354ea360c2509dad10897af52ce0f901ad4","modified":1668006781371},{"_id":"public/archives/page/3/index.html","hash":"a85b895c9af386c0781659663ae0afa1e6a90321","modified":1668006781371},{"_id":"public/archives/page/4/index.html","hash":"bd705b6ec67178bec991eabe5b3547b58a8805ed","modified":1668006781371},{"_id":"public/archives/page/5/index.html","hash":"a871632a94d85c36ca5252e5e926e3ee234de5fd","modified":1668006781371},{"_id":"public/archives/page/6/index.html","hash":"600368f0fbbf80209fc91ab4df94e19d5f9d59fe","modified":1668006781371},{"_id":"public/archives/2020/index.html","hash":"3f3c2568f02a461f9665c5aeda7f20bf06bce2de","modified":1668006781371},{"_id":"public/archives/2020/10/index.html","hash":"2e6d95ebbe5628da7c8b504edc9e4de2ed776671","modified":1668006781371},{"_id":"public/archives/2021/index.html","hash":"091f877ea6c0c3f2ceee21be9c246814d283b24b","modified":1668006781371},{"_id":"public/archives/2021/page/2/index.html","hash":"b20a9453ae9f76449fff586f9ed350b0dd2e5688","modified":1668006781371},{"_id":"public/archives/2021/page/3/index.html","hash":"4348c70c362fe9205d3261ea0cb7e8616007ba13","modified":1668006781371},{"_id":"public/archives/2021/page/4/index.html","hash":"b7df3d0eecfc27904879c4de9aeb3110c65a397d","modified":1668006781371},{"_id":"public/archives/2021/page/5/index.html","hash":"5ec02143d385a50aef701240f2a319c33d541b1c","modified":1668006781371},{"_id":"public/archives/2021/page/6/index.html","hash":"09787e6fd9592ea5782dfa98dd037a33e837b6a2","modified":1668006781371},{"_id":"public/archives/2021/09/index.html","hash":"82c07bd2168638e4158f37560294697094c5911d","modified":1668006781371},{"_id":"public/archives/2021/09/page/2/index.html","hash":"1f3235adf9d5a142d82bfb2d5803d374d5eb7b05","modified":1668006781371},{"_id":"public/archives/2021/09/page/3/index.html","hash":"fa24110d0aed2ec4f9c9550e19d0efe50249c869","modified":1668006781371},{"_id":"public/archives/2021/09/page/4/index.html","hash":"597eec2037d9e776449f738148daf29756a18d38","modified":1668006781371},{"_id":"public/archives/2021/09/page/5/index.html","hash":"c82bb422ba96e29b596e2790dc41b4be4bb36c23","modified":1668006781371},{"_id":"public/archives/2021/09/page/6/index.html","hash":"284f5cba4cfcf17d115205d9a29ca27fcbe72986","modified":1668006781371},{"_id":"public/categories/算法/index.html","hash":"2ac14903979eb5aae71976875542092e5ea0a182","modified":1668006781371},{"_id":"public/categories/算法/page/2/index.html","hash":"395582177bf84e858a4ebfbd9734f9a76b89717e","modified":1668006781371},{"_id":"public/categories/算法/page/3/index.html","hash":"bfc6c4bf8ad703d09a11622e7be2092ab825a2d2","modified":1668006781371},{"_id":"public/categories/算法/page/4/index.html","hash":"4cebb2afe5f4dc4381f0e919ca7a54494f54b409","modified":1668006781371},{"_id":"public/categories/算法/page/5/index.html","hash":"cf089eb8b11793c60c118bb08cee3a6163bf9e36","modified":1668006781371},{"_id":"public/categories/算法/page/6/index.html","hash":"aa756307f5009b31a5dec1ff56146e87d0b64986","modified":1668006781371},{"_id":"public/categories/算法/leetcode/index.html","hash":"e7b8463612bb828f95b339736dcdc7e5282260db","modified":1667270510251},{"_id":"public/categories/算法/leetcode/page/2/index.html","hash":"ac36500585c65a7aa079c91196f1c68e4ae06c92","modified":1667270510251},{"_id":"public/categories/算法/leetcode/page/3/index.html","hash":"c99900e474e04e137fb9f134803b736e834ac283","modified":1667270510251},{"_id":"public/categories/算法/leetcode/page/4/index.html","hash":"318d6f08cdabb8170e1202aa7886b46b2c3b893d","modified":1667270510251},{"_id":"public/categories/算法/leetcode/page/6/index.html","hash":"b1b9f9d1bc6d3b529631d5d9a1988a3629bdc918","modified":1667270510251},{"_id":"public/categories/算法/leetcode/page/5/index.html","hash":"81dce486e78e1c21d982c3219b30eeb27b8ba34f","modified":1667270510251},{"_id":"public/404.html","hash":"32819c9520083f3a0e338cb26c3ebcdef1518105","modified":1667270510251},{"_id":"public/tags/网络/index.html","hash":"8ceb21aaece06f44231d37b8bf7dfdca8e6d16de","modified":1667270510251},{"_id":"public/categories/index.html","hash":"a49e30b72ffd2dcfc788f9bfa557fe0db29531a0","modified":1668006781371},{"_id":"public/tags/index.html","hash":"f7d18aa894518517e057dea0dc4255bb49d1e25d","modified":1667270618891},{"_id":"public/2021/09/bc68193ce556.html","hash":"a27dfd6934cd54de5a527028770146203ef7d6dc","modified":1668006781371},{"_id":"public/2021/09/cd7daaeb0f4f.html","hash":"8d7aebcb8d9f3b578069550095faa757f494fcbd","modified":1668006781371},{"_id":"public/2021/09/2c885142f785.html","hash":"29dd98027601be32f8477ee7d497b3953f0ee67e","modified":1668006781371},{"_id":"public/2021/09/8cc3eb936545.html","hash":"dcbad98a3fe41d3d41c3a616ef0bfadf4b03ee4a","modified":1668006781371},{"_id":"public/2021/09/09f02e1b9f32.html","hash":"054b930d3ea42c5b3d44f39875ecdbdbc9b30777","modified":1668006781371},{"_id":"public/2021/09/510e100f0b5d.html","hash":"39673f25cd1852e5c6673fd436b7a1e819855890","modified":1668006781371},{"_id":"public/2021/09/1ee5da1fe507.html","hash":"63d702de513a90733b6aee537349a68f904596dc","modified":1668006781371},{"_id":"public/2021/09/98d75be59f0a.html","hash":"817da40f56935280a3ed02fe4232d600e92c8dcc","modified":1668006781371},{"_id":"public/2021/09/e094958da4f3.html","hash":"940d90c624e46ee688ba74c412b4246d36711306","modified":1668006781371},{"_id":"public/2021/09/b207d139ad46.html","hash":"868ed1f6606de42daab7e5418268cb6523e30969","modified":1668006781371},{"_id":"public/2021/09/6dfb0c949d97.html","hash":"05e60a4aa3b1997982b4b7951767c29353ebec00","modified":1668006781371},{"_id":"public/2021/09/5c55c968c05f.html","hash":"2eb9213757ce616c5d8e6ce015edf13dedffea14","modified":1668006781371},{"_id":"public/2021/09/2428552c6da3.html","hash":"adcc1359dc8f476855e126bf9183e10762108712","modified":1668006781371},{"_id":"public/2021/09/fbe38ea3571e.html","hash":"25d43fe4932c13931dc9701befbd1c9ed379525d","modified":1668006781371},{"_id":"public/2021/09/8a1aa3ad11a7.html","hash":"d9b2251f5521442fc6dfe370f83eb74cec492739","modified":1668006781371},{"_id":"public/2021/09/ccf6ad58cd8a.html","hash":"c02d4522d98030cbcfe39d5ea06030710dcf7a2b","modified":1668006781371},{"_id":"public/2021/09/347672d66136.html","hash":"3150d43b91e99afee1c27bf8b8a47a22395a9dc9","modified":1668006781371},{"_id":"public/2021/09/d00c0b25453f.html","hash":"9ecbee27f890ba4922f4c63065ba61aa0a5e93b4","modified":1668006781371},{"_id":"public/2021/09/9f36be36262a.html","hash":"cc1568a610910e9601565bb5b37a3b74b70cff45","modified":1668006781371},{"_id":"public/2021/09/28c37fe4d19d.html","hash":"2b69fbe485bcf8d5baf422f15fff3471eaeea373","modified":1668006781371},{"_id":"public/2021/09/aa2dbfd75f0d.html","hash":"412fc771ba142b0149798d60438a7da22af97e67","modified":1668006781371},{"_id":"public/2021/09/4dd2603238eb.html","hash":"52142cb53766d413a9511a47342f5b4b09a8659e","modified":1668006781371},{"_id":"public/2021/09/c7ddeb838461.html","hash":"474546acc08a0d7ff479902ecdf576fdab5fcb03","modified":1668006781371},{"_id":"public/2021/09/c34f3fd65725.html","hash":"ff42f90af64888db4f837a6d2830088ffa3aff54","modified":1668006781371},{"_id":"public/2021/09/91e669f81edd.html","hash":"39ed82eec091e1d0e3c7dd93a24204584f99b6c4","modified":1668006781371},{"_id":"public/2021/09/5b4cb558d58b.html","hash":"1d17be147a1cb691425d72c7a4dcddfc2aea0689","modified":1668006781371},{"_id":"public/2021/09/1ff751bbb71e.html","hash":"7d9beed40d4de42a64047e878f6cf101ef5f38ac","modified":1668006781371},{"_id":"public/2021/09/abc5acf8e506.html","hash":"f7dada9f3ae7abfcaf0a62ba1f7f673f3170c74e","modified":1668006781371},{"_id":"public/2021/09/45fb9f609987.html","hash":"e53bf3f8f7b097934b80fde60f32d24c402c36b2","modified":1668006781371},{"_id":"public/2021/09/d8e4866d5698.html","hash":"8805df9144aedcd3d65320876f131feb8f183e31","modified":1668006781371},{"_id":"public/2021/09/473a1a4615b3.html","hash":"bf56c54b56f4c892e0d775d7dd4c28d1396a35be","modified":1668006781371},{"_id":"public/2021/09/a1637c359464.html","hash":"9263350577ba89b7eaf1ba8ff49b3e7fe1b49a1a","modified":1668006781371},{"_id":"public/2021/09/192faa59c2cf.html","hash":"3f8df4ebf6740d2f484daa012eba175a31903952","modified":1668006781371},{"_id":"public/2021/09/2cc51ba2510e.html","hash":"3d723a356c6ba5cbd29de37604928126fd9517b1","modified":1668006781371},{"_id":"public/2021/09/310b63774ff8.html","hash":"d8287a91333b19f890984523292543e1b32a91be","modified":1668006781371},{"_id":"public/2021/09/372a17b6d909.html","hash":"d000dfc6052e0a0d245600e2ecddc8bd1cd75992","modified":1668006781371},{"_id":"public/2021/09/a24932b4a773.html","hash":"e5502f134b6514e2383f8f094bee21cecccba46d","modified":1668006781371},{"_id":"public/2021/09/ee08e0805982.html","hash":"b1cc11b019679424266ea99f5a651817415f2a85","modified":1668006781371},{"_id":"public/2021/09/d4aa73c2e1fd.html","hash":"75d681132ed3b19f418d4086479bdb88a756ee6b","modified":1668006781371},{"_id":"public/2021/09/1f1199041b30.html","hash":"65eccd4b4641baceb999e775f2818e79b19aac16","modified":1668006781371},{"_id":"public/2021/09/4e32b9173bb0.html","hash":"624121116b1265255417842e0a3b89fcde8e9c37","modified":1668006781371},{"_id":"public/2021/09/a47563a515f0.html","hash":"2e33a81dfb86d11f521c09f65aa912e56c7d0e54","modified":1668006781371},{"_id":"public/2021/09/c3604616f70c.html","hash":"535d899e31e20976087da2feb643f26e4d77e747","modified":1668006781371},{"_id":"public/2021/09/d38dabc86412.html","hash":"60fe3ac53c4de6ad990d2b8826a505bcdaadd144","modified":1668006781371},{"_id":"public/2021/09/6cbf857f7046.html","hash":"a1793b7a7eab30b5e85803868b03afe95e0cbed1","modified":1668006781371},{"_id":"public/2021/09/06399cba81a2.html","hash":"c2056550e63fb74d053ab9c80a5f852c3d5f1ea5","modified":1668006781371},{"_id":"public/2021/09/13597fc24728.html","hash":"9a3586096850707abf12c3e842918fd305f46392","modified":1668006781371},{"_id":"public/2021/09/5cd8d3141e83.html","hash":"1c36edb4b11f372a964eb58a79124b9bb8d4b39f","modified":1668006781371},{"_id":"public/2021/09/0ad8484ad345.html","hash":"9fdee723158faf4e7fc89e904cea7efe81cfb674","modified":1668006781371},{"_id":"public/2021/09/ef5132bc327a.html","hash":"02da6e3a3799f7a4c059e6f99c7640ae3427461c","modified":1668006781371},{"_id":"public/2021/09/bfe779944b47.html","hash":"37bca941c7f728927be153c7eae727085f49c7b9","modified":1668006781371},{"_id":"public/2021/09/f12d6c038a19.html","hash":"9cec7add451b3129cb1b72606040a301d4818916","modified":1668006781371},{"_id":"public/2021/09/59ae4316663b.html","hash":"f73598d26640b75d3f78872083e4d56f83f83f59","modified":1668006781371},{"_id":"public/2021/09/c60b74097c6b.html","hash":"2d0fbb15e5fd2c4840140b48ecb93daf84170ebf","modified":1668006781371},{"_id":"public/2020/10/48fe4bc41aa8.html","hash":"2b0b71cf0855c5092f50728aabb00d3b9aa60c0f","modified":1667270510251},{"_id":"public/page/2/index.html","hash":"6d7cd9f0cd938fbcf843686d1822348823680367","modified":1668006781371},{"_id":"public/page/3/index.html","hash":"cdd444f93555886eba1d3de33cf24f81e1afd9f8","modified":1668006781371},{"_id":"public/page/4/index.html","hash":"be1c47db72a5d88103b80a5850b1b9d463314412","modified":1668006781371},{"_id":"public/page/5/index.html","hash":"a59a1a20e24d89833908c9731cd7aab49891ab0b","modified":1668006781371},{"_id":"public/index.html","hash":"88e29d85866eb6866e0e5fb9a24c6648b7a33e3b","modified":1668006781371},{"_id":"public/page/6/index.html","hash":"a0b0534b577fa615cec9ed421cccb77d340a75de","modified":1668006781371},{"_id":"public/CNAME","hash":"d67681d1181dbb5e894ce122f9c70b3d69e766df","modified":1667270510251},{"_id":"public/img/favicon.ico","hash":"9a41635c3a4914203da4be0c41df1662f4b64f92","modified":1667270510251},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1667270510251},{"_id":"public/img/default.png","hash":"bab8864a2793d74e04401d37023d83c71df46b91","modified":1667270510251},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1667270510251},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1667270510251},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1667270510251},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1667270510251},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1667270510251},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1667270510251},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1667270510251},{"_id":"public/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1667270510251},{"_id":"public/js/boot.js","hash":"2848f8eb5081a7f0550fbd76dc06d3ff877f1913","modified":1667270510251},{"_id":"public/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1667270510251},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1667270510251},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1667270510251},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1667270510251},{"_id":"public/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1667270510251},{"_id":"public/js/plugins.js","hash":"9f11b514d02a6eb57cb2ae5f5fc653d87d18afc4","modified":1668006781371},{"_id":"public/css/main.css","hash":"91faa5d2824e1fa33d936129b7c52badf9354d68","modified":1667270510251},{"_id":"public/img/default_bak.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1667270510251},{"_id":"source/_drafts/ent数据排序mixin.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1668004319784},{"_id":"source/_drafts/Golang性能分析工具pprof.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1667833892988},{"_id":"source/_posts/算法/leetcode/212.单词搜索 II.md","hash":"aae2e0c0096b2f3986b2c6c7a0d9c04ceb81be9e","modified":1668006781777},{"_id":"source/_posts/算法/leetcode/389.找不同.md","hash":"dbaeea899a3811dd55bd6ec19af7740fdc44e471","modified":1668006781777},{"_id":"public/2021/11/076d3cc23016.html","hash":"46af4f92b9a907e121b3e841b7a33cecbeeee17a","modified":1668006781371},{"_id":"public/2021/11/85b6a30b99bb.html","hash":"0f9d1095b40c2d28105019b653a81faf97836932","modified":1668006781371},{"_id":"public/archives/2021/11/index.html","hash":"5cade115e6f3be87f88d2ef5fd4eca8b43341c64","modified":1668006781371}],"Category":[{"name":"算法","_id":"cl9xltbf300050k4ldge635he"},{"name":"leetcode","parent":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfb000f0k4l4v1a1qd8"}],"Data":[],"Page":[],"Post":[{"title":"跨域问题和CORS","category_bar":true,"date":"2020-10-01T02:00:00.000Z","_content":"\n## 什么是CORS\n\n所谓跨域，通俗来说就是该网站访问了其他origin（源，由域、协议和端口组成）的资源。\n\n浏览器发出的 `XMLHttpRequest` 请求有同源使用限制，默认情况下跨域请求是不被允许的。但是，每个源可以设置哪些其他源可以访问自己的资源，如果一个请求源A在源B的允许请求范围内，那么浏览器就允许请求源A对源B的跨域请求。这种检查机制就是跨源资源共享 (CORS)，是一种基于 HTTP 头的机制。\n\n## 简单请求和非简单请求\n\n在介绍CORS之前，首先要明确两种不同类型的请求，`简单请求` 和 `非简单请求`。 \n\n若请求 满足所有下述条件，则该请求可视为`简单请求`：\n\n使用下列方法之一：\n\n- GET\n- HEAD\n- POST\n\n请求的Headers只包含以下字段：\n\n- Accept\n- Accept-Language\n- Content-Language\n- Content-Type（需要注意额外的限制）\n- 请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。\n- 请求中没有使用 ReadableStream 对象。\n\nContent-Type 的值仅限于下列三者之一：\n- text/plain\n- multipart/form-data\n- application/x-www-form-urlencoded\n\n而不符合上述条件的则为 `非简单请求`。\n\n## CORS预检请求（Preflight request）\n\n浏览器会在必要的时候向服务器发送一个 `OPTIONS` 请求，用来检查服务器是否支持跨域资源共享即CORS。这个请求就叫预检请求（Preflight request）。\n\n请求通常携带 `Access-Control-Request-Method` 和 `Access-Control-Request-Headers`，以及一个 `Origin`  的首部信息。\n\n举一个例子，在实际发送 `DELETE` 请求之前，会先向服务器发起一个预检 `OPTIONS` 请求：\n\n```\nOPTIONS /resource/foo\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: origin, x-requested-with\nOrigin: https://foo.bar.org\n```\n\n如果服务器允许，就会相应这个请求，并在response header里面返回允许的请求源和方法：\n\n```\nHTTP/1.1 200 OK\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Allow-Origin: https://foo.bar.org\nAccess-Control-Allow-Methods: POST, GET, OPTIONS, DELETE\nAccess-Control-Max-Age: 86400\n```\n\n这和开头的两种请求类型有什么关系呢？\n\n简单来说，`简单请求` 不会触发预检请求，而 `非简单请求` 则会触发。这么做的原因也很简单，是否允许CORS是在响应的Header里返回的，而`非简单请求` 都是可能会对服务器数据产生未预期影响的操作，比如删除，修改或者是带有其他Header信息，所以要通过 `OPTIONS` 预检请求来验证请求是否符合CORS规则，同时又不影响服务端数据。\n\n需要注意的是，Response Header里的 `Access-Control-Max-Age` 信息表示在86400秒，也就是24小时内，无需为统一请求再次发起预检请求。当然浏览器也会维护一个最大有效时间，如果Header中的最大有效时间超过了浏览器设置，则不会生效。\n\n## Response Header\n\n跟CORS相关的Response Header，日常工作中注意在服务端，反向代理或者CDN等设置中根据实际情况进行相应设置。\n\n```\n// 设置允许访问该资源的外域 URI\nAccess-Control-Allow-Origin: <origin> | *\n\n// 把允许浏览器访问的头放入白名单\nAccess-Control-Allow-Methods: <method>[, <method>]*\n\n// 用于预检请求的响应，其指明了实际请求所允许使用的 HTTP 方法\nAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header\n\n// 指定了 preflight 请求的结果能够被缓存多久\nAccess-Control-Max-Age: <delta-seconds>\n\n// 一个布尔值，表示是否允许发送Cookie，如果不需要浏览器传递cookie则不设置该值\nAccess-Control-Allow-Credentials: true\n```\n\n## 参考文献\n\n1. [跨源资源共享（CORS） - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n2. [跨域资源共享 CORS 详解 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2016/04/cors.html)\n\n","source":"_posts/跨域问题和CORS.md","raw":"---\ntitle: 跨域问题和CORS\ncategory_bar: true\ncategories: []\ndate: 2020-10-01 10:00:00\ntags: [网络]\n---\n\n## 什么是CORS\n\n所谓跨域，通俗来说就是该网站访问了其他origin（源，由域、协议和端口组成）的资源。\n\n浏览器发出的 `XMLHttpRequest` 请求有同源使用限制，默认情况下跨域请求是不被允许的。但是，每个源可以设置哪些其他源可以访问自己的资源，如果一个请求源A在源B的允许请求范围内，那么浏览器就允许请求源A对源B的跨域请求。这种检查机制就是跨源资源共享 (CORS)，是一种基于 HTTP 头的机制。\n\n## 简单请求和非简单请求\n\n在介绍CORS之前，首先要明确两种不同类型的请求，`简单请求` 和 `非简单请求`。 \n\n若请求 满足所有下述条件，则该请求可视为`简单请求`：\n\n使用下列方法之一：\n\n- GET\n- HEAD\n- POST\n\n请求的Headers只包含以下字段：\n\n- Accept\n- Accept-Language\n- Content-Language\n- Content-Type（需要注意额外的限制）\n- 请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。\n- 请求中没有使用 ReadableStream 对象。\n\nContent-Type 的值仅限于下列三者之一：\n- text/plain\n- multipart/form-data\n- application/x-www-form-urlencoded\n\n而不符合上述条件的则为 `非简单请求`。\n\n## CORS预检请求（Preflight request）\n\n浏览器会在必要的时候向服务器发送一个 `OPTIONS` 请求，用来检查服务器是否支持跨域资源共享即CORS。这个请求就叫预检请求（Preflight request）。\n\n请求通常携带 `Access-Control-Request-Method` 和 `Access-Control-Request-Headers`，以及一个 `Origin`  的首部信息。\n\n举一个例子，在实际发送 `DELETE` 请求之前，会先向服务器发起一个预检 `OPTIONS` 请求：\n\n```\nOPTIONS /resource/foo\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: origin, x-requested-with\nOrigin: https://foo.bar.org\n```\n\n如果服务器允许，就会相应这个请求，并在response header里面返回允许的请求源和方法：\n\n```\nHTTP/1.1 200 OK\nContent-Length: 0\nConnection: keep-alive\nAccess-Control-Allow-Origin: https://foo.bar.org\nAccess-Control-Allow-Methods: POST, GET, OPTIONS, DELETE\nAccess-Control-Max-Age: 86400\n```\n\n这和开头的两种请求类型有什么关系呢？\n\n简单来说，`简单请求` 不会触发预检请求，而 `非简单请求` 则会触发。这么做的原因也很简单，是否允许CORS是在响应的Header里返回的，而`非简单请求` 都是可能会对服务器数据产生未预期影响的操作，比如删除，修改或者是带有其他Header信息，所以要通过 `OPTIONS` 预检请求来验证请求是否符合CORS规则，同时又不影响服务端数据。\n\n需要注意的是，Response Header里的 `Access-Control-Max-Age` 信息表示在86400秒，也就是24小时内，无需为统一请求再次发起预检请求。当然浏览器也会维护一个最大有效时间，如果Header中的最大有效时间超过了浏览器设置，则不会生效。\n\n## Response Header\n\n跟CORS相关的Response Header，日常工作中注意在服务端，反向代理或者CDN等设置中根据实际情况进行相应设置。\n\n```\n// 设置允许访问该资源的外域 URI\nAccess-Control-Allow-Origin: <origin> | *\n\n// 把允许浏览器访问的头放入白名单\nAccess-Control-Allow-Methods: <method>[, <method>]*\n\n// 用于预检请求的响应，其指明了实际请求所允许使用的 HTTP 方法\nAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header\n\n// 指定了 preflight 请求的结果能够被缓存多久\nAccess-Control-Max-Age: <delta-seconds>\n\n// 一个布尔值，表示是否允许发送Cookie，如果不需要浏览器传递cookie则不设置该值\nAccess-Control-Allow-Credentials: true\n```\n\n## 参考文献\n\n1. [跨源资源共享（CORS） - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n2. [跨域资源共享 CORS 详解 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2016/04/cors.html)\n\n","slug":"跨域问题和CORS","published":1,"updated":"2022-11-01T02:16:55.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbeg00000k4lgqln2oh4","content":"<h2 id=\"什么是CORS\"><a href=\"#什么是CORS\" class=\"headerlink\" title=\"什么是CORS\"></a>什么是CORS</h2><p>所谓跨域，通俗来说就是该网站访问了其他origin（源，由域、协议和端口组成）的资源。</p>\n<p>浏览器发出的 <code>XMLHttpRequest</code> 请求有同源使用限制，默认情况下跨域请求是不被允许的。但是，每个源可以设置哪些其他源可以访问自己的资源，如果一个请求源A在源B的允许请求范围内，那么浏览器就允许请求源A对源B的跨域请求。这种检查机制就是跨源资源共享 (CORS)，是一种基于 HTTP 头的机制。</p>\n<h2 id=\"简单请求和非简单请求\"><a href=\"#简单请求和非简单请求\" class=\"headerlink\" title=\"简单请求和非简单请求\"></a>简单请求和非简单请求</h2><p>在介绍CORS之前，首先要明确两种不同类型的请求，<code>简单请求</code> 和 <code>非简单请求</code>。 </p>\n<p>若请求 满足所有下述条件，则该请求可视为<code>简单请求</code>：</p>\n<p>使用下列方法之一：</p>\n<ul>\n<li>GET</li>\n<li>HEAD</li>\n<li>POST</li>\n</ul>\n<p>请求的Headers只包含以下字段：</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Content-Type（需要注意额外的限制）</li>\n<li>请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。</li>\n<li>请求中没有使用 ReadableStream 对象。</li>\n</ul>\n<p>Content-Type 的值仅限于下列三者之一：</p>\n<ul>\n<li>text&#x2F;plain</li>\n<li>multipart&#x2F;form-data</li>\n<li>application&#x2F;x-www-form-urlencoded</li>\n</ul>\n<p>而不符合上述条件的则为 <code>非简单请求</code>。</p>\n<h2 id=\"CORS预检请求（Preflight-request）\"><a href=\"#CORS预检请求（Preflight-request）\" class=\"headerlink\" title=\"CORS预检请求（Preflight request）\"></a>CORS预检请求（Preflight request）</h2><p>浏览器会在必要的时候向服务器发送一个 <code>OPTIONS</code> 请求，用来检查服务器是否支持跨域资源共享即CORS。这个请求就叫预检请求（Preflight request）。</p>\n<p>请求通常携带 <code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code>，以及一个 <code>Origin</code>  的首部信息。</p>\n<p>举一个例子，在实际发送 <code>DELETE</code> 请求之前，会先向服务器发起一个预检 <code>OPTIONS</code> 请求：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\">OPTIONS /resource/foo<br>Access-Control-Request-<span class=\"hljs-keyword\">Method</span>: DELETE<br>Access-Control-Request-Headers: origin, x-requested-<span class=\"hljs-keyword\">with</span><br>Origin: https:<span class=\"hljs-comment\">//foo.bar.org</span><br></code></pre></td></tr></table></figure>\n\n<p>如果服务器允许，就会相应这个请求，并在response header里面返回允许的请求源和方法：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-meta\">HTTP/1.1</span> <span class=\"hljs-number\">200</span> OK<br><span class=\"hljs-attribute\">Content-Length</span><span class=\"hljs-punctuation\">: </span>0<br><span class=\"hljs-attribute\">Connection</span><span class=\"hljs-punctuation\">: </span>keep-alive<br><span class=\"hljs-attribute\">Access-Control-Allow-Origin</span><span class=\"hljs-punctuation\">: </span>https://foo.bar.org<br><span class=\"hljs-attribute\">Access-Control-Allow-Methods</span><span class=\"hljs-punctuation\">: </span>POST, GET, OPTIONS, DELETE<br><span class=\"hljs-attribute\">Access-Control-Max-Age</span><span class=\"hljs-punctuation\">: </span>86400<br></code></pre></td></tr></table></figure>\n\n<p>这和开头的两种请求类型有什么关系呢？</p>\n<p>简单来说，<code>简单请求</code> 不会触发预检请求，而 <code>非简单请求</code> 则会触发。这么做的原因也很简单，是否允许CORS是在响应的Header里返回的，而<code>非简单请求</code> 都是可能会对服务器数据产生未预期影响的操作，比如删除，修改或者是带有其他Header信息，所以要通过 <code>OPTIONS</code> 预检请求来验证请求是否符合CORS规则，同时又不影响服务端数据。</p>\n<p>需要注意的是，Response Header里的 <code>Access-Control-Max-Age</code> 信息表示在86400秒，也就是24小时内，无需为统一请求再次发起预检请求。当然浏览器也会维护一个最大有效时间，如果Header中的最大有效时间超过了浏览器设置，则不会生效。</p>\n<h2 id=\"Response-Header\"><a href=\"#Response-Header\" class=\"headerlink\" title=\"Response Header\"></a>Response Header</h2><p>跟CORS相关的Response Header，日常工作中注意在服务端，反向代理或者CDN等设置中根据实际情况进行相应设置。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"><span class=\"hljs-comment\">// 设置允许访问该资源的外域 URI</span><br>Access-Control-Allow-Origin: &lt;origin&gt; | *<br><br><span class=\"hljs-comment\">// 把允许浏览器访问的头放入白名单</span><br>Access-Control-Allow-Methods: &lt;<span class=\"hljs-keyword\">method</span>&gt;[, &lt;<span class=\"hljs-title function_\">method</span>&gt;]*<br><br>// 用于预检请求的响应，其指明了实际请求所允许使用的 <span class=\"hljs-title function_\">HTTP</span> 方法<br><span class=\"hljs-title function_\">Access</span>-<span class=\"hljs-title function_\">Control</span>-<span class=\"hljs-title function_\">Expose</span>-<span class=\"hljs-title function_\">Headers</span>: X-My-Custom-Header, X-Another-Custom-Header<br><br><span class=\"hljs-comment\">// 指定了 preflight 请求的结果能够被缓存多久</span><br>Access-Control-Max-Age: &lt;delta-seconds&gt;<br><br><span class=\"hljs-comment\">// 一个布尔值，表示是否允许发送Cookie，如果不需要浏览器传递cookie则不设置该值</span><br>Access-Control-Allow-Credentials: <span class=\"hljs-keyword\">true</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\">跨源资源共享（CORS） - HTTP | MDN</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解 - 阮一峰的网络日志</a></li>\n</ol>\n","site":{"data":{}},"wordcount":2034,"excerpt":"","more":"<h2 id=\"什么是CORS\"><a href=\"#什么是CORS\" class=\"headerlink\" title=\"什么是CORS\"></a>什么是CORS</h2><p>所谓跨域，通俗来说就是该网站访问了其他origin（源，由域、协议和端口组成）的资源。</p>\n<p>浏览器发出的 <code>XMLHttpRequest</code> 请求有同源使用限制，默认情况下跨域请求是不被允许的。但是，每个源可以设置哪些其他源可以访问自己的资源，如果一个请求源A在源B的允许请求范围内，那么浏览器就允许请求源A对源B的跨域请求。这种检查机制就是跨源资源共享 (CORS)，是一种基于 HTTP 头的机制。</p>\n<h2 id=\"简单请求和非简单请求\"><a href=\"#简单请求和非简单请求\" class=\"headerlink\" title=\"简单请求和非简单请求\"></a>简单请求和非简单请求</h2><p>在介绍CORS之前，首先要明确两种不同类型的请求，<code>简单请求</code> 和 <code>非简单请求</code>。 </p>\n<p>若请求 满足所有下述条件，则该请求可视为<code>简单请求</code>：</p>\n<p>使用下列方法之一：</p>\n<ul>\n<li>GET</li>\n<li>HEAD</li>\n<li>POST</li>\n</ul>\n<p>请求的Headers只包含以下字段：</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Content-Type（需要注意额外的限制）</li>\n<li>请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。</li>\n<li>请求中没有使用 ReadableStream 对象。</li>\n</ul>\n<p>Content-Type 的值仅限于下列三者之一：</p>\n<ul>\n<li>text&#x2F;plain</li>\n<li>multipart&#x2F;form-data</li>\n<li>application&#x2F;x-www-form-urlencoded</li>\n</ul>\n<p>而不符合上述条件的则为 <code>非简单请求</code>。</p>\n<h2 id=\"CORS预检请求（Preflight-request）\"><a href=\"#CORS预检请求（Preflight-request）\" class=\"headerlink\" title=\"CORS预检请求（Preflight request）\"></a>CORS预检请求（Preflight request）</h2><p>浏览器会在必要的时候向服务器发送一个 <code>OPTIONS</code> 请求，用来检查服务器是否支持跨域资源共享即CORS。这个请求就叫预检请求（Preflight request）。</p>\n<p>请求通常携带 <code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code>，以及一个 <code>Origin</code>  的首部信息。</p>\n<p>举一个例子，在实际发送 <code>DELETE</code> 请求之前，会先向服务器发起一个预检 <code>OPTIONS</code> 请求：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\">OPTIONS /resource/foo<br>Access-Control-Request-<span class=\"hljs-keyword\">Method</span>: DELETE<br>Access-Control-Request-Headers: origin, x-requested-<span class=\"hljs-keyword\">with</span><br>Origin: https:<span class=\"hljs-comment\">//foo.bar.org</span><br></code></pre></td></tr></table></figure>\n\n<p>如果服务器允许，就会相应这个请求，并在response header里面返回允许的请求源和方法：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-meta\">HTTP/1.1</span> <span class=\"hljs-number\">200</span> OK<br><span class=\"hljs-attribute\">Content-Length</span><span class=\"hljs-punctuation\">: </span>0<br><span class=\"hljs-attribute\">Connection</span><span class=\"hljs-punctuation\">: </span>keep-alive<br><span class=\"hljs-attribute\">Access-Control-Allow-Origin</span><span class=\"hljs-punctuation\">: </span>https://foo.bar.org<br><span class=\"hljs-attribute\">Access-Control-Allow-Methods</span><span class=\"hljs-punctuation\">: </span>POST, GET, OPTIONS, DELETE<br><span class=\"hljs-attribute\">Access-Control-Max-Age</span><span class=\"hljs-punctuation\">: </span>86400<br></code></pre></td></tr></table></figure>\n\n<p>这和开头的两种请求类型有什么关系呢？</p>\n<p>简单来说，<code>简单请求</code> 不会触发预检请求，而 <code>非简单请求</code> 则会触发。这么做的原因也很简单，是否允许CORS是在响应的Header里返回的，而<code>非简单请求</code> 都是可能会对服务器数据产生未预期影响的操作，比如删除，修改或者是带有其他Header信息，所以要通过 <code>OPTIONS</code> 预检请求来验证请求是否符合CORS规则，同时又不影响服务端数据。</p>\n<p>需要注意的是，Response Header里的 <code>Access-Control-Max-Age</code> 信息表示在86400秒，也就是24小时内，无需为统一请求再次发起预检请求。当然浏览器也会维护一个最大有效时间，如果Header中的最大有效时间超过了浏览器设置，则不会生效。</p>\n<h2 id=\"Response-Header\"><a href=\"#Response-Header\" class=\"headerlink\" title=\"Response Header\"></a>Response Header</h2><p>跟CORS相关的Response Header，日常工作中注意在服务端，反向代理或者CDN等设置中根据实际情况进行相应设置。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"><span class=\"hljs-comment\">// 设置允许访问该资源的外域 URI</span><br>Access-Control-Allow-Origin: &lt;origin&gt; | *<br><br><span class=\"hljs-comment\">// 把允许浏览器访问的头放入白名单</span><br>Access-Control-Allow-Methods: &lt;<span class=\"hljs-keyword\">method</span>&gt;[, &lt;<span class=\"hljs-title function_\">method</span>&gt;]*<br><br>// 用于预检请求的响应，其指明了实际请求所允许使用的 <span class=\"hljs-title function_\">HTTP</span> 方法<br><span class=\"hljs-title function_\">Access</span>-<span class=\"hljs-title function_\">Control</span>-<span class=\"hljs-title function_\">Expose</span>-<span class=\"hljs-title function_\">Headers</span>: X-My-Custom-Header, X-Another-Custom-Header<br><br><span class=\"hljs-comment\">// 指定了 preflight 请求的结果能够被缓存多久</span><br>Access-Control-Max-Age: &lt;delta-seconds&gt;<br><br><span class=\"hljs-comment\">// 一个布尔值，表示是否允许发送Cookie，如果不需要浏览器传递cookie则不设置该值</span><br>Access-Control-Allow-Credentials: <span class=\"hljs-keyword\">true</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\">跨源资源共享（CORS） - HTTP | MDN</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解 - 阮一峰的网络日志</a></li>\n</ol>\n"},{"title":"1011.D天内送达包裹的能力","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)\n\n承载能力的范围：[最大包裹重量，包裹总重量]\n\n承载能力范围中二分查找，找到让运输天数和需求天数相等的最小承载能力。运输天数小于需求天数时，承载能力可以再减小，反正则应该增大。\n\n每天包裹重量大于承载能力时需等到第二天继续运输。\n<!-- more -->\n```Go\nfunc shipWithinDays(weights []int, days int) int {\n    left, right := 0, 0\n    for _, w := range weights {\n        right += w\n        if left < w {\n            left = w\n        }\n    }\n\n    var day, sum int\n    result := right\n\n    for left <= right {\n        day = 1\n        sum = 0\n        mid := (left + right) / 2\n        // fmt.Printf(\"mid: %v\\n\", mid)\n\n\t\t// 每天包裹重量大于承载能力时需等到第二天继续运输\n        for _, w := range weights {\n            if sum + w > mid {\n                day++\n                sum = 0\n            } \n            sum += w\n        }\n        \n        // fmt.Printf(\"day: %v\\n\", day)\n\n        if day <= days {\n            if mid < result {\n                result = mid\n            }\n            right = mid - 1\n        }else {\n            left = mid + 1\n        }\n    }\n\n    return result\n}\n```\n","source":"_posts/算法/leetcode/1011.D天内送达包裹的能力.md","raw":"---\ntitle: 1011.D天内送达包裹的能力\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)\n\n承载能力的范围：[最大包裹重量，包裹总重量]\n\n承载能力范围中二分查找，找到让运输天数和需求天数相等的最小承载能力。运输天数小于需求天数时，承载能力可以再减小，反正则应该增大。\n\n每天包裹重量大于承载能力时需等到第二天继续运输。\n<!-- more -->\n```Go\nfunc shipWithinDays(weights []int, days int) int {\n    left, right := 0, 0\n    for _, w := range weights {\n        right += w\n        if left < w {\n            left = w\n        }\n    }\n\n    var day, sum int\n    result := right\n\n    for left <= right {\n        day = 1\n        sum = 0\n        mid := (left + right) / 2\n        // fmt.Printf(\"mid: %v\\n\", mid)\n\n\t\t// 每天包裹重量大于承载能力时需等到第二天继续运输\n        for _, w := range weights {\n            if sum + w > mid {\n                day++\n                sum = 0\n            } \n            sum += w\n        }\n        \n        // fmt.Printf(\"day: %v\\n\", day)\n\n        if day <= days {\n            if mid < result {\n                result = mid\n            }\n            right = mid - 1\n        }else {\n            left = mid + 1\n        }\n    }\n\n    return result\n}\n```\n","slug":"leetcode/1011.D天内送达包裹的能力","published":1,"category":"算法","updated":"2022-11-01T02:33:32.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbey00030k4ldw2zckm8","content":"<p><a href=\"https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/\">leetcode</a></p>\n<p>承载能力的范围：[最大包裹重量，包裹总重量]</p>\n<p>承载能力范围中二分查找，找到让运输天数和需求天数相等的最小承载能力。运输天数小于需求天数时，承载能力可以再减小，反正则应该增大。</p>\n<p>每天包裹重量大于承载能力时需等到第二天继续运输。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">shipWithinDays</span><span class=\"hljs-params\">(weights []<span class=\"hljs-type\">int</span>, days <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    left, right := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> _, w := <span class=\"hljs-keyword\">range</span> weights &#123;<br>        right += w<br>        <span class=\"hljs-keyword\">if</span> left &lt; w &#123;<br>            left = w<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> day, sum <span class=\"hljs-type\">int</span><br>    result := right<br><br>    <span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>        day = <span class=\"hljs-number\">1</span><br>        sum = <span class=\"hljs-number\">0</span><br>        mid := (left + right) / <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;mid: %v\\n&quot;, mid)</span><br><br>\t\t<span class=\"hljs-comment\">// 每天包裹重量大于承载能力时需等到第二天继续运输</span><br>        <span class=\"hljs-keyword\">for</span> _, w := <span class=\"hljs-keyword\">range</span> weights &#123;<br>            <span class=\"hljs-keyword\">if</span> sum + w &gt; mid &#123;<br>                day++<br>                sum = <span class=\"hljs-number\">0</span><br>            &#125; <br>            sum += w<br>        &#125;<br>        <br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;day: %v\\n&quot;, day)</span><br><br>        <span class=\"hljs-keyword\">if</span> day &lt;= days &#123;<br>            <span class=\"hljs-keyword\">if</span> mid &lt; result &#123;<br>                result = mid<br>            &#125;<br>            right = mid - <span class=\"hljs-number\">1</span><br>        &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>            left = mid + <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":701,"excerpt":"<p><a href=\"https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/\">leetcode</a></p>\n<p>承载能力的范围：[最大包裹重量，包裹总重量]</p>\n<p>承载能力范围中二分查找，找到让运输天数和需求天数相等的最小承载能力。运输天数小于需求天数时，承载能力可以再减小，反正则应该增大。</p>\n<p>每天包裹重量大于承载能力时需等到第二天继续运输。</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">shipWithinDays</span><span class=\"hljs-params\">(weights []<span class=\"hljs-type\">int</span>, days <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    left, right := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> _, w := <span class=\"hljs-keyword\">range</span> weights &#123;<br>        right += w<br>        <span class=\"hljs-keyword\">if</span> left &lt; w &#123;<br>            left = w<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> day, sum <span class=\"hljs-type\">int</span><br>    result := right<br><br>    <span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>        day = <span class=\"hljs-number\">1</span><br>        sum = <span class=\"hljs-number\">0</span><br>        mid := (left + right) / <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;mid: %v\\n&quot;, mid)</span><br><br>\t\t<span class=\"hljs-comment\">// 每天包裹重量大于承载能力时需等到第二天继续运输</span><br>        <span class=\"hljs-keyword\">for</span> _, w := <span class=\"hljs-keyword\">range</span> weights &#123;<br>            <span class=\"hljs-keyword\">if</span> sum + w &gt; mid &#123;<br>                day++<br>                sum = <span class=\"hljs-number\">0</span><br>            &#125; <br>            sum += w<br>        &#125;<br>        <br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;day: %v\\n&quot;, day)</span><br><br>        <span class=\"hljs-keyword\">if</span> day &lt;= days &#123;<br>            <span class=\"hljs-keyword\">if</span> mid &lt; result &#123;<br>                result = mid<br>            &#125;<br>            right = mid - <span class=\"hljs-number\">1</span><br>        &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>            left = mid + <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"125. 验证回文串","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n双指针\n\n时间复杂度： O(N)\n空间复杂度：O(N)\n\n<!-- more -->\n```Go\nfunc isPalindrome(s string) bool {\n    temp := strings.ToLower(s)\n\n    i, j := 0, len(temp) - 1\n\n    for i < j {\n        for i < j && !isAllowed(temp[i]) {\n            i++\n        }\n        for i < j && !isAllowed(temp[j]) {\n            j--\n        }\n\n        if temp[i] != temp[j] {\n            return false\n        } else {\n            i++\n            j--\n        }\n    }\n\n    return true\n}\n\nfunc isAllowed(ch byte) bool {\n    return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')\n}\n```\n","source":"_posts/算法/leetcode/125. 验证回文串.md","raw":"---\ntitle: 125. 验证回文串\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n双指针\n\n时间复杂度： O(N)\n空间复杂度：O(N)\n\n<!-- more -->\n```Go\nfunc isPalindrome(s string) bool {\n    temp := strings.ToLower(s)\n\n    i, j := 0, len(temp) - 1\n\n    for i < j {\n        for i < j && !isAllowed(temp[i]) {\n            i++\n        }\n        for i < j && !isAllowed(temp[j]) {\n            j--\n        }\n\n        if temp[i] != temp[j] {\n            return false\n        } else {\n            i++\n            j--\n        }\n    }\n\n    return true\n}\n\nfunc isAllowed(ch byte) bool {\n    return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')\n}\n```\n","slug":"leetcode/125. 验证回文串","published":1,"category":"算法","updated":"2022-11-01T02:33:32.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbf000040k4l4ttv4698","content":"<p>双指针</p>\n<p>时间复杂度： O(N)<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isPalindrome</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>    temp := strings.ToLower(s)<br><br>    i, j := <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(temp) - <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> i &lt; j &#123;<br>        <span class=\"hljs-keyword\">for</span> i &lt; j &amp;&amp; !isAllowed(temp[i]) &#123;<br>            i++<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> i &lt; j &amp;&amp; !isAllowed(temp[j]) &#123;<br>            j--<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> temp[i] != temp[j] &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            i++<br>            j--<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isAllowed</span><span class=\"hljs-params\">(ch <span class=\"hljs-type\">byte</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> (ch &gt;= <span class=\"hljs-string\">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class=\"hljs-string\">&#x27;9&#x27;</span>) || (ch &gt;= <span class=\"hljs-string\">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class=\"hljs-string\">&#x27;z&#x27;</span>) || (ch &gt;= <span class=\"hljs-string\">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class=\"hljs-string\">&#x27;Z&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":554,"excerpt":"<p>双指针</p>\n<p>时间复杂度： O(N)<br>空间复杂度：O(N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isPalindrome</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>    temp := strings.ToLower(s)<br><br>    i, j := <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(temp) - <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> i &lt; j &#123;<br>        <span class=\"hljs-keyword\">for</span> i &lt; j &amp;&amp; !isAllowed(temp[i]) &#123;<br>            i++<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> i &lt; j &amp;&amp; !isAllowed(temp[j]) &#123;<br>            j--<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> temp[i] != temp[j] &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            i++<br>            j--<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isAllowed</span><span class=\"hljs-params\">(ch <span class=\"hljs-type\">byte</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> (ch &gt;= <span class=\"hljs-string\">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class=\"hljs-string\">&#x27;9&#x27;</span>) || (ch &gt;= <span class=\"hljs-string\">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class=\"hljs-string\">&#x27;z&#x27;</span>) || (ch &gt;= <span class=\"hljs-string\">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class=\"hljs-string\">&#x27;Z&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"1334.阈值距离内邻居最少的城市","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\nFloyd算法计算所有点对之间最短路径。注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了。\n\n时间复杂度：O(N^3)\n空间复杂度：O(N^2)\n<!-- more -->\n```Go\nfunc findTheCity(n int, edges [][]int, distanceThreshold int) int {\n    // 构建邻接矩阵\n    d := make([][]int, n)\n\n    for i := 0; i < n; i++ {\n        d[i] = make([]int, n)\n        for j := 0; j < n; j++{\n            if i != j {\n                d[i][j] = math.MaxInt / 2\n            }\n        }\n    }\n\n    for _, edge := range edges {\n        x := edge[0]\n        y := edge[1]\n        z := edge[2]\n\n        d[x][y] = z\n        d[y][x] = z\n    }\n\n    // Floyd算法\n    // d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n    // 注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了\n    for k := 0; k < n; k++ {\n        for i := 0; i < n; i++ {\n            for j := 0; j < n; j++ {\n                if k != i && k != j {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n                }\n            }\n        }\n    }\n\n    // fmt.Printf(\"d[i][j]: %v\\n\", d)\n\n    minNeighboor := math.MaxInt / 2\n    ans := 0\n\n    for i := 0; i < n; i++ {\n        neighboor := 0\n        for j := 0; j < n; j++ {\n            if i != j && d[i][j] <= distanceThreshold {\n                neighboor++\n            }\n        }\n        if neighboor < minNeighboor || (neighboor == minNeighboor && i > ans) {\n            minNeighboor = neighboor\n            ans = i\n        }\n    }\n\n    return ans\n\n}\n\nfunc min(a, b int) int {\n    if (a > b){\n        return b\n    }\n    return a\n}\n```\n","source":"_posts/算法/leetcode/1334.阈值距离内邻居最少的城市.md","raw":"---\ntitle: 1334.阈值距离内邻居最少的城市\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\nFloyd算法计算所有点对之间最短路径。注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了。\n\n时间复杂度：O(N^3)\n空间复杂度：O(N^2)\n<!-- more -->\n```Go\nfunc findTheCity(n int, edges [][]int, distanceThreshold int) int {\n    // 构建邻接矩阵\n    d := make([][]int, n)\n\n    for i := 0; i < n; i++ {\n        d[i] = make([]int, n)\n        for j := 0; j < n; j++{\n            if i != j {\n                d[i][j] = math.MaxInt / 2\n            }\n        }\n    }\n\n    for _, edge := range edges {\n        x := edge[0]\n        y := edge[1]\n        z := edge[2]\n\n        d[x][y] = z\n        d[y][x] = z\n    }\n\n    // Floyd算法\n    // d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n    // 注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了\n    for k := 0; k < n; k++ {\n        for i := 0; i < n; i++ {\n            for j := 0; j < n; j++ {\n                if k != i && k != j {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n                }\n            }\n        }\n    }\n\n    // fmt.Printf(\"d[i][j]: %v\\n\", d)\n\n    minNeighboor := math.MaxInt / 2\n    ans := 0\n\n    for i := 0; i < n; i++ {\n        neighboor := 0\n        for j := 0; j < n; j++ {\n            if i != j && d[i][j] <= distanceThreshold {\n                neighboor++\n            }\n        }\n        if neighboor < minNeighboor || (neighboor == minNeighboor && i > ans) {\n            minNeighboor = neighboor\n            ans = i\n        }\n    }\n\n    return ans\n\n}\n\nfunc min(a, b int) int {\n    if (a > b){\n        return b\n    }\n    return a\n}\n```\n","slug":"leetcode/1334.阈值距离内邻居最少的城市","published":1,"category":"算法","updated":"2022-11-01T02:33:32.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbf400060k4l04ec24vy","content":"<p>Floyd算法计算所有点对之间最短路径。注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了。</p>\n<p>时间复杂度：O(N^3)<br>空间复杂度：O(N^2)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findTheCity</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>, edges [][]<span class=\"hljs-type\">int</span>, distanceThreshold <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// 构建邻接矩阵</span><br>    d := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        d[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; n; j++&#123;<br>            <span class=\"hljs-keyword\">if</span> i != j &#123;<br>                d[i][j] = math.MaxInt / <span class=\"hljs-number\">2</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> _, edge := <span class=\"hljs-keyword\">range</span> edges &#123;<br>        x := edge[<span class=\"hljs-number\">0</span>]<br>        y := edge[<span class=\"hljs-number\">1</span>]<br>        z := edge[<span class=\"hljs-number\">2</span>]<br><br>        d[x][y] = z<br>        d[y][x] = z<br>    &#125;<br><br>    <span class=\"hljs-comment\">// Floyd算法</span><br>    <span class=\"hljs-comment\">// d[i][j] = min(d[i][j], d[i][k] + d[k][j])</span><br>    <span class=\"hljs-comment\">// 注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了</span><br>    <span class=\"hljs-keyword\">for</span> k := <span class=\"hljs-number\">0</span>; k &lt; n; k++ &#123;<br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>            <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; n; j++ &#123;<br>                <span class=\"hljs-keyword\">if</span> k != i &amp;&amp; k != j &#123;<br>                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;d[i][j]: %v\\n&quot;, d)</span><br><br>    minNeighboor := math.MaxInt / <span class=\"hljs-number\">2</span><br>    ans := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        neighboor := <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; n; j++ &#123;<br>            <span class=\"hljs-keyword\">if</span> i != j &amp;&amp; d[i][j] &lt;= distanceThreshold &#123;<br>                neighboor++<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> neighboor &lt; minNeighboor || (neighboor == minNeighboor &amp;&amp; i &gt; ans) &#123;<br>            minNeighboor = neighboor<br>            ans = i<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (a &gt; b)&#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1120,"excerpt":"<p>Floyd算法计算所有点对之间最短路径。注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了。</p>\n<p>时间复杂度：O(N^3)<br>空间复杂度：O(N^2)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findTheCity</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>, edges [][]<span class=\"hljs-type\">int</span>, distanceThreshold <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// 构建邻接矩阵</span><br>    d := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        d[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; n; j++&#123;<br>            <span class=\"hljs-keyword\">if</span> i != j &#123;<br>                d[i][j] = math.MaxInt / <span class=\"hljs-number\">2</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> _, edge := <span class=\"hljs-keyword\">range</span> edges &#123;<br>        x := edge[<span class=\"hljs-number\">0</span>]<br>        y := edge[<span class=\"hljs-number\">1</span>]<br>        z := edge[<span class=\"hljs-number\">2</span>]<br><br>        d[x][y] = z<br>        d[y][x] = z<br>    &#125;<br><br>    <span class=\"hljs-comment\">// Floyd算法</span><br>    <span class=\"hljs-comment\">// d[i][j] = min(d[i][j], d[i][k] + d[k][j])</span><br>    <span class=\"hljs-comment\">// 注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了</span><br>    <span class=\"hljs-keyword\">for</span> k := <span class=\"hljs-number\">0</span>; k &lt; n; k++ &#123;<br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>            <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; n; j++ &#123;<br>                <span class=\"hljs-keyword\">if</span> k != i &amp;&amp; k != j &#123;<br>                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;d[i][j]: %v\\n&quot;, d)</span><br><br>    minNeighboor := math.MaxInt / <span class=\"hljs-number\">2</span><br>    ans := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        neighboor := <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; n; j++ &#123;<br>            <span class=\"hljs-keyword\">if</span> i != j &amp;&amp; d[i][j] &lt;= distanceThreshold &#123;<br>                neighboor++<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> neighboor &lt; minNeighboor || (neighboor == minNeighboor &amp;&amp; i &gt; ans) &#123;<br>            minNeighboor = neighboor<br>            ans = i<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (a &gt; b)&#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"130.被围绕的区域","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n广度优先遍历\n\n时间复杂度：O(n×m)\n空间复杂度：O(n×m)\n\nm,n为矩阵的行数和列数。\n<!-- more -->\n```Go\nfunc solve(board [][]byte)  {\n    rows := len(board)\n    cols := len(board[0])\n\n    dx := []int{-1, 0, 0, 1}\n    dy := []int{0, -1, 1, 0}\n\n    q := [][]int{}\n\n    var bfs func(int, int)\n\n    bfs = func(x int, y int) {\n        q = q[1:]\n\n        for i := 0; i < 4; i++ {\n            nx := x + dx[i]\n            ny := y + dy[i]\n\n            if nx >= 0 && nx < rows && ny >= 0 && ny < cols && board[nx][ny] == 'O' {\n                q = append(q, []int{nx, ny})\n                board[nx][ny] = '#'\n            }\n        }\n    }\n\n\t// 先处理四周的岛屿\n    for i := 0; i < rows; i++ {\n        if board[i][0] == 'O' {\n            q = append(q, []int{i, 0})\n            board[i][0] = '#'\n        }\n        if board[i][cols - 1] == 'O' {\n            q = append(q, []int{i, cols - 1})\n            board[i][cols-1] = '#'\n        }\n    }\n\n    for i := 1; i < cols - 1; i++ {\n        if board[0][i] == 'O' {\n            q = append(q, []int{0, i})\n            board[0][i] = '#'\n        }\n        if board[rows-1][i] == 'O' {\n            q = append(q, []int{rows - 1, i})\n            board[rows-1][i] = '#'\n        }\n    }\n\n    // fmt.Printf(\"board: %v\\n\", board)\n\n    for len(q) > 0 {\n        bfs(q[0][0], q[0][1])\n    }\n\n\t// 剩下的岛屿就是被围绕的岛屿，同时把四周的岛屿还原\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            if board[i][j] == '#' {\n                board[i][j] = 'O'\n            } else if board[i][j] == 'O' {\n                board[i][j] = 'X'\n            }\n        }\n    }\n\n}\n```\n","source":"_posts/算法/leetcode/130.被围绕的区域.md","raw":"---\ntitle: 130.被围绕的区域\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n广度优先遍历\n\n时间复杂度：O(n×m)\n空间复杂度：O(n×m)\n\nm,n为矩阵的行数和列数。\n<!-- more -->\n```Go\nfunc solve(board [][]byte)  {\n    rows := len(board)\n    cols := len(board[0])\n\n    dx := []int{-1, 0, 0, 1}\n    dy := []int{0, -1, 1, 0}\n\n    q := [][]int{}\n\n    var bfs func(int, int)\n\n    bfs = func(x int, y int) {\n        q = q[1:]\n\n        for i := 0; i < 4; i++ {\n            nx := x + dx[i]\n            ny := y + dy[i]\n\n            if nx >= 0 && nx < rows && ny >= 0 && ny < cols && board[nx][ny] == 'O' {\n                q = append(q, []int{nx, ny})\n                board[nx][ny] = '#'\n            }\n        }\n    }\n\n\t// 先处理四周的岛屿\n    for i := 0; i < rows; i++ {\n        if board[i][0] == 'O' {\n            q = append(q, []int{i, 0})\n            board[i][0] = '#'\n        }\n        if board[i][cols - 1] == 'O' {\n            q = append(q, []int{i, cols - 1})\n            board[i][cols-1] = '#'\n        }\n    }\n\n    for i := 1; i < cols - 1; i++ {\n        if board[0][i] == 'O' {\n            q = append(q, []int{0, i})\n            board[0][i] = '#'\n        }\n        if board[rows-1][i] == 'O' {\n            q = append(q, []int{rows - 1, i})\n            board[rows-1][i] = '#'\n        }\n    }\n\n    // fmt.Printf(\"board: %v\\n\", board)\n\n    for len(q) > 0 {\n        bfs(q[0][0], q[0][1])\n    }\n\n\t// 剩下的岛屿就是被围绕的岛屿，同时把四周的岛屿还原\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            if board[i][j] == '#' {\n                board[i][j] = 'O'\n            } else if board[i][j] == 'O' {\n                board[i][j] = 'X'\n            }\n        }\n    }\n\n}\n```\n","slug":"leetcode/130.被围绕的区域","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbf400070k4ld22hdkho","content":"<p>广度优先遍历</p>\n<p>时间复杂度：O(n×m)<br>空间复杂度：O(n×m)</p>\n<p>m,n为矩阵的行数和列数。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">solve</span><span class=\"hljs-params\">(board [][]<span class=\"hljs-type\">byte</span>)</span></span>  &#123;<br>    rows := <span class=\"hljs-built_in\">len</span>(board)<br>    cols := <span class=\"hljs-built_in\">len</span>(board[<span class=\"hljs-number\">0</span>])<br><br>    dx := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>&#125;<br>    dy := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>&#125;<br><br>    q := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">var</span> bfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span><br><br>    bfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">int</span>, y <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        q = q[<span class=\"hljs-number\">1</span>:]<br><br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++ &#123;<br>            nx := x + dx[i]<br>            ny := y + dy[i]<br><br>            <span class=\"hljs-keyword\">if</span> nx &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; ny &lt; cols &amp;&amp; board[nx][ny] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>                q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;nx, ny&#125;)<br>                board[nx][ny] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 先处理四周的岛屿</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; rows; i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> board[i][<span class=\"hljs-number\">0</span>] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>            q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;i, <span class=\"hljs-number\">0</span>&#125;)<br>            board[i][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> board[i][cols - <span class=\"hljs-number\">1</span>] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>            q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;i, cols - <span class=\"hljs-number\">1</span>&#125;)<br>            board[i][cols<span class=\"hljs-number\">-1</span>] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; cols - <span class=\"hljs-number\">1</span>; i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> board[<span class=\"hljs-number\">0</span>][i] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>            q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, i&#125;)<br>            board[<span class=\"hljs-number\">0</span>][i] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> board[rows<span class=\"hljs-number\">-1</span>][i] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>            q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;rows - <span class=\"hljs-number\">1</span>, i&#125;)<br>            board[rows<span class=\"hljs-number\">-1</span>][i] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;board: %v\\n&quot;, board)</span><br><br>    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(q) &gt; <span class=\"hljs-number\">0</span> &#123;<br>        bfs(q[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>], q[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>])<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 剩下的岛屿就是被围绕的岛屿，同时把四周的岛屿还原</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; rows; i++ &#123;<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; cols; j++ &#123;<br>            <span class=\"hljs-keyword\">if</span> board[i][j] == <span class=\"hljs-string\">&#x27;#&#x27;</span> &#123;<br>                board[i][j] = <span class=\"hljs-string\">&#x27;O&#x27;</span><br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> board[i][j] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>                board[i][j] = <span class=\"hljs-string\">&#x27;X&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1415,"excerpt":"<p>广度优先遍历</p>\n<p>时间复杂度：O(n×m)<br>空间复杂度：O(n×m)</p>\n<p>m,n为矩阵的行数和列数。</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">solve</span><span class=\"hljs-params\">(board [][]<span class=\"hljs-type\">byte</span>)</span></span>  &#123;<br>    rows := <span class=\"hljs-built_in\">len</span>(board)<br>    cols := <span class=\"hljs-built_in\">len</span>(board[<span class=\"hljs-number\">0</span>])<br><br>    dx := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>&#125;<br>    dy := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>&#125;<br><br>    q := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">var</span> bfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span><br><br>    bfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">int</span>, y <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        q = q[<span class=\"hljs-number\">1</span>:]<br><br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++ &#123;<br>            nx := x + dx[i]<br>            ny := y + dy[i]<br><br>            <span class=\"hljs-keyword\">if</span> nx &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; ny &lt; cols &amp;&amp; board[nx][ny] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>                q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;nx, ny&#125;)<br>                board[nx][ny] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 先处理四周的岛屿</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; rows; i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> board[i][<span class=\"hljs-number\">0</span>] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>            q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;i, <span class=\"hljs-number\">0</span>&#125;)<br>            board[i][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> board[i][cols - <span class=\"hljs-number\">1</span>] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>            q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;i, cols - <span class=\"hljs-number\">1</span>&#125;)<br>            board[i][cols<span class=\"hljs-number\">-1</span>] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; cols - <span class=\"hljs-number\">1</span>; i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> board[<span class=\"hljs-number\">0</span>][i] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>            q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, i&#125;)<br>            board[<span class=\"hljs-number\">0</span>][i] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> board[rows<span class=\"hljs-number\">-1</span>][i] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>            q = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;rows - <span class=\"hljs-number\">1</span>, i&#125;)<br>            board[rows<span class=\"hljs-number\">-1</span>][i] = <span class=\"hljs-string\">&#x27;#&#x27;</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;board: %v\\n&quot;, board)</span><br><br>    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(q) &gt; <span class=\"hljs-number\">0</span> &#123;<br>        bfs(q[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>], q[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>])<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 剩下的岛屿就是被围绕的岛屿，同时把四周的岛屿还原</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; rows; i++ &#123;<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; cols; j++ &#123;<br>            <span class=\"hljs-keyword\">if</span> board[i][j] == <span class=\"hljs-string\">&#x27;#&#x27;</span> &#123;<br>                board[i][j] = <span class=\"hljs-string\">&#x27;O&#x27;</span><br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> board[i][j] == <span class=\"hljs-string\">&#x27;O&#x27;</span> &#123;<br>                board[i][j] = <span class=\"hljs-string\">&#x27;X&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"120.三角形最小路径和","category_bar":true,"date":"2021-09-29T16:00:00.000Z","_content":"\n动态规划+空间优化\n\n状态转移方程： `dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])` \n\n应该记录一个二维数组dp，来维护每个位置的最小路径。但是由于是三角形结构，`dp[i][j]` 只跟 `dp[i-1][j-1]` 和 `dp[i-1][j]` 有关，使用一个一维数组来记录dp，倒序遍历，则计算 \n`i` 行的 `dp[j]` 时，`dp[j-1]` 和 `dp[j]` 还是 `i-1` 行的数据，并不影响计算。\n\n时间复杂度： O(n^2)\n空间复杂度： O(n)\n<!-- more -->\n```Go\nfunc minimumTotal(triangle [][]int) int {\n    // dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])\n\n    n := len(triangle)\n\n    if n == 1 {\n        return triangle[0][0]\n    }\n\n    dp := make([]int, n)\n    dp[0] = triangle[0][0]\n    ans := math.MaxInt\n\n    for i := 1; i < n; i++ {\n        for j := i; j >= 0; j-- {\n            if j == 0 {\n                dp[j] += triangle[i][j]\n            } else if j == i {\n                dp[j] = triangle[i][i] + dp[j-1]\n            } else if dp[j] < dp[j-1] {\n                dp[j] = triangle[i][j] + dp[j]\n            } else {\n                dp[j] = triangle[i][j] + dp[j-1]\n            }\n\n            if i == n - 1 {\n                if dp[j] < ans {\n                    ans = dp[j]\n                }\n            }\n            \n        }\n    }\n\n    return ans\n}\n```\n","source":"_posts/算法/leetcode/120.三角形最小路径和.md","raw":"---\ntitle: 120.三角形最小路径和\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-30 00:00:00\ntags:\n---\n\n动态规划+空间优化\n\n状态转移方程： `dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])` \n\n应该记录一个二维数组dp，来维护每个位置的最小路径。但是由于是三角形结构，`dp[i][j]` 只跟 `dp[i-1][j-1]` 和 `dp[i-1][j]` 有关，使用一个一维数组来记录dp，倒序遍历，则计算 \n`i` 行的 `dp[j]` 时，`dp[j-1]` 和 `dp[j]` 还是 `i-1` 行的数据，并不影响计算。\n\n时间复杂度： O(n^2)\n空间复杂度： O(n)\n<!-- more -->\n```Go\nfunc minimumTotal(triangle [][]int) int {\n    // dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])\n\n    n := len(triangle)\n\n    if n == 1 {\n        return triangle[0][0]\n    }\n\n    dp := make([]int, n)\n    dp[0] = triangle[0][0]\n    ans := math.MaxInt\n\n    for i := 1; i < n; i++ {\n        for j := i; j >= 0; j-- {\n            if j == 0 {\n                dp[j] += triangle[i][j]\n            } else if j == i {\n                dp[j] = triangle[i][i] + dp[j-1]\n            } else if dp[j] < dp[j-1] {\n                dp[j] = triangle[i][j] + dp[j]\n            } else {\n                dp[j] = triangle[i][j] + dp[j-1]\n            }\n\n            if i == n - 1 {\n                if dp[j] < ans {\n                    ans = dp[j]\n                }\n            }\n            \n        }\n    }\n\n    return ans\n}\n```\n","slug":"leetcode/120.三角形最小路径和","published":1,"category":"算法","updated":"2022-11-01T02:37:07.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbf500080k4lbjpxdoxi","content":"<p>动态规划+空间优化</p>\n<p>状态转移方程： <code>dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])</code> </p>\n<p>应该记录一个二维数组dp，来维护每个位置的最小路径。但是由于是三角形结构，<code>dp[i][j]</code> 只跟 <code>dp[i-1][j-1]</code> 和 <code>dp[i-1][j]</code> 有关，使用一个一维数组来记录dp，倒序遍历，则计算<br><code>i</code> 行的 <code>dp[j]</code> 时，<code>dp[j-1]</code> 和 <code>dp[j]</code> 还是 <code>i-1</code> 行的数据，并不影响计算。</p>\n<p>时间复杂度： O(n^2)<br>空间复杂度： O(n)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minimumTotal</span><span class=\"hljs-params\">(triangle [][]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])</span><br><br>    n := <span class=\"hljs-built_in\">len</span>(triangle)<br><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> triangle[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]<br>    &#125;<br><br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>    dp[<span class=\"hljs-number\">0</span>] = triangle[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]<br>    ans := math.MaxInt<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; n; i++ &#123;<br>        <span class=\"hljs-keyword\">for</span> j := i; j &gt;= <span class=\"hljs-number\">0</span>; j-- &#123;<br>            <span class=\"hljs-keyword\">if</span> j == <span class=\"hljs-number\">0</span> &#123;<br>                dp[j] += triangle[i][j]<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> j == i &#123;<br>                dp[j] = triangle[i][i] + dp[j<span class=\"hljs-number\">-1</span>]<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> dp[j] &lt; dp[j<span class=\"hljs-number\">-1</span>] &#123;<br>                dp[j] = triangle[i][j] + dp[j]<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                dp[j] = triangle[i][j] + dp[j<span class=\"hljs-number\">-1</span>]<br>            &#125;<br><br>            <span class=\"hljs-keyword\">if</span> i == n - <span class=\"hljs-number\">1</span> &#123;<br>                <span class=\"hljs-keyword\">if</span> dp[j] &lt; ans &#123;<br>                    ans = dp[j]<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":815,"excerpt":"<p>动态规划+空间优化</p>\n<p>状态转移方程： <code>dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])</code> </p>\n<p>应该记录一个二维数组dp，来维护每个位置的最小路径。但是由于是三角形结构，<code>dp[i][j]</code> 只跟 <code>dp[i-1][j-1]</code> 和 <code>dp[i-1][j]</code> 有关，使用一个一维数组来记录dp，倒序遍历，则计算<br><code>i</code> 行的 <code>dp[j]</code> 时，<code>dp[j-1]</code> 和 <code>dp[j]</code> 还是 <code>i-1</code> 行的数据，并不影响计算。</p>\n<p>时间复杂度： O(n^2)<br>空间复杂度： O(n)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minimumTotal</span><span class=\"hljs-params\">(triangle [][]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])</span><br><br>    n := <span class=\"hljs-built_in\">len</span>(triangle)<br><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> triangle[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]<br>    &#125;<br><br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>    dp[<span class=\"hljs-number\">0</span>] = triangle[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]<br>    ans := math.MaxInt<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; n; i++ &#123;<br>        <span class=\"hljs-keyword\">for</span> j := i; j &gt;= <span class=\"hljs-number\">0</span>; j-- &#123;<br>            <span class=\"hljs-keyword\">if</span> j == <span class=\"hljs-number\">0</span> &#123;<br>                dp[j] += triangle[i][j]<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> j == i &#123;<br>                dp[j] = triangle[i][i] + dp[j<span class=\"hljs-number\">-1</span>]<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> dp[j] &lt; dp[j<span class=\"hljs-number\">-1</span>] &#123;<br>                dp[j] = triangle[i][j] + dp[j]<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                dp[j] = triangle[i][j] + dp[j<span class=\"hljs-number\">-1</span>]<br>            &#125;<br><br>            <span class=\"hljs-keyword\">if</span> i == n - <span class=\"hljs-number\">1</span> &#123;<br>                <span class=\"hljs-keyword\">if</span> dp[j] &lt; ans &#123;<br>                    ans = dp[j]<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"136.邻值查找","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[Acwing](https://www.acwing.com/problem/content/138/)\n\n双向链表\n\n用排序后的双向链表维护每个数字前后相邻的两个数字用来计算最大绝对值。\n\n计算绝对值时根据原数组顺序从后往前遍历，处理完后则在链表中删除当前数字。\n\n时间复杂度：O(N)\n空间复杂度：O(N)\n<!-- more -->\n```Go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype Node struct {\n    Prev *Node\n    Next *Node\n    Val int\n    Index int\n}\n\nfunc main() {\n    var n int\n    fmt.Scan(&n)\n    \n    nums := make([][]int, n)\n    \n    for i := 0; i < n; i++ {\n        nums[i] = make([]int, 2)\n        fmt.Scanf(\"%d\", &nums[i][0])\n        nums[i][1] = i\n    }\n    \n    sort.Slice(nums, func(i, j int) bool {\n        return nums[i][0] < nums[j][0]\n    })\n    \n    head := &Node{\n        Index: -1,\n    }\n    prev := head\n    nodes := make([]*Node, n)\n    ans := make([][]int, n)\n    \n    for i := 0; i < n; i++ {\n        node := &Node{\n            Prev: prev,\n            Val: nums[i][0],\n            Index: nums[i][1],\n        }\n        \n        prev.Next = node\n        prev = node\n        nodes[nums[i][1]] = node\n        // fmt.Printf(\"%v, %v\\n\", nums[i][1], node)\n    }\n    \n    prev.Next =  &Node{\n            Index: n,\n        }\n    \n    for i := n - 1; i > 0; i--{\n        curr := nodes[i]\n        pn := nodes[i].Prev\n        nn := nodes[i].Next\n        \n\n        ans[i] = make([]int, 2)\n        // fmt.Printf(\"%v %v %v\\n\", p.Val, curr.Val, n.Val)\n        if nn.Index == n || (pn.Index != -1 && abs(pn.Val - curr.Val) <= abs(nn.Val - curr.Val)) {\n            ans[i][0] = abs(pn.Val - curr.Val)\n            ans[i][1] = pn.Index + 1\n        } else {\n            ans[i][0] = abs(nn.Val - curr.Val)\n            ans[i][1] = nn.Index + 1\n        }\n        \n        pn.Next = curr.Next\n        nn.Prev = pn\n    }\n    \n    for i := 1; i < n; i++ {\n        fmt.Printf(\"%v %v\\n\", ans[i][0], ans[i][1])\n    }\n    \n}\n\nfunc abs(a int) int {\n    if a < 0 {\n        return -a\n    }\n    return a\n}\n```\n","source":"_posts/算法/leetcode/136.邻值查找.md","raw":"---\ntitle: 136.邻值查找\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[Acwing](https://www.acwing.com/problem/content/138/)\n\n双向链表\n\n用排序后的双向链表维护每个数字前后相邻的两个数字用来计算最大绝对值。\n\n计算绝对值时根据原数组顺序从后往前遍历，处理完后则在链表中删除当前数字。\n\n时间复杂度：O(N)\n空间复杂度：O(N)\n<!-- more -->\n```Go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype Node struct {\n    Prev *Node\n    Next *Node\n    Val int\n    Index int\n}\n\nfunc main() {\n    var n int\n    fmt.Scan(&n)\n    \n    nums := make([][]int, n)\n    \n    for i := 0; i < n; i++ {\n        nums[i] = make([]int, 2)\n        fmt.Scanf(\"%d\", &nums[i][0])\n        nums[i][1] = i\n    }\n    \n    sort.Slice(nums, func(i, j int) bool {\n        return nums[i][0] < nums[j][0]\n    })\n    \n    head := &Node{\n        Index: -1,\n    }\n    prev := head\n    nodes := make([]*Node, n)\n    ans := make([][]int, n)\n    \n    for i := 0; i < n; i++ {\n        node := &Node{\n            Prev: prev,\n            Val: nums[i][0],\n            Index: nums[i][1],\n        }\n        \n        prev.Next = node\n        prev = node\n        nodes[nums[i][1]] = node\n        // fmt.Printf(\"%v, %v\\n\", nums[i][1], node)\n    }\n    \n    prev.Next =  &Node{\n            Index: n,\n        }\n    \n    for i := n - 1; i > 0; i--{\n        curr := nodes[i]\n        pn := nodes[i].Prev\n        nn := nodes[i].Next\n        \n\n        ans[i] = make([]int, 2)\n        // fmt.Printf(\"%v %v %v\\n\", p.Val, curr.Val, n.Val)\n        if nn.Index == n || (pn.Index != -1 && abs(pn.Val - curr.Val) <= abs(nn.Val - curr.Val)) {\n            ans[i][0] = abs(pn.Val - curr.Val)\n            ans[i][1] = pn.Index + 1\n        } else {\n            ans[i][0] = abs(nn.Val - curr.Val)\n            ans[i][1] = nn.Index + 1\n        }\n        \n        pn.Next = curr.Next\n        nn.Prev = pn\n    }\n    \n    for i := 1; i < n; i++ {\n        fmt.Printf(\"%v %v\\n\", ans[i][0], ans[i][1])\n    }\n    \n}\n\nfunc abs(a int) int {\n    if a < 0 {\n        return -a\n    }\n    return a\n}\n```\n","slug":"leetcode/136.邻值查找","published":1,"category":"算法","updated":"2022-11-01T02:33:32.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbf8000a0k4l2dev9pa7","content":"<p><a href=\"https://www.acwing.com/problem/content/138/\">Acwing</a></p>\n<p>双向链表</p>\n<p>用排序后的双向链表维护每个数字前后相邻的两个数字用来计算最大绝对值。</p>\n<p>计算绝对值时根据原数组顺序从后往前遍历，处理完后则在链表中删除当前数字。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>    <span class=\"hljs-string\">&quot;fmt&quot;</span><br>    <span class=\"hljs-string\">&quot;sort&quot;</span><br>)<br><br><span class=\"hljs-keyword\">type</span> Node <span class=\"hljs-keyword\">struct</span> &#123;<br>    Prev *Node<br>    Next *Node<br>    Val <span class=\"hljs-type\">int</span><br>    Index <span class=\"hljs-type\">int</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> n <span class=\"hljs-type\">int</span><br>    fmt.Scan(&amp;n)<br>    <br>    nums := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br>    <br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        nums[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>        fmt.Scanf(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;nums[i][<span class=\"hljs-number\">0</span>])<br>        nums[i][<span class=\"hljs-number\">1</span>] = i<br>    &#125;<br>    <br>    sort.Slice(nums, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i, j <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> nums[i][<span class=\"hljs-number\">0</span>] &lt; nums[j][<span class=\"hljs-number\">0</span>]<br>    &#125;)<br>    <br>    head := &amp;Node&#123;<br>        Index: <span class=\"hljs-number\">-1</span>,<br>    &#125;<br>    prev := head<br>    nodes := <span class=\"hljs-built_in\">make</span>([]*Node, n)<br>    ans := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br>    <br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        node := &amp;Node&#123;<br>            Prev: prev,<br>            Val: nums[i][<span class=\"hljs-number\">0</span>],<br>            Index: nums[i][<span class=\"hljs-number\">1</span>],<br>        &#125;<br>        <br>        prev.Next = node<br>        prev = node<br>        nodes[nums[i][<span class=\"hljs-number\">1</span>]] = node<br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;%v, %v\\n&quot;, nums[i][1], node)</span><br>    &#125;<br>    <br>    prev.Next =  &amp;Node&#123;<br>            Index: n,<br>        &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span> i := n - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; i--&#123;<br>        curr := nodes[i]<br>        pn := nodes[i].Prev<br>        nn := nodes[i].Next<br>        <br><br>        ans[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;%v %v %v\\n&quot;, p.Val, curr.Val, n.Val)</span><br>        <span class=\"hljs-keyword\">if</span> nn.Index == n || (pn.Index != <span class=\"hljs-number\">-1</span> &amp;&amp; abs(pn.Val - curr.Val) &lt;= abs(nn.Val - curr.Val)) &#123;<br>            ans[i][<span class=\"hljs-number\">0</span>] = abs(pn.Val - curr.Val)<br>            ans[i][<span class=\"hljs-number\">1</span>] = pn.Index + <span class=\"hljs-number\">1</span><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            ans[i][<span class=\"hljs-number\">0</span>] = abs(nn.Val - curr.Val)<br>            ans[i][<span class=\"hljs-number\">1</span>] = nn.Index + <span class=\"hljs-number\">1</span><br>        &#125;<br>        <br>        pn.Next = curr.Next<br>        nn.Prev = pn<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; n; i++ &#123;<br>        fmt.Printf(<span class=\"hljs-string\">&quot;%v %v\\n&quot;</span>, ans[i][<span class=\"hljs-number\">0</span>], ans[i][<span class=\"hljs-number\">1</span>])<br>    &#125;<br>    <br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">abs</span><span class=\"hljs-params\">(a <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &lt; <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> -a<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1473,"excerpt":"<p><a href=\"https://www.acwing.com/problem/content/138/\">Acwing</a></p>\n<p>双向链表</p>\n<p>用排序后的双向链表维护每个数字前后相邻的两个数字用来计算最大绝对值。</p>\n<p>计算绝对值时根据原数组顺序从后往前遍历，处理完后则在链表中删除当前数字。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>    <span class=\"hljs-string\">&quot;fmt&quot;</span><br>    <span class=\"hljs-string\">&quot;sort&quot;</span><br>)<br><br><span class=\"hljs-keyword\">type</span> Node <span class=\"hljs-keyword\">struct</span> &#123;<br>    Prev *Node<br>    Next *Node<br>    Val <span class=\"hljs-type\">int</span><br>    Index <span class=\"hljs-type\">int</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> n <span class=\"hljs-type\">int</span><br>    fmt.Scan(&amp;n)<br>    <br>    nums := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br>    <br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        nums[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>        fmt.Scanf(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;nums[i][<span class=\"hljs-number\">0</span>])<br>        nums[i][<span class=\"hljs-number\">1</span>] = i<br>    &#125;<br>    <br>    sort.Slice(nums, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i, j <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> nums[i][<span class=\"hljs-number\">0</span>] &lt; nums[j][<span class=\"hljs-number\">0</span>]<br>    &#125;)<br>    <br>    head := &amp;Node&#123;<br>        Index: <span class=\"hljs-number\">-1</span>,<br>    &#125;<br>    prev := head<br>    nodes := <span class=\"hljs-built_in\">make</span>([]*Node, n)<br>    ans := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br>    <br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        node := &amp;Node&#123;<br>            Prev: prev,<br>            Val: nums[i][<span class=\"hljs-number\">0</span>],<br>            Index: nums[i][<span class=\"hljs-number\">1</span>],<br>        &#125;<br>        <br>        prev.Next = node<br>        prev = node<br>        nodes[nums[i][<span class=\"hljs-number\">1</span>]] = node<br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;%v, %v\\n&quot;, nums[i][1], node)</span><br>    &#125;<br>    <br>    prev.Next =  &amp;Node&#123;<br>            Index: n,<br>        &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span> i := n - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; i--&#123;<br>        curr := nodes[i]<br>        pn := nodes[i].Prev<br>        nn := nodes[i].Next<br>        <br><br>        ans[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;%v %v %v\\n&quot;, p.Val, curr.Val, n.Val)</span><br>        <span class=\"hljs-keyword\">if</span> nn.Index == n || (pn.Index != <span class=\"hljs-number\">-1</span> &amp;&amp; abs(pn.Val - curr.Val) &lt;= abs(nn.Val - curr.Val)) &#123;<br>            ans[i][<span class=\"hljs-number\">0</span>] = abs(pn.Val - curr.Val)<br>            ans[i][<span class=\"hljs-number\">1</span>] = pn.Index + <span class=\"hljs-number\">1</span><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            ans[i][<span class=\"hljs-number\">0</span>] = abs(nn.Val - curr.Val)<br>            ans[i][<span class=\"hljs-number\">1</span>] = nn.Index + <span class=\"hljs-number\">1</span><br>        &#125;<br>        <br>        pn.Next = curr.Next<br>        nn.Prev = pn<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; n; i++ &#123;<br>        fmt.Printf(<span class=\"hljs-string\">&quot;%v %v\\n&quot;</span>, ans[i][<span class=\"hljs-number\">0</span>], ans[i][<span class=\"hljs-number\">1</span>])<br>    &#125;<br>    <br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">abs</span><span class=\"hljs-params\">(a <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &lt; <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> -a<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"152.乘积最大子数组","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n动态规划\n\n考虑当前数字为正还是为负，并维护前序乘积最大和最小数组。\n\n由于当前位置乘积最大值只与前一位置的乘积最大值或最小值有关，则可以优化数组为两个变量。\n\n时间复杂度： O(N)\n空间复杂度： O(1)\n<!-- more -->\n```Go\nfunc maxProduct(nums []int) int {\n    // nums[i] > 0\n    // dpMax[i] = max(dpMax[i-1] * nums[i], nums[i])\n    // dpMin[i] = min(dpMin[i-1] * nums[i], nums[i])\n    // nums[i] < 0\n    // dpMax[i] = max(dpMin[i-1] * nums[i], nums[i])\n    // dpMin[i] = min(dpMax[i-1] * nums[i], nums[i])\n    \n    dpMax := nums[0]\n    dpMin := nums[0]\n    ans := nums[0]\n    \n    for i := 1; i < len(nums); i++ {\n        if nums[i] > 0 {\n            dpMax = max(dpMax * nums[i], nums[i])\n            dpMin = min(dpMin * nums[i], nums[i])\n        } else {\n            temp := dpMax\n            dpMax = max(dpMin * nums[i], nums[i])\n            dpMin = min(temp * nums[i], nums[i])\n        }\n        ans = max(dpMax, ans)\n    }\n    \n    return ans\n}\n\nfunc max(a, b int) int {\n    if (a > b) {\n        return a\n    }\n    \n    return b\n}\n\nfunc min(a, b int) int {\n    if (a < b) {\n        return a\n    }\n    \n    return b\n}\n```\n","source":"_posts/算法/leetcode/152.乘积最大子数组.md","raw":"---\ntitle: 152.乘积最大子数组\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n动态规划\n\n考虑当前数字为正还是为负，并维护前序乘积最大和最小数组。\n\n由于当前位置乘积最大值只与前一位置的乘积最大值或最小值有关，则可以优化数组为两个变量。\n\n时间复杂度： O(N)\n空间复杂度： O(1)\n<!-- more -->\n```Go\nfunc maxProduct(nums []int) int {\n    // nums[i] > 0\n    // dpMax[i] = max(dpMax[i-1] * nums[i], nums[i])\n    // dpMin[i] = min(dpMin[i-1] * nums[i], nums[i])\n    // nums[i] < 0\n    // dpMax[i] = max(dpMin[i-1] * nums[i], nums[i])\n    // dpMin[i] = min(dpMax[i-1] * nums[i], nums[i])\n    \n    dpMax := nums[0]\n    dpMin := nums[0]\n    ans := nums[0]\n    \n    for i := 1; i < len(nums); i++ {\n        if nums[i] > 0 {\n            dpMax = max(dpMax * nums[i], nums[i])\n            dpMin = min(dpMin * nums[i], nums[i])\n        } else {\n            temp := dpMax\n            dpMax = max(dpMin * nums[i], nums[i])\n            dpMin = min(temp * nums[i], nums[i])\n        }\n        ans = max(dpMax, ans)\n    }\n    \n    return ans\n}\n\nfunc max(a, b int) int {\n    if (a > b) {\n        return a\n    }\n    \n    return b\n}\n\nfunc min(a, b int) int {\n    if (a < b) {\n        return a\n    }\n    \n    return b\n}\n```\n","slug":"leetcode/152.乘积最大子数组","published":1,"category":"算法","updated":"2022-11-01T02:33:31.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbf9000b0k4l9k820dgi","content":"<p>动态规划</p>\n<p>考虑当前数字为正还是为负，并维护前序乘积最大和最小数组。</p>\n<p>由于当前位置乘积最大值只与前一位置的乘积最大值或最小值有关，则可以优化数组为两个变量。</p>\n<p>时间复杂度： O(N)<br>空间复杂度： O(1)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxProduct</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// nums[i] &gt; 0</span><br>    <span class=\"hljs-comment\">// dpMax[i] = max(dpMax[i-1] * nums[i], nums[i])</span><br>    <span class=\"hljs-comment\">// dpMin[i] = min(dpMin[i-1] * nums[i], nums[i])</span><br>    <span class=\"hljs-comment\">// nums[i] &lt; 0</span><br>    <span class=\"hljs-comment\">// dpMax[i] = max(dpMin[i-1] * nums[i], nums[i])</span><br>    <span class=\"hljs-comment\">// dpMin[i] = min(dpMax[i-1] * nums[i], nums[i])</span><br>    <br>    dpMax := nums[<span class=\"hljs-number\">0</span>]<br>    dpMin := nums[<span class=\"hljs-number\">0</span>]<br>    ans := nums[<span class=\"hljs-number\">0</span>]<br>    <br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> nums[i] &gt; <span class=\"hljs-number\">0</span> &#123;<br>            dpMax = max(dpMax * nums[i], nums[i])<br>            dpMin = min(dpMin * nums[i], nums[i])<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            temp := dpMax<br>            dpMax = max(dpMin * nums[i], nums[i])<br>            dpMin = min(temp * nums[i], nums[i])<br>        &#125;<br>        ans = max(dpMax, ans)<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (a &gt; b) &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (a &lt; b) &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":823,"excerpt":"<p>动态规划</p>\n<p>考虑当前数字为正还是为负，并维护前序乘积最大和最小数组。</p>\n<p>由于当前位置乘积最大值只与前一位置的乘积最大值或最小值有关，则可以优化数组为两个变量。</p>\n<p>时间复杂度： O(N)<br>空间复杂度： O(1)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxProduct</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// nums[i] &gt; 0</span><br>    <span class=\"hljs-comment\">// dpMax[i] = max(dpMax[i-1] * nums[i], nums[i])</span><br>    <span class=\"hljs-comment\">// dpMin[i] = min(dpMin[i-1] * nums[i], nums[i])</span><br>    <span class=\"hljs-comment\">// nums[i] &lt; 0</span><br>    <span class=\"hljs-comment\">// dpMax[i] = max(dpMin[i-1] * nums[i], nums[i])</span><br>    <span class=\"hljs-comment\">// dpMin[i] = min(dpMax[i-1] * nums[i], nums[i])</span><br>    <br>    dpMax := nums[<span class=\"hljs-number\">0</span>]<br>    dpMin := nums[<span class=\"hljs-number\">0</span>]<br>    ans := nums[<span class=\"hljs-number\">0</span>]<br>    <br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> nums[i] &gt; <span class=\"hljs-number\">0</span> &#123;<br>            dpMax = max(dpMax * nums[i], nums[i])<br>            dpMin = min(dpMin * nums[i], nums[i])<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            temp := dpMax<br>            dpMax = max(dpMin * nums[i], nums[i])<br>            dpMin = min(temp * nums[i], nums[i])<br>        &#125;<br>        ans = max(dpMax, ans)<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (a &gt; b) &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (a &lt; b) &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"154. 寻找旋转排序数组中的最小值 2","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n使用二分法可以减少时间复杂度。注意有重复元素，遇到重复元素则可以删除一个，至少留有一个来参与最小值比较。\n<!-- more -->\n```Go\nfunc findMin(nums []int) int {\n    left, right := 0, len(nums) - 1\n\n    for left < right {\n        mid := (left + right) / 2\n        // 重复元素则去掉最右端的那个\n        if nums[mid] == nums[right] {\n            right--\n        }else if nums[mid] < nums[right] {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n\n    return nums[right]\n}\n```\n","source":"_posts/算法/leetcode/154. 寻找旋转排序数组中的最小值 2.md","raw":"---\ntitle: 154. 寻找旋转排序数组中的最小值 2\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n使用二分法可以减少时间复杂度。注意有重复元素，遇到重复元素则可以删除一个，至少留有一个来参与最小值比较。\n<!-- more -->\n```Go\nfunc findMin(nums []int) int {\n    left, right := 0, len(nums) - 1\n\n    for left < right {\n        mid := (left + right) / 2\n        // 重复元素则去掉最右端的那个\n        if nums[mid] == nums[right] {\n            right--\n        }else if nums[mid] < nums[right] {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n\n    return nums[right]\n}\n```\n","slug":"leetcode/154. 寻找旋转排序数组中的最小值 2","published":1,"category":"算法","updated":"2022-11-01T02:33:31.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfa000d0k4l2ctdaudh","content":"<p><a href=\"https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/\">leetcode</a></p>\n<p>使用二分法可以减少时间复杂度。注意有重复元素，遇到重复元素则可以删除一个，至少留有一个来参与最小值比较。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findMin</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    left, right := <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        mid := (left + right) / <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-comment\">// 重复元素则去掉最右端的那个</span><br>        <span class=\"hljs-keyword\">if</span> nums[mid] == nums[right] &#123;<br>            right--<br>        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &lt; nums[right] &#123;<br>            right = mid<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            left = mid + <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> nums[right]<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":346,"excerpt":"<p><a href=\"https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/\">leetcode</a></p>\n<p>使用二分法可以减少时间复杂度。注意有重复元素，遇到重复元素则可以删除一个，至少留有一个来参与最小值比较。</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findMin</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    left, right := <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        mid := (left + right) / <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-comment\">// 重复元素则去掉最右端的那个</span><br>        <span class=\"hljs-keyword\">if</span> nums[mid] == nums[right] &#123;<br>            right--<br>        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &lt; nums[right] &#123;<br>            right = mid<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            left = mid + <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> nums[right]<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"122.买卖股票的最佳时机 II","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n动态规划\n\n考虑两个状态，天数和当天是否持有股票，不同状态下当天持有的最大现金：\n\n> 当天持有股票：前一天持有并且当天不卖或者前一天没有当天买入。\n   当天没有持有股票：前一天没有持有并且当天不买或者前一天持有当天卖出。\n\n最后一天不持有股票状态下的现金为最大值。\n\n由于第n天的现金只与前一天的现金和是否持有股票有关，所以优化空间只用记录前一天持有和不持有股票的现金即可。\n\n时间复杂度： O(N)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc maxProfit(prices []int) int {\n    // dp[i][1] = max(dp[i-1][1], dp[i][0] - prices[i])\n    // dp[i][0] = max(dp[i-1][0], dp[i][1] + prices[i])\n    n := len(prices)\n\n    dp := make([]int, 2)\n    dp = []int{ 0, -prices[0] }\n\n    for i := 1; i < n; i++ {\n        temp0 := dp[0]\n        dp[0] = max(dp[0], dp[1] + prices[i])\n        dp[1] = max(dp[1], temp0 - prices[i])\n    }\n\n    return dp[0]\n\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    \n    return b\n}\n```\n","source":"_posts/算法/leetcode/122.买卖股票的最佳时机 II.md","raw":"---\ntitle: 122.买卖股票的最佳时机 II\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n动态规划\n\n考虑两个状态，天数和当天是否持有股票，不同状态下当天持有的最大现金：\n\n> 当天持有股票：前一天持有并且当天不卖或者前一天没有当天买入。\n   当天没有持有股票：前一天没有持有并且当天不买或者前一天持有当天卖出。\n\n最后一天不持有股票状态下的现金为最大值。\n\n由于第n天的现金只与前一天的现金和是否持有股票有关，所以优化空间只用记录前一天持有和不持有股票的现金即可。\n\n时间复杂度： O(N)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc maxProfit(prices []int) int {\n    // dp[i][1] = max(dp[i-1][1], dp[i][0] - prices[i])\n    // dp[i][0] = max(dp[i-1][0], dp[i][1] + prices[i])\n    n := len(prices)\n\n    dp := make([]int, 2)\n    dp = []int{ 0, -prices[0] }\n\n    for i := 1; i < n; i++ {\n        temp0 := dp[0]\n        dp[0] = max(dp[0], dp[1] + prices[i])\n        dp[1] = max(dp[1], temp0 - prices[i])\n    }\n\n    return dp[0]\n\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    \n    return b\n}\n```\n","slug":"leetcode/122.买卖股票的最佳时机 II","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfb000e0k4l2otp9tzv","content":"<p>动态规划</p>\n<p>考虑两个状态，天数和当天是否持有股票，不同状态下当天持有的最大现金：</p>\n<blockquote>\n<p>当天持有股票：前一天持有并且当天不卖或者前一天没有当天买入。<br>   当天没有持有股票：前一天没有持有并且当天不买或者前一天持有当天卖出。</p>\n</blockquote>\n<p>最后一天不持有股票状态下的现金为最大值。</p>\n<p>由于第n天的现金只与前一天的现金和是否持有股票有关，所以优化空间只用记录前一天持有和不持有股票的现金即可。</p>\n<p>时间复杂度： O(N)<br>空间复杂度：O(1)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxProfit</span><span class=\"hljs-params\">(prices []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// dp[i][1] = max(dp[i-1][1], dp[i][0] - prices[i])</span><br>    <span class=\"hljs-comment\">// dp[i][0] = max(dp[i-1][0], dp[i][1] + prices[i])</span><br>    n := <span class=\"hljs-built_in\">len</span>(prices)<br><br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>    dp = []<span class=\"hljs-type\">int</span>&#123; <span class=\"hljs-number\">0</span>, -prices[<span class=\"hljs-number\">0</span>] &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; n; i++ &#123;<br>        temp0 := dp[<span class=\"hljs-number\">0</span>]<br>        dp[<span class=\"hljs-number\">0</span>] = max(dp[<span class=\"hljs-number\">0</span>], dp[<span class=\"hljs-number\">1</span>] + prices[i])<br>        dp[<span class=\"hljs-number\">1</span>] = max(dp[<span class=\"hljs-number\">1</span>], temp0 - prices[i])<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> dp[<span class=\"hljs-number\">0</span>]<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":611,"excerpt":"<p>动态规划</p>\n<p>考虑两个状态，天数和当天是否持有股票，不同状态下当天持有的最大现金：</p>\n<blockquote>\n<p>当天持有股票：前一天持有并且当天不卖或者前一天没有当天买入。<br>   当天没有持有股票：前一天没有持有并且当天不买或者前一天持有当天卖出。</p>\n</blockquote>\n<p>最后一天不持有股票状态下的现金为最大值。</p>\n<p>由于第n天的现金只与前一天的现金和是否持有股票有关，所以优化空间只用记录前一天持有和不持有股票的现金即可。</p>\n<p>时间复杂度： O(N)<br>空间复杂度：O(1)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxProfit</span><span class=\"hljs-params\">(prices []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// dp[i][1] = max(dp[i-1][1], dp[i][0] - prices[i])</span><br>    <span class=\"hljs-comment\">// dp[i][0] = max(dp[i-1][0], dp[i][1] + prices[i])</span><br>    n := <span class=\"hljs-built_in\">len</span>(prices)<br><br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>    dp = []<span class=\"hljs-type\">int</span>&#123; <span class=\"hljs-number\">0</span>, -prices[<span class=\"hljs-number\">0</span>] &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; n; i++ &#123;<br>        temp0 := dp[<span class=\"hljs-number\">0</span>]<br>        dp[<span class=\"hljs-number\">0</span>] = max(dp[<span class=\"hljs-number\">0</span>], dp[<span class=\"hljs-number\">1</span>] + prices[i])<br>        dp[<span class=\"hljs-number\">1</span>] = max(dp[<span class=\"hljs-number\">1</span>], temp0 - prices[i])<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> dp[<span class=\"hljs-number\">0</span>]<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"1584.连接所有点的最小费用","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n最小生成树问题，Kruskal 算法\n\n任意一颗最小生成树一定包含无向图中权值最小的边。\n\n把任何一个生成森林扩展成最小生成树，一定使用了图中剩余边中权值最小的边。\n\n证明方法： 树上加一条边成环  + 反证法\n\n时间复杂度：O(N^2logN)\n空间复杂度：O(N^2)\n<!-- more -->\n```Go\n\nfunc minCostConnectPoints(points [][]int) int {\n    n := len(points)\n    groups := make([]int, n)\n    edges := [][]int{}\n    ans := 0\n\n    // 并查集\n    for i := 0; i < n; i++ {\n        groups[i] = i\n    }\n\n    var find func(int) int\n    find = func(i int) int {\n        if i == groups[i] {\n            return i\n        }\n        groups[i] = find(groups[i])\n        return groups[i]\n    }\n\n    union := func(x, y int) {\n        gx := find(x)\n        gy := find(y)\n\n        if gx != gy {\n            groups[gx] = gy\n        }\n    }\n\n    // 构建出边数组\n    for i := 0; i < n; i ++ {\n        for j := i + 1; j < n; j++ {\n            xi := points[i][0]\n            yi := points[i][1]\n            xj := points[j][0]\n            yj := points[j][1]\n\n            edges = append(edges, []int{i, j, abs(xi-xj) + abs(yi-yj)})\n        }\n    }\n\n    // 根据权重排序\n    sort.Slice(edges, func(i, j int) bool {\n        return edges[i][2] < edges[j][2]\n    })\n    \n    // 依次链接，计算费用\n    left := n - 1\n    for _, edge := range edges {\n        if left == 0 {\n            break\n        }\n        if find(edge[0]) == find(edge[1]) {\n            continue\n        }else{\n            union(edge[0], edge[1])\n            ans += edge[2]\n        }\n        left--\n    }\n\n    return ans\n}\n\nfunc abs(val int) int {\n    if val < 0 {\n        return -val\n    }\n    return val\n}\n```\n","source":"_posts/算法/leetcode/1584.连接所有点的最小费用.md","raw":"---\ntitle: 1584.连接所有点的最小费用\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n最小生成树问题，Kruskal 算法\n\n任意一颗最小生成树一定包含无向图中权值最小的边。\n\n把任何一个生成森林扩展成最小生成树，一定使用了图中剩余边中权值最小的边。\n\n证明方法： 树上加一条边成环  + 反证法\n\n时间复杂度：O(N^2logN)\n空间复杂度：O(N^2)\n<!-- more -->\n```Go\n\nfunc minCostConnectPoints(points [][]int) int {\n    n := len(points)\n    groups := make([]int, n)\n    edges := [][]int{}\n    ans := 0\n\n    // 并查集\n    for i := 0; i < n; i++ {\n        groups[i] = i\n    }\n\n    var find func(int) int\n    find = func(i int) int {\n        if i == groups[i] {\n            return i\n        }\n        groups[i] = find(groups[i])\n        return groups[i]\n    }\n\n    union := func(x, y int) {\n        gx := find(x)\n        gy := find(y)\n\n        if gx != gy {\n            groups[gx] = gy\n        }\n    }\n\n    // 构建出边数组\n    for i := 0; i < n; i ++ {\n        for j := i + 1; j < n; j++ {\n            xi := points[i][0]\n            yi := points[i][1]\n            xj := points[j][0]\n            yj := points[j][1]\n\n            edges = append(edges, []int{i, j, abs(xi-xj) + abs(yi-yj)})\n        }\n    }\n\n    // 根据权重排序\n    sort.Slice(edges, func(i, j int) bool {\n        return edges[i][2] < edges[j][2]\n    })\n    \n    // 依次链接，计算费用\n    left := n - 1\n    for _, edge := range edges {\n        if left == 0 {\n            break\n        }\n        if find(edge[0]) == find(edge[1]) {\n            continue\n        }else{\n            union(edge[0], edge[1])\n            ans += edge[2]\n        }\n        left--\n    }\n\n    return ans\n}\n\nfunc abs(val int) int {\n    if val < 0 {\n        return -val\n    }\n    return val\n}\n```\n","slug":"leetcode/1584.连接所有点的最小费用","published":1,"category":"算法","updated":"2022-11-01T02:38:36.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfc000g0k4lamic1by3","content":"<p>最小生成树问题，Kruskal 算法</p>\n<p>任意一颗最小生成树一定包含无向图中权值最小的边。</p>\n<p>把任何一个生成森林扩展成最小生成树，一定使用了图中剩余边中权值最小的边。</p>\n<p>证明方法： 树上加一条边成环  + 反证法</p>\n<p>时间复杂度：O(N^2logN)<br>空间复杂度：O(N^2)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minCostConnectPoints</span><span class=\"hljs-params\">(points [][]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    n := <span class=\"hljs-built_in\">len</span>(points)<br>    groups := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>    edges := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    ans := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-comment\">// 并查集</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        groups[i] = i<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> find <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span><br>    find = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> i == groups[i] &#123;<br>            <span class=\"hljs-keyword\">return</span> i<br>        &#125;<br>        groups[i] = find(groups[i])<br>        <span class=\"hljs-keyword\">return</span> groups[i]<br>    &#125;<br><br>    union := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        gx := find(x)<br>        gy := find(y)<br><br>        <span class=\"hljs-keyword\">if</span> gx != gy &#123;<br>            groups[gx] = gy<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 构建出边数组</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i ++ &#123;<br>        <span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; n; j++ &#123;<br>            xi := points[i][<span class=\"hljs-number\">0</span>]<br>            yi := points[i][<span class=\"hljs-number\">1</span>]<br>            xj := points[j][<span class=\"hljs-number\">0</span>]<br>            yj := points[j][<span class=\"hljs-number\">1</span>]<br><br>            edges = <span class=\"hljs-built_in\">append</span>(edges, []<span class=\"hljs-type\">int</span>&#123;i, j, abs(xi-xj) + abs(yi-yj)&#125;)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 根据权重排序</span><br>    sort.Slice(edges, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i, j <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> edges[i][<span class=\"hljs-number\">2</span>] &lt; edges[j][<span class=\"hljs-number\">2</span>]<br>    &#125;)<br>    <br>    <span class=\"hljs-comment\">// 依次链接，计算费用</span><br>    left := n - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">for</span> _, edge := <span class=\"hljs-keyword\">range</span> edges &#123;<br>        <span class=\"hljs-keyword\">if</span> left == <span class=\"hljs-number\">0</span> &#123;<br>            <span class=\"hljs-keyword\">break</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> find(edge[<span class=\"hljs-number\">0</span>]) == find(edge[<span class=\"hljs-number\">1</span>]) &#123;<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            union(edge[<span class=\"hljs-number\">0</span>], edge[<span class=\"hljs-number\">1</span>])<br>            ans += edge[<span class=\"hljs-number\">2</span>]<br>        &#125;<br>        left--<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">abs</span><span class=\"hljs-params\">(val <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> val &lt; <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> -val<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1177,"excerpt":"<p>最小生成树问题，Kruskal 算法</p>\n<p>任意一颗最小生成树一定包含无向图中权值最小的边。</p>\n<p>把任何一个生成森林扩展成最小生成树，一定使用了图中剩余边中权值最小的边。</p>\n<p>证明方法： 树上加一条边成环  + 反证法</p>\n<p>时间复杂度：O(N^2logN)<br>空间复杂度：O(N^2)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minCostConnectPoints</span><span class=\"hljs-params\">(points [][]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    n := <span class=\"hljs-built_in\">len</span>(points)<br>    groups := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>    edges := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    ans := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-comment\">// 并查集</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        groups[i] = i<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> find <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span><br>    find = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> i == groups[i] &#123;<br>            <span class=\"hljs-keyword\">return</span> i<br>        &#125;<br>        groups[i] = find(groups[i])<br>        <span class=\"hljs-keyword\">return</span> groups[i]<br>    &#125;<br><br>    union := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        gx := find(x)<br>        gy := find(y)<br><br>        <span class=\"hljs-keyword\">if</span> gx != gy &#123;<br>            groups[gx] = gy<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 构建出边数组</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i ++ &#123;<br>        <span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; n; j++ &#123;<br>            xi := points[i][<span class=\"hljs-number\">0</span>]<br>            yi := points[i][<span class=\"hljs-number\">1</span>]<br>            xj := points[j][<span class=\"hljs-number\">0</span>]<br>            yj := points[j][<span class=\"hljs-number\">1</span>]<br><br>            edges = <span class=\"hljs-built_in\">append</span>(edges, []<span class=\"hljs-type\">int</span>&#123;i, j, abs(xi-xj) + abs(yi-yj)&#125;)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 根据权重排序</span><br>    sort.Slice(edges, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i, j <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> edges[i][<span class=\"hljs-number\">2</span>] &lt; edges[j][<span class=\"hljs-number\">2</span>]<br>    &#125;)<br>    <br>    <span class=\"hljs-comment\">// 依次链接，计算费用</span><br>    left := n - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">for</span> _, edge := <span class=\"hljs-keyword\">range</span> edges &#123;<br>        <span class=\"hljs-keyword\">if</span> left == <span class=\"hljs-number\">0</span> &#123;<br>            <span class=\"hljs-keyword\">break</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> find(edge[<span class=\"hljs-number\">0</span>]) == find(edge[<span class=\"hljs-number\">1</span>]) &#123;<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            union(edge[<span class=\"hljs-number\">0</span>], edge[<span class=\"hljs-number\">1</span>])<br>            ans += edge[<span class=\"hljs-number\">2</span>]<br>        &#125;<br>        left--<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">abs</span><span class=\"hljs-params\">(val <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> val &lt; <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> -val<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"146.LRU缓存","category_bar":true,"date":"2021-09-29T16:00:00.000Z","_content":"<!-- more -->\n```Go\ntype LRUCache struct {\n  capacity int\n  size int\n  hashMap map[int]*DLinkNode\n  head, tail *DLinkNode\n}\n\ntype DLinkNode struct {\n  key, value int\n  prev *DLinkNode\n  next *DLinkNode\n}\n\nfunc NewDLinkNode(key, value int) *DLinkNode {\n  return &DLinkNode{\n    key: key,\n    value: value,\n  }\n}\n\nfunc Constructor(capacity int) LRUCache {\n  head := NewDLinkNode(0, 0)\n  tail := NewDLinkNode(0, 0)\n  head.next = tail\n  tail.prev = head\n\n  return LRUCache{\n    capacity: capacity, \n    hashMap: make(map[int]*DLinkNode),\n    head: head,\n    tail: tail,\n    size: 0,\n  }\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n  if node, ok := this.hashMap[key]; ok {\n    this.moveToHead(node)\n    return node.value\n  } else {\n    return -1\n  }\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n  node, ok := this.hashMap[key]\n  if ok {\n    node.value = value\n    this.moveToHead(node)\n  } else {\n    node = NewDLinkNode(key, value)\n    this.addToHead(node)\n    this.size++\n  }\n\n  if this.size > this.capacity {\n    delete(this.hashMap, this.tail.prev.key)\n    this.removeFromTail()\n    this.size--\n  }\n\n  this.hashMap[key] = node\n}\n\nfunc (this *LRUCache) removeNode(node *DLinkNode) {\n  node.prev.next = node.next\n  node.next.prev = node.prev\n}\n\nfunc (this *LRUCache) moveToHead(node *DLinkNode) {\n  this.removeNode(node)\n  this.addToHead(node)\n}\n\nfunc (this *LRUCache) addToHead(node *DLinkNode) {\n  node.prev = this.head\n  node.next = this.head.next\n  this.head.next.prev = node\n  this.head.next = node\n}\n\nfunc (this *LRUCache) removeFromTail() {\n  this.removeNode(this.tail.prev)\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n \n ```\n","source":"_posts/算法/leetcode/146.LRU缓存.md","raw":"---\ntitle: 146.LRU缓存\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-30 00:00:00\ntags:\n---\n<!-- more -->\n```Go\ntype LRUCache struct {\n  capacity int\n  size int\n  hashMap map[int]*DLinkNode\n  head, tail *DLinkNode\n}\n\ntype DLinkNode struct {\n  key, value int\n  prev *DLinkNode\n  next *DLinkNode\n}\n\nfunc NewDLinkNode(key, value int) *DLinkNode {\n  return &DLinkNode{\n    key: key,\n    value: value,\n  }\n}\n\nfunc Constructor(capacity int) LRUCache {\n  head := NewDLinkNode(0, 0)\n  tail := NewDLinkNode(0, 0)\n  head.next = tail\n  tail.prev = head\n\n  return LRUCache{\n    capacity: capacity, \n    hashMap: make(map[int]*DLinkNode),\n    head: head,\n    tail: tail,\n    size: 0,\n  }\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n  if node, ok := this.hashMap[key]; ok {\n    this.moveToHead(node)\n    return node.value\n  } else {\n    return -1\n  }\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n  node, ok := this.hashMap[key]\n  if ok {\n    node.value = value\n    this.moveToHead(node)\n  } else {\n    node = NewDLinkNode(key, value)\n    this.addToHead(node)\n    this.size++\n  }\n\n  if this.size > this.capacity {\n    delete(this.hashMap, this.tail.prev.key)\n    this.removeFromTail()\n    this.size--\n  }\n\n  this.hashMap[key] = node\n}\n\nfunc (this *LRUCache) removeNode(node *DLinkNode) {\n  node.prev.next = node.next\n  node.next.prev = node.prev\n}\n\nfunc (this *LRUCache) moveToHead(node *DLinkNode) {\n  this.removeNode(node)\n  this.addToHead(node)\n}\n\nfunc (this *LRUCache) addToHead(node *DLinkNode) {\n  node.prev = this.head\n  node.next = this.head.next\n  this.head.next.prev = node\n  this.head.next = node\n}\n\nfunc (this *LRUCache) removeFromTail() {\n  this.removeNode(this.tail.prev)\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n \n ```\n","slug":"leetcode/146.LRU缓存","published":1,"category":"算法","updated":"2022-11-01T02:37:27.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfc000h0k4l709jgp90","content":"<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> LRUCache <span class=\"hljs-keyword\">struct</span> &#123;<br>  capacity <span class=\"hljs-type\">int</span><br>  size <span class=\"hljs-type\">int</span><br>  hashMap <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]*DLinkNode<br>  head, tail *DLinkNode<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> DLinkNode <span class=\"hljs-keyword\">struct</span> &#123;<br>  key, value <span class=\"hljs-type\">int</span><br>  prev *DLinkNode<br>  next *DLinkNode<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewDLinkNode</span><span class=\"hljs-params\">(key, value <span class=\"hljs-type\">int</span>)</span></span> *DLinkNode &#123;<br>  <span class=\"hljs-keyword\">return</span> &amp;DLinkNode&#123;<br>    key: key,<br>    value: value,<br>  &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">(capacity <span class=\"hljs-type\">int</span>)</span></span> LRUCache &#123;<br>  head := NewDLinkNode(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)<br>  tail := NewDLinkNode(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)<br>  head.next = tail<br>  tail.prev = head<br><br>  <span class=\"hljs-keyword\">return</span> LRUCache&#123;<br>    capacity: capacity, <br>    hashMap: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]*DLinkNode),<br>    head: head,<br>    tail: tail,<br>    size: <span class=\"hljs-number\">0</span>,<br>  &#125;<br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> Get(key <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> node, ok := this.hashMap[key]; ok &#123;<br>    this.moveToHead(node)<br>    <span class=\"hljs-keyword\">return</span> node.value<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>  &#125;<br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> Put(key <span class=\"hljs-type\">int</span>, value <span class=\"hljs-type\">int</span>)  &#123;<br>  node, ok := this.hashMap[key]<br>  <span class=\"hljs-keyword\">if</span> ok &#123;<br>    node.value = value<br>    this.moveToHead(node)<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    node = NewDLinkNode(key, value)<br>    this.addToHead(node)<br>    this.size++<br>  &#125;<br><br>  <span class=\"hljs-keyword\">if</span> this.size &gt; this.capacity &#123;<br>    <span class=\"hljs-built_in\">delete</span>(this.hashMap, this.tail.prev.key)<br>    this.removeFromTail()<br>    this.size--<br>  &#125;<br><br>  this.hashMap[key] = node<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> removeNode(node *DLinkNode) &#123;<br>  node.prev.next = node.next<br>  node.next.prev = node.prev<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> moveToHead(node *DLinkNode) &#123;<br>  this.removeNode(node)<br>  this.addToHead(node)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> addToHead(node *DLinkNode) &#123;<br>  node.prev = this.head<br>  node.next = this.head.next<br>  this.head.next.prev = node<br>  this.head.next = node<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> removeFromTail() &#123;<br>  this.removeNode(this.tail.prev)<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Your LRUCache object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"> * obj := Constructor(capacity);</span><br><span class=\"hljs-comment\"> * param_1 := obj.Get(key);</span><br><span class=\"hljs-comment\"> * obj.Put(key,value);</span><br><span class=\"hljs-comment\"> */</span><br> <br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1711,"excerpt":"","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> LRUCache <span class=\"hljs-keyword\">struct</span> &#123;<br>  capacity <span class=\"hljs-type\">int</span><br>  size <span class=\"hljs-type\">int</span><br>  hashMap <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]*DLinkNode<br>  head, tail *DLinkNode<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> DLinkNode <span class=\"hljs-keyword\">struct</span> &#123;<br>  key, value <span class=\"hljs-type\">int</span><br>  prev *DLinkNode<br>  next *DLinkNode<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewDLinkNode</span><span class=\"hljs-params\">(key, value <span class=\"hljs-type\">int</span>)</span></span> *DLinkNode &#123;<br>  <span class=\"hljs-keyword\">return</span> &amp;DLinkNode&#123;<br>    key: key,<br>    value: value,<br>  &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">(capacity <span class=\"hljs-type\">int</span>)</span></span> LRUCache &#123;<br>  head := NewDLinkNode(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)<br>  tail := NewDLinkNode(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)<br>  head.next = tail<br>  tail.prev = head<br><br>  <span class=\"hljs-keyword\">return</span> LRUCache&#123;<br>    capacity: capacity, <br>    hashMap: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]*DLinkNode),<br>    head: head,<br>    tail: tail,<br>    size: <span class=\"hljs-number\">0</span>,<br>  &#125;<br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> Get(key <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> node, ok := this.hashMap[key]; ok &#123;<br>    this.moveToHead(node)<br>    <span class=\"hljs-keyword\">return</span> node.value<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>  &#125;<br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> Put(key <span class=\"hljs-type\">int</span>, value <span class=\"hljs-type\">int</span>)  &#123;<br>  node, ok := this.hashMap[key]<br>  <span class=\"hljs-keyword\">if</span> ok &#123;<br>    node.value = value<br>    this.moveToHead(node)<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    node = NewDLinkNode(key, value)<br>    this.addToHead(node)<br>    this.size++<br>  &#125;<br><br>  <span class=\"hljs-keyword\">if</span> this.size &gt; this.capacity &#123;<br>    <span class=\"hljs-built_in\">delete</span>(this.hashMap, this.tail.prev.key)<br>    this.removeFromTail()<br>    this.size--<br>  &#125;<br><br>  this.hashMap[key] = node<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> removeNode(node *DLinkNode) &#123;<br>  node.prev.next = node.next<br>  node.next.prev = node.prev<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> moveToHead(node *DLinkNode) &#123;<br>  this.removeNode(node)<br>  this.addToHead(node)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> addToHead(node *DLinkNode) &#123;<br>  node.prev = this.head<br>  node.next = this.head.next<br>  this.head.next.prev = node<br>  this.head.next = node<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *LRUCache)</span></span> removeFromTail() &#123;<br>  this.removeNode(this.tail.prev)<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Your LRUCache object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"> * obj := Constructor(capacity);</span><br><span class=\"hljs-comment\"> * param_1 := obj.Get(key);</span><br><span class=\"hljs-comment\"> * obj.Put(key,value);</span><br><span class=\"hljs-comment\"> */</span><br> <br></code></pre></td></tr></table></figure>"},{"title":"1091.二进制矩阵中的最短路径","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"<!-- more -->\n```Go\nfunc shortestPathBinaryMatrix(grid [][]int) int {\n\tn := len(grid)\n\tif grid[0][0] == 1 {\n\t\treturn -1\n\t}\n\tif n == 1 {\n\t\treturn 1\n\t}\n\n\tq := [][]int{}\n\tvisited := make([][]bool, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tvisited[i] = make([]bool, n)\n\t}\n\tvisited[0][0] = true\n\n\tans := -1\n\tvar bfs func()\n\tvar valid func(int, int) bool\n\n\t// row col\n\tq = append(q, []int{0, 0, 1})\n\n\tbfs = func() {\n\t\tfor len(q) > 0 {\n\t\t\tcurr := q[0]\n\t\t\tq = q[1:]\n\n\t\t\tdx := []int{1, 1, 0, -1, 1, 0, -1, -1}\n\t\t\tdy := []int{1, 0, 1, 1, -1, -1, 0, -1}\n\n\t\t\tfor i := 0; i < 8; i++ {\n\t\t\t\trow := curr[0] + dy[i]\n\t\t\t\tcol := curr[1] + dx[i]\n\n\t\t\t\tif valid(row, col) {\n\t\t\t\t\tvisited[row][col] = true\n\t\t\t\t\tif row == n-1 && col == n-1 {\n\t\t\t\t\t\tans = curr[2] + 1\n\t\t\t\t\t}\n\t\t\t\t\tq = append(q, []int{row, col, curr[2] + 1})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvalid = func(row, col int) bool {\n\t\tif row < 0 || col < 0 || row >= n || col >= n || visited[row][col] {\n\t\t\treturn false\n\t\t}\n\n\t\treturn grid[row][col] == 0\n\t}\n\n\tbfs()\n\treturn ans\n}\n\nfunc powInt(x, y int) int {\n\treturn int(math.Pow(float64(x), float64(y)))\n}\n```\n","source":"_posts/算法/leetcode/1091.二进制矩阵中的最短路径.md","raw":"---\ntitle: 1091.二进制矩阵中的最短路径\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n<!-- more -->\n```Go\nfunc shortestPathBinaryMatrix(grid [][]int) int {\n\tn := len(grid)\n\tif grid[0][0] == 1 {\n\t\treturn -1\n\t}\n\tif n == 1 {\n\t\treturn 1\n\t}\n\n\tq := [][]int{}\n\tvisited := make([][]bool, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tvisited[i] = make([]bool, n)\n\t}\n\tvisited[0][0] = true\n\n\tans := -1\n\tvar bfs func()\n\tvar valid func(int, int) bool\n\n\t// row col\n\tq = append(q, []int{0, 0, 1})\n\n\tbfs = func() {\n\t\tfor len(q) > 0 {\n\t\t\tcurr := q[0]\n\t\t\tq = q[1:]\n\n\t\t\tdx := []int{1, 1, 0, -1, 1, 0, -1, -1}\n\t\t\tdy := []int{1, 0, 1, 1, -1, -1, 0, -1}\n\n\t\t\tfor i := 0; i < 8; i++ {\n\t\t\t\trow := curr[0] + dy[i]\n\t\t\t\tcol := curr[1] + dx[i]\n\n\t\t\t\tif valid(row, col) {\n\t\t\t\t\tvisited[row][col] = true\n\t\t\t\t\tif row == n-1 && col == n-1 {\n\t\t\t\t\t\tans = curr[2] + 1\n\t\t\t\t\t}\n\t\t\t\t\tq = append(q, []int{row, col, curr[2] + 1})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvalid = func(row, col int) bool {\n\t\tif row < 0 || col < 0 || row >= n || col >= n || visited[row][col] {\n\t\t\treturn false\n\t\t}\n\n\t\treturn grid[row][col] == 0\n\t}\n\n\tbfs()\n\treturn ans\n}\n\nfunc powInt(x, y int) int {\n\treturn int(math.Pow(float64(x), float64(y)))\n}\n```\n","slug":"leetcode/1091.二进制矩阵中的最短路径","published":1,"category":"算法","updated":"2022-11-01T02:33:31.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfd000j0k4l3rin5j9f","content":"<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">shortestPathBinaryMatrix</span><span class=\"hljs-params\">(grid [][]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tn := <span class=\"hljs-built_in\">len</span>(grid)<br>\t<span class=\"hljs-keyword\">if</span> grid[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>\t&#125;<br><br>\tq := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\tvisited := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">bool</span>, n)<br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>\t\tvisited[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, n)<br>\t&#125;<br>\tvisited[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-literal\">true</span><br><br>\tans := <span class=\"hljs-number\">-1</span><br>\t<span class=\"hljs-keyword\">var</span> bfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span><br>\t<span class=\"hljs-keyword\">var</span> valid <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span><br><br>\t<span class=\"hljs-comment\">// row col</span><br>\tq = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>&#125;)<br><br>\tbfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(q) &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\tcurr := q[<span class=\"hljs-number\">0</span>]<br>\t\t\tq = q[<span class=\"hljs-number\">1</span>:]<br><br>\t\t\tdx := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>\t\t\tdy := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>&#125;<br><br>\t\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">8</span>; i++ &#123;<br>\t\t\t\trow := curr[<span class=\"hljs-number\">0</span>] + dy[i]<br>\t\t\t\tcol := curr[<span class=\"hljs-number\">1</span>] + dx[i]<br><br>\t\t\t\t<span class=\"hljs-keyword\">if</span> valid(row, col) &#123;<br>\t\t\t\t\tvisited[row][col] = <span class=\"hljs-literal\">true</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> row == n<span class=\"hljs-number\">-1</span> &amp;&amp; col == n<span class=\"hljs-number\">-1</span> &#123;<br>\t\t\t\t\t\tans = curr[<span class=\"hljs-number\">2</span>] + <span class=\"hljs-number\">1</span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tq = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;row, col, curr[<span class=\"hljs-number\">2</span>] + <span class=\"hljs-number\">1</span>&#125;)<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br><br>\tvalid = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(row, col <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> row &lt; <span class=\"hljs-number\">0</span> || col &lt; <span class=\"hljs-number\">0</span> || row &gt;= n || col &gt;= n || visited[row][col] &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> grid[row][col] == <span class=\"hljs-number\">0</span><br>\t&#125;<br><br>\tbfs()<br>\t<span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">powInt</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">int</span>(math.Pow(<span class=\"hljs-type\">float64</span>(x), <span class=\"hljs-type\">float64</span>(y)))<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1041,"excerpt":"","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">shortestPathBinaryMatrix</span><span class=\"hljs-params\">(grid [][]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tn := <span class=\"hljs-built_in\">len</span>(grid)<br>\t<span class=\"hljs-keyword\">if</span> grid[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>\t&#125;<br><br>\tq := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\tvisited := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">bool</span>, n)<br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>\t\tvisited[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, n)<br>\t&#125;<br>\tvisited[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-literal\">true</span><br><br>\tans := <span class=\"hljs-number\">-1</span><br>\t<span class=\"hljs-keyword\">var</span> bfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span><br>\t<span class=\"hljs-keyword\">var</span> valid <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span><br><br>\t<span class=\"hljs-comment\">// row col</span><br>\tq = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>&#125;)<br><br>\tbfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(q) &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\tcurr := q[<span class=\"hljs-number\">0</span>]<br>\t\t\tq = q[<span class=\"hljs-number\">1</span>:]<br><br>\t\t\tdx := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>\t\t\tdy := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>&#125;<br><br>\t\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">8</span>; i++ &#123;<br>\t\t\t\trow := curr[<span class=\"hljs-number\">0</span>] + dy[i]<br>\t\t\t\tcol := curr[<span class=\"hljs-number\">1</span>] + dx[i]<br><br>\t\t\t\t<span class=\"hljs-keyword\">if</span> valid(row, col) &#123;<br>\t\t\t\t\tvisited[row][col] = <span class=\"hljs-literal\">true</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> row == n<span class=\"hljs-number\">-1</span> &amp;&amp; col == n<span class=\"hljs-number\">-1</span> &#123;<br>\t\t\t\t\t\tans = curr[<span class=\"hljs-number\">2</span>] + <span class=\"hljs-number\">1</span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tq = <span class=\"hljs-built_in\">append</span>(q, []<span class=\"hljs-type\">int</span>&#123;row, col, curr[<span class=\"hljs-number\">2</span>] + <span class=\"hljs-number\">1</span>&#125;)<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br><br>\tvalid = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(row, col <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> row &lt; <span class=\"hljs-number\">0</span> || col &lt; <span class=\"hljs-number\">0</span> || row &gt;= n || col &gt;= n || visited[row][col] &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> grid[row][col] == <span class=\"hljs-number\">0</span><br>\t&#125;<br><br>\tbfs()<br>\t<span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">powInt</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">int</span>(math.Pow(<span class=\"hljs-type\">float64</span>(x), <span class=\"hljs-type\">float64</span>(y)))<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"22.括号生成","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/generate-parentheses/submissions/)\n\n先选定一对括号，生成的序列可以写为`(left)right`，其中 `left` 和 `right` 分别为 `i` 对括号和 `n-i-1` 对括号的序列。\n\n再利用递归计算 `left` 和 `right` 。\n\n时间复杂度：O(4n/√n)\n空间复杂度：O(4n/√n)\n<!-- more -->\n```Go\nvar cache = make(map[int][]string)\n\nfunc generateParenthesis(n int) []string {\n    return generate(n)\n}\n\nfunc generate(n int) []string {\n    if n == 0 {\n        return []string{\"\"}\n    }\n\n    if n == 1 {\n        return []string{\"()\"}\n    }\n\n    if c, ok := cache[n]; ok {\n        return c\n    }\n\n    result := []string{}\n    for i := 0; i < n; i++ {\n        left := generate(i)\n        right := generate(n - i -1)\n        \n        for _, l := range left {\n            temp := fmt.Sprintf(\"(%s)\", l)\n            for _, r := range right {\n                result = append(result, fmt.Sprintf(\"%s%s\", temp, r))\n            }\n        }\n\n    }\n\n    cache[n] = result\n    return result\n}\n```\n","source":"_posts/算法/leetcode/22.括号生成.md","raw":"---\ntitle: 22.括号生成\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/generate-parentheses/submissions/)\n\n先选定一对括号，生成的序列可以写为`(left)right`，其中 `left` 和 `right` 分别为 `i` 对括号和 `n-i-1` 对括号的序列。\n\n再利用递归计算 `left` 和 `right` 。\n\n时间复杂度：O(4n/√n)\n空间复杂度：O(4n/√n)\n<!-- more -->\n```Go\nvar cache = make(map[int][]string)\n\nfunc generateParenthesis(n int) []string {\n    return generate(n)\n}\n\nfunc generate(n int) []string {\n    if n == 0 {\n        return []string{\"\"}\n    }\n\n    if n == 1 {\n        return []string{\"()\"}\n    }\n\n    if c, ok := cache[n]; ok {\n        return c\n    }\n\n    result := []string{}\n    for i := 0; i < n; i++ {\n        left := generate(i)\n        right := generate(n - i -1)\n        \n        for _, l := range left {\n            temp := fmt.Sprintf(\"(%s)\", l)\n            for _, r := range right {\n                result = append(result, fmt.Sprintf(\"%s%s\", temp, r))\n            }\n        }\n\n    }\n\n    cache[n] = result\n    return result\n}\n```\n","slug":"leetcode/22.括号生成","published":1,"category":"算法","updated":"2022-11-01T02:33:32.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfe000k0k4l9tx44h4g","content":"<p><a href=\"https://leetcode.cn/problems/generate-parentheses/submissions/\">leetcode</a></p>\n<p>先选定一对括号，生成的序列可以写为<code>(left)right</code>，其中 <code>left</code> 和 <code>right</code> 分别为 <code>i</code> 对括号和 <code>n-i-1</code> 对括号的序列。</p>\n<p>再利用递归计算 <code>left</code> 和 <code>right</code> 。</p>\n<p>时间复杂度：O(4n&#x2F;√n)<br>空间复杂度：O(4n&#x2F;√n)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">var</span> cache = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>][]<span class=\"hljs-type\">string</span>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">generateParenthesis</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> generate(n)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">generate</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;&quot;</span>&#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;()&quot;</span>&#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> c, ok := cache[n]; ok &#123;<br>        <span class=\"hljs-keyword\">return</span> c<br>    &#125;<br><br>    result := []<span class=\"hljs-type\">string</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        left := generate(i)<br>        right := generate(n - i <span class=\"hljs-number\">-1</span>)<br>        <br>        <span class=\"hljs-keyword\">for</span> _, l := <span class=\"hljs-keyword\">range</span> left &#123;<br>            temp := fmt.Sprintf(<span class=\"hljs-string\">&quot;(%s)&quot;</span>, l)<br>            <span class=\"hljs-keyword\">for</span> _, r := <span class=\"hljs-keyword\">range</span> right &#123;<br>                result = <span class=\"hljs-built_in\">append</span>(result, fmt.Sprintf(<span class=\"hljs-string\">&quot;%s%s&quot;</span>, temp, r))<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    cache[n] = result<br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":753,"excerpt":"<p><a href=\"https://leetcode.cn/problems/generate-parentheses/submissions/\">leetcode</a></p>\n<p>先选定一对括号，生成的序列可以写为<code>(left)right</code>，其中 <code>left</code> 和 <code>right</code> 分别为 <code>i</code> 对括号和 <code>n-i-1</code> 对括号的序列。</p>\n<p>再利用递归计算 <code>left</code> 和 <code>right</code> 。</p>\n<p>时间复杂度：O(4n&#x2F;√n)<br>空间复杂度：O(4n&#x2F;√n)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">var</span> cache = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>][]<span class=\"hljs-type\">string</span>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">generateParenthesis</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> generate(n)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">generate</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;&quot;</span>&#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;()&quot;</span>&#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> c, ok := cache[n]; ok &#123;<br>        <span class=\"hljs-keyword\">return</span> c<br>    &#125;<br><br>    result := []<span class=\"hljs-type\">string</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        left := generate(i)<br>        right := generate(n - i <span class=\"hljs-number\">-1</span>)<br>        <br>        <span class=\"hljs-keyword\">for</span> _, l := <span class=\"hljs-keyword\">range</span> left &#123;<br>            temp := fmt.Sprintf(<span class=\"hljs-string\">&quot;(%s)&quot;</span>, l)<br>            <span class=\"hljs-keyword\">for</span> _, r := <span class=\"hljs-keyword\">range</span> right &#123;<br>                result = <span class=\"hljs-built_in\">append</span>(result, fmt.Sprintf(<span class=\"hljs-string\">&quot;%s%s&quot;</span>, temp, r))<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    cache[n] = result<br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"198.打家劫舍","category_bar":true,"date":"2021-09-29T16:00:00.000Z","_content":"\n动态规划\n\n考虑当前房屋偷还是不偷。同时当前房屋的状态只与前一间房屋有关，所以可以用滚动数组进行空间优化。\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc rob(nums []int) int {\n    dp := make([]int, 2)\n    dp[0] = 0\n    dp[1] = 0\n\n    for i := 1; i <= len(nums); i++ {\n        temp := dp[0]\n        dp[0] = max(dp[1], dp[0])\n        dp[1] = temp + nums[i-1]\n    }\n\n    return max(dp[0], dp[1])\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n","source":"_posts/算法/leetcode/198.打家劫舍.md","raw":"---\ntitle: 198.打家劫舍\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-30 00:00:00\ntags:\n---\n\n动态规划\n\n考虑当前房屋偷还是不偷。同时当前房屋的状态只与前一间房屋有关，所以可以用滚动数组进行空间优化。\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc rob(nums []int) int {\n    dp := make([]int, 2)\n    dp[0] = 0\n    dp[1] = 0\n\n    for i := 1; i <= len(nums); i++ {\n        temp := dp[0]\n        dp[0] = max(dp[1], dp[0])\n        dp[1] = temp + nums[i-1]\n    }\n\n    return max(dp[0], dp[1])\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n","slug":"leetcode/198.打家劫舍","published":1,"category":"算法","updated":"2022-11-01T02:37:48.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbff000n0k4l1pnxbff9","content":"<p>动态规划</p>\n<p>考虑当前房屋偷还是不偷。同时当前房屋的状态只与前一间房屋有关，所以可以用滚动数组进行空间优化。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(1)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">rob</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span><br>    dp[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        temp := dp[<span class=\"hljs-number\">0</span>]<br>        dp[<span class=\"hljs-number\">0</span>] = max(dp[<span class=\"hljs-number\">1</span>], dp[<span class=\"hljs-number\">0</span>])<br>        dp[<span class=\"hljs-number\">1</span>] = temp + nums[i<span class=\"hljs-number\">-1</span>]<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> max(dp[<span class=\"hljs-number\">0</span>], dp[<span class=\"hljs-number\">1</span>])<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":344,"excerpt":"<p>动态规划</p>\n<p>考虑当前房屋偷还是不偷。同时当前房屋的状态只与前一间房屋有关，所以可以用滚动数组进行空间优化。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(1)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">rob</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span><br>    dp[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        temp := dp[<span class=\"hljs-number\">0</span>]<br>        dp[<span class=\"hljs-number\">0</span>] = max(dp[<span class=\"hljs-number\">1</span>], dp[<span class=\"hljs-number\">0</span>])<br>        dp[<span class=\"hljs-number\">1</span>] = temp + nums[i<span class=\"hljs-number\">-1</span>]<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> max(dp[<span class=\"hljs-number\">0</span>], dp[<span class=\"hljs-number\">1</span>])<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"210.课程表2","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/course-schedule-ii/)\n\n建立前序后序邻接表，找到入度为零的节点，然后维护邻接表。\n\n最后路径长度等于课程总数则表示可以学完所有课程。\n\n时间复杂度：O(n + m)\n空间复杂度：O(n + m)\n<!-- more -->\n```Go\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\n\tresult := []int{}\n\tpre := make(map[int][]int)\n\tpost := make(map[int][]int)\n\n\tfor _, req := range prerequisites {\n\t\tx := req[0]\n\t\ty := req[1]\n\t\tpre[x] = append(pre[x], y)\n\t\tpost[y] = append(post[y], x)\n\t}\n\n\t// fmt.Printf(\"pre: %v\\n\", pre)\n\t// fmt.Printf(\"post: %v\\n\", post)\n\n\tqueue := []int{}\n\n\tfor i := 0; i < numCourses; i++ {\n\t\tif _, ok := pre[i]; !ok {\n\t\t\tqueue = append(queue, i)\n\t\t}\n\t}\n\n\tfor len(queue) > 0 {\n\t\tcur := queue[0]\n\t\tresult = append(result, cur)\n\t\t// fmt.Printf(\"queue: %v\\n\", queue)\n\t\tqueue = queue[1:]\n\t\tfor _, p := range post[cur] {\n\t\t\tfor i, q := range pre[p] {\n\t\t\t\tif q == cur {\n\t\t\t\t\tpre[p] = append(pre[p][:i], pre[p][i+1:]...)\n\t\t\t\t\tif len(pre[p]) == 0 {\n\t\t\t\t\t\tqueue = append(queue, p)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif len(result) != numCourses {\n\t\treturn []int{}\n\t}\n\n\treturn result\n}\n```\n","source":"_posts/算法/leetcode/210.课程表2.md","raw":"---\ntitle: 210.课程表2\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/course-schedule-ii/)\n\n建立前序后序邻接表，找到入度为零的节点，然后维护邻接表。\n\n最后路径长度等于课程总数则表示可以学完所有课程。\n\n时间复杂度：O(n + m)\n空间复杂度：O(n + m)\n<!-- more -->\n```Go\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\n\tresult := []int{}\n\tpre := make(map[int][]int)\n\tpost := make(map[int][]int)\n\n\tfor _, req := range prerequisites {\n\t\tx := req[0]\n\t\ty := req[1]\n\t\tpre[x] = append(pre[x], y)\n\t\tpost[y] = append(post[y], x)\n\t}\n\n\t// fmt.Printf(\"pre: %v\\n\", pre)\n\t// fmt.Printf(\"post: %v\\n\", post)\n\n\tqueue := []int{}\n\n\tfor i := 0; i < numCourses; i++ {\n\t\tif _, ok := pre[i]; !ok {\n\t\t\tqueue = append(queue, i)\n\t\t}\n\t}\n\n\tfor len(queue) > 0 {\n\t\tcur := queue[0]\n\t\tresult = append(result, cur)\n\t\t// fmt.Printf(\"queue: %v\\n\", queue)\n\t\tqueue = queue[1:]\n\t\tfor _, p := range post[cur] {\n\t\t\tfor i, q := range pre[p] {\n\t\t\t\tif q == cur {\n\t\t\t\t\tpre[p] = append(pre[p][:i], pre[p][i+1:]...)\n\t\t\t\t\tif len(pre[p]) == 0 {\n\t\t\t\t\t\tqueue = append(queue, p)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif len(result) != numCourses {\n\t\treturn []int{}\n\t}\n\n\treturn result\n}\n```\n","slug":"leetcode/210.课程表2","published":1,"category":"算法","updated":"2022-11-01T02:33:32.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfg000p0k4ld1ft0o0p","content":"<p><a href=\"https://leetcode.cn/problems/course-schedule-ii/\">leetcode</a></p>\n<p>建立前序后序邻接表，找到入度为零的节点，然后维护邻接表。</p>\n<p>最后路径长度等于课程总数则表示可以学完所有课程。</p>\n<p>时间复杂度：O(n + m)<br>空间复杂度：O(n + m)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findOrder</span><span class=\"hljs-params\">(numCourses <span class=\"hljs-type\">int</span>, prerequisites [][]<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\tpre := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>][]<span class=\"hljs-type\">int</span>)<br>\tpost := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>][]<span class=\"hljs-type\">int</span>)<br><br>\t<span class=\"hljs-keyword\">for</span> _, req := <span class=\"hljs-keyword\">range</span> prerequisites &#123;<br>\t\tx := req[<span class=\"hljs-number\">0</span>]<br>\t\ty := req[<span class=\"hljs-number\">1</span>]<br>\t\tpre[x] = <span class=\"hljs-built_in\">append</span>(pre[x], y)<br>\t\tpost[y] = <span class=\"hljs-built_in\">append</span>(post[y], x)<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// fmt.Printf(&quot;pre: %v\\n&quot;, pre)</span><br>\t<span class=\"hljs-comment\">// fmt.Printf(&quot;post: %v\\n&quot;, post)</span><br><br>\tqueue := []<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; numCourses; i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> _, ok := pre[i]; !ok &#123;<br>\t\t\tqueue = <span class=\"hljs-built_in\">append</span>(queue, i)<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(queue) &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\tcur := queue[<span class=\"hljs-number\">0</span>]<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, cur)<br>\t\t<span class=\"hljs-comment\">// fmt.Printf(&quot;queue: %v\\n&quot;, queue)</span><br>\t\tqueue = queue[<span class=\"hljs-number\">1</span>:]<br>\t\t<span class=\"hljs-keyword\">for</span> _, p := <span class=\"hljs-keyword\">range</span> post[cur] &#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> i, q := <span class=\"hljs-keyword\">range</span> pre[p] &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> q == cur &#123;<br>\t\t\t\t\tpre[p] = <span class=\"hljs-built_in\">append</span>(pre[p][:i], pre[p][i+<span class=\"hljs-number\">1</span>:]...)<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(pre[p]) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\t\t\tqueue = <span class=\"hljs-built_in\">append</span>(queue, p)<br>\t\t\t\t\t&#125;<br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(result) != numCourses &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":986,"excerpt":"<p><a href=\"https://leetcode.cn/problems/course-schedule-ii/\">leetcode</a></p>\n<p>建立前序后序邻接表，找到入度为零的节点，然后维护邻接表。</p>\n<p>最后路径长度等于课程总数则表示可以学完所有课程。</p>\n<p>时间复杂度：O(n + m)<br>空间复杂度：O(n + m)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findOrder</span><span class=\"hljs-params\">(numCourses <span class=\"hljs-type\">int</span>, prerequisites [][]<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\tpre := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>][]<span class=\"hljs-type\">int</span>)<br>\tpost := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>][]<span class=\"hljs-type\">int</span>)<br><br>\t<span class=\"hljs-keyword\">for</span> _, req := <span class=\"hljs-keyword\">range</span> prerequisites &#123;<br>\t\tx := req[<span class=\"hljs-number\">0</span>]<br>\t\ty := req[<span class=\"hljs-number\">1</span>]<br>\t\tpre[x] = <span class=\"hljs-built_in\">append</span>(pre[x], y)<br>\t\tpost[y] = <span class=\"hljs-built_in\">append</span>(post[y], x)<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// fmt.Printf(&quot;pre: %v\\n&quot;, pre)</span><br>\t<span class=\"hljs-comment\">// fmt.Printf(&quot;post: %v\\n&quot;, post)</span><br><br>\tqueue := []<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; numCourses; i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> _, ok := pre[i]; !ok &#123;<br>\t\t\tqueue = <span class=\"hljs-built_in\">append</span>(queue, i)<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(queue) &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\tcur := queue[<span class=\"hljs-number\">0</span>]<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, cur)<br>\t\t<span class=\"hljs-comment\">// fmt.Printf(&quot;queue: %v\\n&quot;, queue)</span><br>\t\tqueue = queue[<span class=\"hljs-number\">1</span>:]<br>\t\t<span class=\"hljs-keyword\">for</span> _, p := <span class=\"hljs-keyword\">range</span> post[cur] &#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> i, q := <span class=\"hljs-keyword\">range</span> pre[p] &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> q == cur &#123;<br>\t\t\t\t\tpre[p] = <span class=\"hljs-built_in\">append</span>(pre[p][:i], pre[p][i+<span class=\"hljs-number\">1</span>:]...)<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(pre[p]) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\t\t\tqueue = <span class=\"hljs-built_in\">append</span>(queue, p)<br>\t\t\t\t\t&#125;<br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(result) != numCourses &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"208.实现 Trie (前缀树)","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n字典树\n\n树的节点存储两个数据：\n\n1. Count作为结束节点的次数（用来标识单词结束以及统计单词出现次数）\n2. Edges存储从该节点还可以延伸下去的边（指针指向下一个节点），可以是数组也可以是map，map适用性更强。\n<!-- more -->\n```Go\ntype Trie struct {\n    Count int\n    Edges map[byte]*Trie\n}\n\nfunc Constructor() Trie {\n    return Trie{\n        Count: 0,\n        Edges: make(map[byte]*Trie),\n    }\n}\n\n\nfunc (this *Trie) Insert(word string)  {\n    curr := this\n    for i := 0; i < len(word); i++ {\n        next, ok := curr.Edges[word[i]]\n        if !ok {\n            next = &Trie{\n                Count: 0,\n                Edges: make(map[byte]*Trie),\n            }\n            curr.Edges[word[i]] = next\n        }\n\n        if i == len(word) - 1 {\n            next.Count++\n        }\n        // fmt.Printf(\"curr: %v\\n\", curr)\n\n        curr = next\n\n    }\n}\n\nfunc (this *Trie) Search(word string) bool {\n    curr := this\n    ok := true\n    for i := 0; i < len(word); i++ {\n        if ok {\n            curr, ok = curr.Edges[word[i]]  \n        } else {\n            return false\n        }\n    }\n    return ok && curr.Count > 0\n}\n\n\nfunc (this *Trie) StartsWith(prefix string) bool {\n    curr := this\n    ok := true\n    for i := 0; i < len(prefix); i++ {\n        if ok {\n            curr, ok = curr.Edges[prefix[i]]  \n        } else {\n            return false\n        }\n    }\n    return ok && true\n}\n\n\n/**\n * Your Trie object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Insert(word);\n * param_2 := obj.Search(word);\n * param_3 := obj.StartsWith(prefix);\n */\n ```\n","source":"_posts/算法/leetcode/208.实现 Trie (前缀树).md","raw":"---\ntitle: 208.实现 Trie (前缀树)\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n字典树\n\n树的节点存储两个数据：\n\n1. Count作为结束节点的次数（用来标识单词结束以及统计单词出现次数）\n2. Edges存储从该节点还可以延伸下去的边（指针指向下一个节点），可以是数组也可以是map，map适用性更强。\n<!-- more -->\n```Go\ntype Trie struct {\n    Count int\n    Edges map[byte]*Trie\n}\n\nfunc Constructor() Trie {\n    return Trie{\n        Count: 0,\n        Edges: make(map[byte]*Trie),\n    }\n}\n\n\nfunc (this *Trie) Insert(word string)  {\n    curr := this\n    for i := 0; i < len(word); i++ {\n        next, ok := curr.Edges[word[i]]\n        if !ok {\n            next = &Trie{\n                Count: 0,\n                Edges: make(map[byte]*Trie),\n            }\n            curr.Edges[word[i]] = next\n        }\n\n        if i == len(word) - 1 {\n            next.Count++\n        }\n        // fmt.Printf(\"curr: %v\\n\", curr)\n\n        curr = next\n\n    }\n}\n\nfunc (this *Trie) Search(word string) bool {\n    curr := this\n    ok := true\n    for i := 0; i < len(word); i++ {\n        if ok {\n            curr, ok = curr.Edges[word[i]]  \n        } else {\n            return false\n        }\n    }\n    return ok && curr.Count > 0\n}\n\n\nfunc (this *Trie) StartsWith(prefix string) bool {\n    curr := this\n    ok := true\n    for i := 0; i < len(prefix); i++ {\n        if ok {\n            curr, ok = curr.Edges[prefix[i]]  \n        } else {\n            return false\n        }\n    }\n    return ok && true\n}\n\n\n/**\n * Your Trie object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Insert(word);\n * param_2 := obj.Search(word);\n * param_3 := obj.StartsWith(prefix);\n */\n ```\n","slug":"leetcode/208.实现 Trie (前缀树)","published":1,"category":"算法","updated":"2022-11-01T02:33:32.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfg000s0k4l99ox1ysk","content":"<p>字典树</p>\n<p>树的节点存储两个数据：</p>\n<ol>\n<li>Count作为结束节点的次数（用来标识单词结束以及统计单词出现次数）</li>\n<li>Edges存储从该节点还可以延伸下去的边（指针指向下一个节点），可以是数组也可以是map，map适用性更强。<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Trie <span class=\"hljs-keyword\">struct</span> &#123;<br>    Count <span class=\"hljs-type\">int</span><br>    Edges <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> Trie &#123;<br>    <span class=\"hljs-keyword\">return</span> Trie&#123;<br>        Count: <span class=\"hljs-number\">0</span>,<br>        Edges: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie),<br>    &#125;<br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Trie)</span></span> Insert(word <span class=\"hljs-type\">string</span>)  &#123;<br>    curr := this<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(word); i++ &#123;<br>        next, ok := curr.Edges[word[i]]<br>        <span class=\"hljs-keyword\">if</span> !ok &#123;<br>            next = &amp;Trie&#123;<br>                Count: <span class=\"hljs-number\">0</span>,<br>                Edges: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie),<br>            &#125;<br>            curr.Edges[word[i]] = next<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-built_in\">len</span>(word) - <span class=\"hljs-number\">1</span> &#123;<br>            next.Count++<br>        &#125;<br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;curr: %v\\n&quot;, curr)</span><br><br>        curr = next<br><br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Trie)</span></span> Search(word <span class=\"hljs-type\">string</span>) <span class=\"hljs-type\">bool</span> &#123;<br>    curr := this<br>    ok := <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(word); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> ok &#123;<br>            curr, ok = curr.Edges[word[i]]  <br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ok &amp;&amp; curr.Count &gt; <span class=\"hljs-number\">0</span><br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Trie)</span></span> StartsWith(prefix <span class=\"hljs-type\">string</span>) <span class=\"hljs-type\">bool</span> &#123;<br>    curr := this<br>    ok := <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(prefix); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> ok &#123;<br>            curr, ok = curr.Edges[prefix[i]]  <br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ok &amp;&amp; <span class=\"hljs-literal\">true</span><br>&#125;<br><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Your Trie object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"> * obj := Constructor();</span><br><span class=\"hljs-comment\"> * obj.Insert(word);</span><br><span class=\"hljs-comment\"> * param_2 := obj.Search(word);</span><br><span class=\"hljs-comment\"> * param_3 := obj.StartsWith(prefix);</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":1255,"excerpt":"<p>字典树</p>\n<p>树的节点存储两个数据：</p>\n<ol>\n<li>Count作为结束节点的次数（用来标识单词结束以及统计单词出现次数）</li>\n<li>Edges存储从该节点还可以延伸下去的边（指针指向下一个节点），可以是数组也可以是map，map适用性更强。","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Trie <span class=\"hljs-keyword\">struct</span> &#123;<br>    Count <span class=\"hljs-type\">int</span><br>    Edges <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> Trie &#123;<br>    <span class=\"hljs-keyword\">return</span> Trie&#123;<br>        Count: <span class=\"hljs-number\">0</span>,<br>        Edges: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie),<br>    &#125;<br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Trie)</span></span> Insert(word <span class=\"hljs-type\">string</span>)  &#123;<br>    curr := this<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(word); i++ &#123;<br>        next, ok := curr.Edges[word[i]]<br>        <span class=\"hljs-keyword\">if</span> !ok &#123;<br>            next = &amp;Trie&#123;<br>                Count: <span class=\"hljs-number\">0</span>,<br>                Edges: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie),<br>            &#125;<br>            curr.Edges[word[i]] = next<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-built_in\">len</span>(word) - <span class=\"hljs-number\">1</span> &#123;<br>            next.Count++<br>        &#125;<br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;curr: %v\\n&quot;, curr)</span><br><br>        curr = next<br><br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Trie)</span></span> Search(word <span class=\"hljs-type\">string</span>) <span class=\"hljs-type\">bool</span> &#123;<br>    curr := this<br>    ok := <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(word); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> ok &#123;<br>            curr, ok = curr.Edges[word[i]]  <br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ok &amp;&amp; curr.Count &gt; <span class=\"hljs-number\">0</span><br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Trie)</span></span> StartsWith(prefix <span class=\"hljs-type\">string</span>) <span class=\"hljs-type\">bool</span> &#123;<br>    curr := this<br>    ok := <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(prefix); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> ok &#123;<br>            curr, ok = curr.Edges[prefix[i]]  <br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ok &amp;&amp; <span class=\"hljs-literal\">true</span><br>&#125;<br><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Your Trie object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"> * obj := Constructor();</span><br><span class=\"hljs-comment\"> * obj.Insert(word);</span><br><span class=\"hljs-comment\"> * param_2 := obj.Search(word);</span><br><span class=\"hljs-comment\"> * param_3 := obj.StartsWith(prefix);</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></td></tr></table></figure></li>\n</ol>"},{"title":"200.岛屿数量","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/number-of-islands/)\n\n深度优先搜索\n\n时间复杂度：O(MN)\n空间复杂度：O(MN)\n<!-- more -->\n```Go\nfunc numIslands(grid [][]byte) int {\n    result := 0\n\n    var dfs func(int, int, int)\n\n    dfs = func(row int, col int, count int){\n        if row < 0 || col < 0 || row >= len(grid) || col >= len(grid[0]) {\n            return\n        }\n\n        if string(grid[row][col]) == \"0\" || string(grid[row][col]) == \"2\" {\n            return\n        }\n\n        // if count > 0 {\n        //     fmt.Printf(\"grid: %v\\n\", grid)\n        // }\n        grid[row][col] = '2'\n        result += count\n\n        dfs(row - 1, col, 0) //上\n        dfs(row, col + 1, 0) //右\n        dfs(row + 1, col, 0) //下\n        bfs(row, col - 1, 0) //左\n    }\n\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[0]); j++ {\n            bfs(i, j, 1)\n        }\n    }\n\n    return result\n}\n```\n","source":"_posts/算法/leetcode/200.岛屿数量.md","raw":"---\ntitle: 200.岛屿数量\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/number-of-islands/)\n\n深度优先搜索\n\n时间复杂度：O(MN)\n空间复杂度：O(MN)\n<!-- more -->\n```Go\nfunc numIslands(grid [][]byte) int {\n    result := 0\n\n    var dfs func(int, int, int)\n\n    dfs = func(row int, col int, count int){\n        if row < 0 || col < 0 || row >= len(grid) || col >= len(grid[0]) {\n            return\n        }\n\n        if string(grid[row][col]) == \"0\" || string(grid[row][col]) == \"2\" {\n            return\n        }\n\n        // if count > 0 {\n        //     fmt.Printf(\"grid: %v\\n\", grid)\n        // }\n        grid[row][col] = '2'\n        result += count\n\n        dfs(row - 1, col, 0) //上\n        dfs(row, col + 1, 0) //右\n        dfs(row + 1, col, 0) //下\n        bfs(row, col - 1, 0) //左\n    }\n\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[0]); j++ {\n            bfs(i, j, 1)\n        }\n    }\n\n    return result\n}\n```\n","slug":"leetcode/200.岛屿数量","published":1,"category":"算法","updated":"2022-11-01T02:33:31.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfh000u0k4l34tx0zqw","content":"<p><a href=\"https://leetcode.cn/problems/number-of-islands/\">leetcode</a></p>\n<p>深度优先搜索</p>\n<p>时间复杂度：O(MN)<br>空间复杂度：O(MN)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">numIslands</span><span class=\"hljs-params\">(grid [][]<span class=\"hljs-type\">byte</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    result := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span><br><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(row <span class=\"hljs-type\">int</span>, col <span class=\"hljs-type\">int</span>, count <span class=\"hljs-type\">int</span>)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span> row &lt; <span class=\"hljs-number\">0</span> || col &lt; <span class=\"hljs-number\">0</span> || row &gt;= <span class=\"hljs-built_in\">len</span>(grid) || col &gt;= <span class=\"hljs-built_in\">len</span>(grid[<span class=\"hljs-number\">0</span>]) &#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-type\">string</span>(grid[row][col]) == <span class=\"hljs-string\">&quot;0&quot;</span> || <span class=\"hljs-type\">string</span>(grid[row][col]) == <span class=\"hljs-string\">&quot;2&quot;</span> &#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        <span class=\"hljs-comment\">// if count &gt; 0 &#123;</span><br>        <span class=\"hljs-comment\">//     fmt.Printf(&quot;grid: %v\\n&quot;, grid)</span><br>        <span class=\"hljs-comment\">// &#125;</span><br>        grid[row][col] = <span class=\"hljs-string\">&#x27;2&#x27;</span><br>        result += count<br><br>        dfs(row - <span class=\"hljs-number\">1</span>, col, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//上</span><br>        dfs(row, col + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//右</span><br>        dfs(row + <span class=\"hljs-number\">1</span>, col, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//下</span><br>        bfs(row, col - <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//左</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(grid); i++ &#123;<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-built_in\">len</span>(grid[<span class=\"hljs-number\">0</span>]); j++ &#123;<br>            bfs(i, j, <span class=\"hljs-number\">1</span>)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":675,"excerpt":"<p><a href=\"https://leetcode.cn/problems/number-of-islands/\">leetcode</a></p>\n<p>深度优先搜索</p>\n<p>时间复杂度：O(MN)<br>空间复杂度：O(MN)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">numIslands</span><span class=\"hljs-params\">(grid [][]<span class=\"hljs-type\">byte</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    result := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span><br><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(row <span class=\"hljs-type\">int</span>, col <span class=\"hljs-type\">int</span>, count <span class=\"hljs-type\">int</span>)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span> row &lt; <span class=\"hljs-number\">0</span> || col &lt; <span class=\"hljs-number\">0</span> || row &gt;= <span class=\"hljs-built_in\">len</span>(grid) || col &gt;= <span class=\"hljs-built_in\">len</span>(grid[<span class=\"hljs-number\">0</span>]) &#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-type\">string</span>(grid[row][col]) == <span class=\"hljs-string\">&quot;0&quot;</span> || <span class=\"hljs-type\">string</span>(grid[row][col]) == <span class=\"hljs-string\">&quot;2&quot;</span> &#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        <span class=\"hljs-comment\">// if count &gt; 0 &#123;</span><br>        <span class=\"hljs-comment\">//     fmt.Printf(&quot;grid: %v\\n&quot;, grid)</span><br>        <span class=\"hljs-comment\">// &#125;</span><br>        grid[row][col] = <span class=\"hljs-string\">&#x27;2&#x27;</span><br>        result += count<br><br>        dfs(row - <span class=\"hljs-number\">1</span>, col, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//上</span><br>        dfs(row, col + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//右</span><br>        dfs(row + <span class=\"hljs-number\">1</span>, col, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//下</span><br>        bfs(row, col - <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//左</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(grid); i++ &#123;<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-built_in\">len</span>(grid[<span class=\"hljs-number\">0</span>]); j++ &#123;<br>            bfs(i, j, <span class=\"hljs-number\">1</span>)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"23. 合并K个升序链表","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/merge-k-sorted-lists/)\n\n分治思想\n\n时间复杂度：O(kn * log k)\n空间复杂度：O(log k)\n<!-- more -->\n```Go\n/**\n\n* Definition for singly-linked list.\n\n* type ListNode struct {\n\n* Val int\n\n* Next *ListNode\n\n* }\n\n*/\n\nfunc mergeKLists(lists []*ListNode) *ListNode {\n\n\tk := len(lists)\n\t\n\tif k == 0 {\n\t\n\t\treturn nil\n\t\n\t}\n\t\n\t  \n\t\n\tif k == 1 {\n\t\n\t\treturn lists[0]\n\t\n\t}\n\t\n\t  \n\t\n\tmid := k / 2\n\t\n\tleft := lists[0:mid]\n\t\n\tright := lists[mid:k]\n\t\n\tleftList := mergeKLists(left)\n\t\n\trightList := mergeKLists(right)\n\t\n\t  \n\t\n\treturn merge(leftList, rightList)\n\n}\n\n  \n\nfunc merge(left *ListNode, right *ListNode) *ListNode{\n\n\tdummy := &ListNode{}\n\t\n\tresult := dummy\n\t\n\tfor left != nil && right != nil {\n\t\t\n\t\tif left.Val < right.Val {\n\t\t\n\t\t\tdummy.Next = left\n\t\t\t\n\t\t\tdummy = left\n\t\t\t\n\t\t\tleft = left.Next\n\t\t\n\t\t}else{\n\t\t\n\t\t\tdummy.Next = right\n\t\t\t\n\t\t\tdummy = right\n\t\t\t\n\t\t\tright = right.Next\n\t\t\t\n\t\t}\n\t\n\t}\n\t\n\t  \n\t\n\tif left == nil {\n\t\n\t\tdummy.Next = right\n\t\n\t}\n\t\n\t  \n\t\n\tif right == nil {\n\t\n\t\tdummy.Next = left\n\t\n\t}\n\t\n\t\n\treturn result.Next\n\n}\n```\n","source":"_posts/算法/leetcode/23. 合并K个升序链表.md","raw":"---\ntitle: 23. 合并K个升序链表\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/merge-k-sorted-lists/)\n\n分治思想\n\n时间复杂度：O(kn * log k)\n空间复杂度：O(log k)\n<!-- more -->\n```Go\n/**\n\n* Definition for singly-linked list.\n\n* type ListNode struct {\n\n* Val int\n\n* Next *ListNode\n\n* }\n\n*/\n\nfunc mergeKLists(lists []*ListNode) *ListNode {\n\n\tk := len(lists)\n\t\n\tif k == 0 {\n\t\n\t\treturn nil\n\t\n\t}\n\t\n\t  \n\t\n\tif k == 1 {\n\t\n\t\treturn lists[0]\n\t\n\t}\n\t\n\t  \n\t\n\tmid := k / 2\n\t\n\tleft := lists[0:mid]\n\t\n\tright := lists[mid:k]\n\t\n\tleftList := mergeKLists(left)\n\t\n\trightList := mergeKLists(right)\n\t\n\t  \n\t\n\treturn merge(leftList, rightList)\n\n}\n\n  \n\nfunc merge(left *ListNode, right *ListNode) *ListNode{\n\n\tdummy := &ListNode{}\n\t\n\tresult := dummy\n\t\n\tfor left != nil && right != nil {\n\t\t\n\t\tif left.Val < right.Val {\n\t\t\n\t\t\tdummy.Next = left\n\t\t\t\n\t\t\tdummy = left\n\t\t\t\n\t\t\tleft = left.Next\n\t\t\n\t\t}else{\n\t\t\n\t\t\tdummy.Next = right\n\t\t\t\n\t\t\tdummy = right\n\t\t\t\n\t\t\tright = right.Next\n\t\t\t\n\t\t}\n\t\n\t}\n\t\n\t  \n\t\n\tif left == nil {\n\t\n\t\tdummy.Next = right\n\t\n\t}\n\t\n\t  \n\t\n\tif right == nil {\n\t\n\t\tdummy.Next = left\n\t\n\t}\n\t\n\t\n\treturn result.Next\n\n}\n```\n","slug":"leetcode/23. 合并K个升序链表","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfi000x0k4lcrqj824r","content":"<p><a href=\"https://leetcode.cn/problems/merge-k-sorted-lists/\">leetcode</a></p>\n<p>分治思想</p>\n<p>时间复杂度：O(kn * log k)<br>空间复杂度：O(log k)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* Definition for singly-linked list.</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* type ListNode struct &#123;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* Val int</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* Next *ListNode</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* &#125;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">mergeKLists</span><span class=\"hljs-params\">(lists []*ListNode)</span></span> *ListNode &#123;<br><br>\tk := <span class=\"hljs-built_in\">len</span>(lists)<br>\t<br>\t<span class=\"hljs-keyword\">if</span> k == <span class=\"hljs-number\">0</span> &#123;<br>\t<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">if</span> k == <span class=\"hljs-number\">1</span> &#123;<br>\t<br>\t\t<span class=\"hljs-keyword\">return</span> lists[<span class=\"hljs-number\">0</span>]<br>\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\tmid := k / <span class=\"hljs-number\">2</span><br>\t<br>\tleft := lists[<span class=\"hljs-number\">0</span>:mid]<br>\t<br>\tright := lists[mid:k]<br>\t<br>\tleftList := mergeKLists(left)<br>\t<br>\trightList := mergeKLists(right)<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">return</span> merge(leftList, rightList)<br><br>&#125;<br><br>  <br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(left *ListNode, right *ListNode)</span></span> *ListNode&#123;<br><br>\tdummy := &amp;ListNode&#123;&#125;<br>\t<br>\tresult := dummy<br>\t<br>\t<span class=\"hljs-keyword\">for</span> left != <span class=\"hljs-literal\">nil</span> &amp;&amp; right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<br>\t\t<span class=\"hljs-keyword\">if</span> left.Val &lt; right.Val &#123;<br>\t\t<br>\t\t\tdummy.Next = left<br>\t\t\t<br>\t\t\tdummy = left<br>\t\t\t<br>\t\t\tleft = left.Next<br>\t\t<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t<br>\t\t\tdummy.Next = right<br>\t\t\t<br>\t\t\tdummy = right<br>\t\t\t<br>\t\t\tright = right.Next<br>\t\t\t<br>\t\t&#125;<br>\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">if</span> left == <span class=\"hljs-literal\">nil</span> &#123;<br>\t<br>\t\tdummy.Next = right<br>\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">if</span> right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t<br>\t\tdummy.Next = left<br>\t<br>\t&#125;<br>\t<br>\t<br>\t<span class=\"hljs-keyword\">return</span> result.Next<br><br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":958,"excerpt":"<p><a href=\"https://leetcode.cn/problems/merge-k-sorted-lists/\">leetcode</a></p>\n<p>分治思想</p>\n<p>时间复杂度：O(kn * log k)<br>空间复杂度：O(log k)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* Definition for singly-linked list.</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* type ListNode struct &#123;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* Val int</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* Next *ListNode</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* &#125;</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">mergeKLists</span><span class=\"hljs-params\">(lists []*ListNode)</span></span> *ListNode &#123;<br><br>\tk := <span class=\"hljs-built_in\">len</span>(lists)<br>\t<br>\t<span class=\"hljs-keyword\">if</span> k == <span class=\"hljs-number\">0</span> &#123;<br>\t<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">if</span> k == <span class=\"hljs-number\">1</span> &#123;<br>\t<br>\t\t<span class=\"hljs-keyword\">return</span> lists[<span class=\"hljs-number\">0</span>]<br>\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\tmid := k / <span class=\"hljs-number\">2</span><br>\t<br>\tleft := lists[<span class=\"hljs-number\">0</span>:mid]<br>\t<br>\tright := lists[mid:k]<br>\t<br>\tleftList := mergeKLists(left)<br>\t<br>\trightList := mergeKLists(right)<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">return</span> merge(leftList, rightList)<br><br>&#125;<br><br>  <br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(left *ListNode, right *ListNode)</span></span> *ListNode&#123;<br><br>\tdummy := &amp;ListNode&#123;&#125;<br>\t<br>\tresult := dummy<br>\t<br>\t<span class=\"hljs-keyword\">for</span> left != <span class=\"hljs-literal\">nil</span> &amp;&amp; right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<br>\t\t<span class=\"hljs-keyword\">if</span> left.Val &lt; right.Val &#123;<br>\t\t<br>\t\t\tdummy.Next = left<br>\t\t\t<br>\t\t\tdummy = left<br>\t\t\t<br>\t\t\tleft = left.Next<br>\t\t<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t<br>\t\t\tdummy.Next = right<br>\t\t\t<br>\t\t\tdummy = right<br>\t\t\t<br>\t\t\tright = right.Next<br>\t\t\t<br>\t\t&#125;<br>\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">if</span> left == <span class=\"hljs-literal\">nil</span> &#123;<br>\t<br>\t\tdummy.Next = right<br>\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">if</span> right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t<br>\t\tdummy.Next = left<br>\t<br>\t&#125;<br>\t<br>\t<br>\t<span class=\"hljs-keyword\">return</span> result.Next<br><br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"239.滑动窗口最大值","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/sliding-window-maximum/)\n\n使用container.heap包实现大根堆。需要维护数据的index来判断是否在窗口内。\n<!-- more -->\n```Go\nvar a []int\nfunc maxSlidingWindow(nums []int, k int) []int {\n    a = nums\n    h := &Heap{}\n    heap.Init(h)\n    ans := []int{}\n\n    for i := 0; i < len(nums); i++ {\n        heap.Push(h, i)\n        for h.slice[0] <= i - k {\n            heap.Pop(h)\n        }\n        // fmt.Printf(\"h: %v\\n\", h)\n        if i >= k - 1 {\n            ans = append(ans, nums[h.slice[0]])\n        }\n    }\n    return ans\n}\n\ntype Heap struct {\n    slice sort.IntSlice\n}\n\nfunc (h Heap) Len() int {\n    return len(h.slice)\n}\n\nfunc (h Heap) Swap(i, j int) {\n    h.slice[i], h.slice[j] = h.slice[j], h.slice[i]\n}\n\nfunc (h Heap) Less(i, j int) bool {\n    return a[h.slice[i]] > a[h.slice[j]]\n}\n\nfunc (h *Heap) Push(x interface{}) {\n    h.slice = append(h.slice, x.(int))\n}\n\nfunc (h *Heap) Pop() interface{} {\n    old := h.slice\n    n := len(old)\n    x := old[n-1]\n    h.slice = old[:n-1]\n    return x\n}\n\n\n\ntype NodeHeap []Node\n\nfunc (nh NodeHeap) Len() int {\n\treturn len(nh)\n}\n\nfunc (nh NodeHeap) Swap(i, j int) {\n\tnh[i], nh[j] = nh[j], nh[i]\n}\nfunc (nh NodeHeap) Less(i, j int) bool {\n\tif nh[i].count > nh[j].count {\n\t\treturn true\n\t}\n\n\tif nh[i].count == nh[j].count {\n\t\tif nh[i].x + nh[i].y < nh[j].x + nh[j].y{\n\t\t\treturn true\n\t\t}\n\n\t\tif nh[i].x + nh[i].y == nh[j].x + nh[j].y && nh[i].x < nh[].x{\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn nh[i].Area() < nh[j].Area()\n}\n\nfunc (nh *NodeHeap) Push(h interface{}) {\n\t*nh = append(*nh, h.(Node))\n}\nfunc (nh *NodeHeap) Pop() (x interface{}) {\n\tn := len(*nh)\n\tx = (*nh)[n-1]    \n\t*nh = (*nh)[:n-1]\n\treturn x\n}\n```\n\n","source":"_posts/算法/leetcode/239.滑动窗口最大值.md","raw":"---\ntitle: 239.滑动窗口最大值\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/sliding-window-maximum/)\n\n使用container.heap包实现大根堆。需要维护数据的index来判断是否在窗口内。\n<!-- more -->\n```Go\nvar a []int\nfunc maxSlidingWindow(nums []int, k int) []int {\n    a = nums\n    h := &Heap{}\n    heap.Init(h)\n    ans := []int{}\n\n    for i := 0; i < len(nums); i++ {\n        heap.Push(h, i)\n        for h.slice[0] <= i - k {\n            heap.Pop(h)\n        }\n        // fmt.Printf(\"h: %v\\n\", h)\n        if i >= k - 1 {\n            ans = append(ans, nums[h.slice[0]])\n        }\n    }\n    return ans\n}\n\ntype Heap struct {\n    slice sort.IntSlice\n}\n\nfunc (h Heap) Len() int {\n    return len(h.slice)\n}\n\nfunc (h Heap) Swap(i, j int) {\n    h.slice[i], h.slice[j] = h.slice[j], h.slice[i]\n}\n\nfunc (h Heap) Less(i, j int) bool {\n    return a[h.slice[i]] > a[h.slice[j]]\n}\n\nfunc (h *Heap) Push(x interface{}) {\n    h.slice = append(h.slice, x.(int))\n}\n\nfunc (h *Heap) Pop() interface{} {\n    old := h.slice\n    n := len(old)\n    x := old[n-1]\n    h.slice = old[:n-1]\n    return x\n}\n\n\n\ntype NodeHeap []Node\n\nfunc (nh NodeHeap) Len() int {\n\treturn len(nh)\n}\n\nfunc (nh NodeHeap) Swap(i, j int) {\n\tnh[i], nh[j] = nh[j], nh[i]\n}\nfunc (nh NodeHeap) Less(i, j int) bool {\n\tif nh[i].count > nh[j].count {\n\t\treturn true\n\t}\n\n\tif nh[i].count == nh[j].count {\n\t\tif nh[i].x + nh[i].y < nh[j].x + nh[j].y{\n\t\t\treturn true\n\t\t}\n\n\t\tif nh[i].x + nh[i].y == nh[j].x + nh[j].y && nh[i].x < nh[].x{\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn nh[i].Area() < nh[j].Area()\n}\n\nfunc (nh *NodeHeap) Push(h interface{}) {\n\t*nh = append(*nh, h.(Node))\n}\nfunc (nh *NodeHeap) Pop() (x interface{}) {\n\tn := len(*nh)\n\tx = (*nh)[n-1]    \n\t*nh = (*nh)[:n-1]\n\treturn x\n}\n```\n\n","slug":"leetcode/239.滑动窗口最大值","published":1,"category":"算法","updated":"2022-11-01T02:33:31.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfi000z0k4l1nhd3zex","content":"<p><a href=\"https://leetcode.cn/problems/sliding-window-maximum/\">leetcode</a></p>\n<p>使用container.heap包实现大根堆。需要维护数据的index来判断是否在窗口内。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">var</span> a []<span class=\"hljs-type\">int</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxSlidingWindow</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    a = nums<br>    h := &amp;Heap&#123;&#125;<br>    heap.Init(h)<br>    ans := []<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        heap.Push(h, i)<br>        <span class=\"hljs-keyword\">for</span> h.slice[<span class=\"hljs-number\">0</span>] &lt;= i - k &#123;<br>            heap.Pop(h)<br>        &#125;<br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;h: %v\\n&quot;, h)</span><br>        <span class=\"hljs-keyword\">if</span> i &gt;= k - <span class=\"hljs-number\">1</span> &#123;<br>            ans = <span class=\"hljs-built_in\">append</span>(ans, nums[h.slice[<span class=\"hljs-number\">0</span>]])<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> Heap <span class=\"hljs-keyword\">struct</span> &#123;<br>    slice sort.IntSlice<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h Heap)</span></span> Len() <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(h.slice)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h Heap)</span></span> Swap(i, j <span class=\"hljs-type\">int</span>) &#123;<br>    h.slice[i], h.slice[j] = h.slice[j], h.slice[i]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h Heap)</span></span> Less(i, j <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">bool</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> a[h.slice[i]] &gt; a[h.slice[j]]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h *Heap)</span></span> Push(x <span class=\"hljs-keyword\">interface</span>&#123;&#125;) &#123;<br>    h.slice = <span class=\"hljs-built_in\">append</span>(h.slice, x.(<span class=\"hljs-type\">int</span>))<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h *Heap)</span></span> Pop() <span class=\"hljs-keyword\">interface</span>&#123;&#125; &#123;<br>    old := h.slice<br>    n := <span class=\"hljs-built_in\">len</span>(old)<br>    x := old[n<span class=\"hljs-number\">-1</span>]<br>    h.slice = old[:n<span class=\"hljs-number\">-1</span>]<br>    <span class=\"hljs-keyword\">return</span> x<br>&#125;<br><br><br><br><span class=\"hljs-keyword\">type</span> NodeHeap []Node<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh NodeHeap)</span></span> Len() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(nh)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh NodeHeap)</span></span> Swap(i, j <span class=\"hljs-type\">int</span>) &#123;<br>\tnh[i], nh[j] = nh[j], nh[i]<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh NodeHeap)</span></span> Less(i, j <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> nh[i].count &gt; nh[j].count &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> nh[i].count == nh[j].count &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> nh[i].x + nh[i].y &lt; nh[j].x + nh[j].y&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">if</span> nh[i].x + nh[i].y == nh[j].x + nh[j].y &amp;&amp; nh[i].x &lt; nh[].x&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> nh[i].Area() &lt; nh[j].Area()<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh *NodeHeap)</span></span> Push(h <span class=\"hljs-keyword\">interface</span>&#123;&#125;) &#123;<br>\t*nh = <span class=\"hljs-built_in\">append</span>(*nh, h.(Node))<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh *NodeHeap)</span></span> Pop() (x <span class=\"hljs-keyword\">interface</span>&#123;&#125;) &#123;<br>\tn := <span class=\"hljs-built_in\">len</span>(*nh)<br>\tx = (*nh)[n<span class=\"hljs-number\">-1</span>]    <br>\t*nh = (*nh)[:n<span class=\"hljs-number\">-1</span>]<br>\t<span class=\"hljs-keyword\">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":1594,"excerpt":"<p><a href=\"https://leetcode.cn/problems/sliding-window-maximum/\">leetcode</a></p>\n<p>使用container.heap包实现大根堆。需要维护数据的index来判断是否在窗口内。</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">var</span> a []<span class=\"hljs-type\">int</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxSlidingWindow</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    a = nums<br>    h := &amp;Heap&#123;&#125;<br>    heap.Init(h)<br>    ans := []<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        heap.Push(h, i)<br>        <span class=\"hljs-keyword\">for</span> h.slice[<span class=\"hljs-number\">0</span>] &lt;= i - k &#123;<br>            heap.Pop(h)<br>        &#125;<br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;h: %v\\n&quot;, h)</span><br>        <span class=\"hljs-keyword\">if</span> i &gt;= k - <span class=\"hljs-number\">1</span> &#123;<br>            ans = <span class=\"hljs-built_in\">append</span>(ans, nums[h.slice[<span class=\"hljs-number\">0</span>]])<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> Heap <span class=\"hljs-keyword\">struct</span> &#123;<br>    slice sort.IntSlice<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h Heap)</span></span> Len() <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(h.slice)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h Heap)</span></span> Swap(i, j <span class=\"hljs-type\">int</span>) &#123;<br>    h.slice[i], h.slice[j] = h.slice[j], h.slice[i]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h Heap)</span></span> Less(i, j <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">bool</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> a[h.slice[i]] &gt; a[h.slice[j]]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h *Heap)</span></span> Push(x <span class=\"hljs-keyword\">interface</span>&#123;&#125;) &#123;<br>    h.slice = <span class=\"hljs-built_in\">append</span>(h.slice, x.(<span class=\"hljs-type\">int</span>))<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h *Heap)</span></span> Pop() <span class=\"hljs-keyword\">interface</span>&#123;&#125; &#123;<br>    old := h.slice<br>    n := <span class=\"hljs-built_in\">len</span>(old)<br>    x := old[n<span class=\"hljs-number\">-1</span>]<br>    h.slice = old[:n<span class=\"hljs-number\">-1</span>]<br>    <span class=\"hljs-keyword\">return</span> x<br>&#125;<br><br><br><br><span class=\"hljs-keyword\">type</span> NodeHeap []Node<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh NodeHeap)</span></span> Len() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(nh)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh NodeHeap)</span></span> Swap(i, j <span class=\"hljs-type\">int</span>) &#123;<br>\tnh[i], nh[j] = nh[j], nh[i]<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh NodeHeap)</span></span> Less(i, j <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> nh[i].count &gt; nh[j].count &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> nh[i].count == nh[j].count &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> nh[i].x + nh[i].y &lt; nh[j].x + nh[j].y&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">if</span> nh[i].x + nh[i].y == nh[j].x + nh[j].y &amp;&amp; nh[i].x &lt; nh[].x&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> nh[i].Area() &lt; nh[j].Area()<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh *NodeHeap)</span></span> Push(h <span class=\"hljs-keyword\">interface</span>&#123;&#125;) &#123;<br>\t*nh = <span class=\"hljs-built_in\">append</span>(*nh, h.(Node))<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(nh *NodeHeap)</span></span> Pop() (x <span class=\"hljs-keyword\">interface</span>&#123;&#125;) &#123;<br>\tn := <span class=\"hljs-built_in\">len</span>(*nh)<br>\tx = (*nh)[n<span class=\"hljs-number\">-1</span>]    <br>\t*nh = (*nh)[:n<span class=\"hljs-number\">-1</span>]<br>\t<span class=\"hljs-keyword\">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"279.完全平方数","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n动态规划\n\n`dp[i]`  表示和为i的完全平方数的最少数量。则可以得到状态转移方程： `dp[i] = min(dp[i-j^2]) + 1` 。\n\n时间复杂度： O(N√N)。状态转移的时间复杂度为O(√N)，攻击N个状态。\n空间复杂度：O(N)\n\n<!-- more -->\n```Go\nfunc numSquares(n int) int {\n    // dp[i] = min(dp[i-j^2]) + 1\n\n    dp := make([]int, n+1)\n    for i := 1; i <= n; i++{\n        minDp := math.MaxInt\n        for j := 1; j*j <= i; j++ {\n            minDp = min(minDp, dp[i-j*j])\n        }\n        dp[i] = minDp + 1\n    }\n\n    return dp[n]\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n","source":"_posts/算法/leetcode/279.完全平方数.md","raw":"---\ntitle: 279.完全平方数\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n动态规划\n\n`dp[i]`  表示和为i的完全平方数的最少数量。则可以得到状态转移方程： `dp[i] = min(dp[i-j^2]) + 1` 。\n\n时间复杂度： O(N√N)。状态转移的时间复杂度为O(√N)，攻击N个状态。\n空间复杂度：O(N)\n\n<!-- more -->\n```Go\nfunc numSquares(n int) int {\n    // dp[i] = min(dp[i-j^2]) + 1\n\n    dp := make([]int, n+1)\n    for i := 1; i <= n; i++{\n        minDp := math.MaxInt\n        for j := 1; j*j <= i; j++ {\n            minDp = min(minDp, dp[i-j*j])\n        }\n        dp[i] = minDp + 1\n    }\n\n    return dp[n]\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n","slug":"leetcode/279.完全平方数","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfj00120k4ldrew02wj","content":"<p>动态规划</p>\n<p><code>dp[i]</code>  表示和为i的完全平方数的最少数量。则可以得到状态转移方程： <code>dp[i] = min(dp[i-j^2]) + 1</code> 。</p>\n<p>时间复杂度： O(N√N)。状态转移的时间复杂度为O(√N)，攻击N个状态。<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">numSquares</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// dp[i] = min(dp[i-j^2]) + 1</span><br><br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n+<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= n; i++&#123;<br>        minDp := math.MaxInt<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">1</span>; j*j &lt;= i; j++ &#123;<br>            minDp = min(minDp, dp[i-j*j])<br>        &#125;<br>        dp[i] = minDp + <span class=\"hljs-number\">1</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> dp[n]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":415,"excerpt":"<p>动态规划</p>\n<p><code>dp[i]</code>  表示和为i的完全平方数的最少数量。则可以得到状态转移方程： <code>dp[i] = min(dp[i-j^2]) + 1</code> 。</p>\n<p>时间复杂度： O(N√N)。状态转移的时间复杂度为O(√N)，攻击N个状态。<br>空间复杂度：O(N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">numSquares</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// dp[i] = min(dp[i-j^2]) + 1</span><br><br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n+<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= n; i++&#123;<br>        minDp := math.MaxInt<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">1</span>; j*j &lt;= i; j++ &#123;<br>            minDp = min(minDp, dp[i-j*j])<br>        &#125;<br>        dp[i] = minDp + <span class=\"hljs-number\">1</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> dp[n]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"300.最长递增子序列","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n动态规划\n\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc lengthOfLIS(nums []int) int {\n    dp := make([]int, len(nums))\n    ans := 0\n\n    for i := 0; i < len(nums); i++ {\n        dp[i] = 1\n        for j := 0; j < i; j++ {\n            if nums[j] < nums[i] && dp[i] < dp[j] + 1 {\n                dp[i] = dp[j] + 1\n            }\n        }\n        if ans < dp[i] {\n            ans = dp[i]\n        }\n    }\n\n    return ans\n}```\n","source":"_posts/算法/leetcode/300.最长递增子序列.md","raw":"---\ntitle: 300.最长递增子序列\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n动态规划\n\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc lengthOfLIS(nums []int) int {\n    dp := make([]int, len(nums))\n    ans := 0\n\n    for i := 0; i < len(nums); i++ {\n        dp[i] = 1\n        for j := 0; j < i; j++ {\n            if nums[j] < nums[i] && dp[i] < dp[j] + 1 {\n                dp[i] = dp[j] + 1\n            }\n        }\n        if ans < dp[i] {\n            ans = dp[i]\n        }\n    }\n\n    return ans\n}```\n","slug":"leetcode/300.最长递增子序列","published":1,"category":"算法","updated":"2022-11-01T02:33:32.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfj00140k4l5alf6em6","content":"<p>动态规划</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<pre><code class=\"Go\">func lengthOfLIS(nums []int) int &#123;\n    dp := make([]int, len(nums))\n    ans := 0\n\n    for i := 0; i &lt; len(nums); i++ &#123;\n        dp[i] = 1\n        for j := 0; j &lt; i; j++ &#123;\n            if nums[j] &lt; nums[i] &amp;&amp; dp[i] &lt; dp[j] + 1 &#123;\n                dp[i] = dp[j] + 1\n            &#125;\n        &#125;\n        if ans &lt; dp[i] &#123;\n            ans = dp[i]\n        &#125;\n    &#125;\n\n    return ans\n&#125;```\n</code></pre>\n","site":{"data":{}},"wordcount":291,"excerpt":"<p>动态规划</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p>","more":"<pre><code class=\"Go\">func lengthOfLIS(nums []int) int &#123;\n    dp := make([]int, len(nums))\n    ans := 0\n\n    for i := 0; i &lt; len(nums); i++ &#123;\n        dp[i] = 1\n        for j := 0; j &lt; i; j++ &#123;\n            if nums[j] &lt; nums[i] &amp;&amp; dp[i] &lt; dp[j] + 1 &#123;\n                dp[i] = dp[j] + 1\n            &#125;\n        &#125;\n        if ans &lt; dp[i] &#123;\n            ans = dp[i]\n        &#125;\n    &#125;\n\n    return ans\n&#125;```\n</code></pre>"},{"title":"322.零钱兑换","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n动态规划\n\n自底向上，计算1~amount每个数作为结果所需要的最小硬币数量。\n\n时间复杂度：O(Sn)，其中 SS 是金额，nn 是面额数\n空间复杂度：O(S)\n<!-- more -->\n```Go\nfunc coinChange(coins []int, amount int) int {\n    if amount == 0 {\n        return 0\n    }\n    \n    dp := make([]int, amount + 1)\n    dp[0] = 0\n    for i := 1; i < amount+1; i++ {\n        dp[i] = amount + 1\n    }\n\n    // 计算1~amount的每种情况下所需硬币数\n    for i := 1; i <= amount; i++{\n        for _, coin := range coins {\n            //硬币面额大于amount则跳过\n            if coin <= i {\n                // 求最小dp[i-coin]\n                if dp[i] > dp[i-coin] + 1{\n                    dp[i] = dp[i-coin] + 1\n                }\n            }\n        }\n    }\n\n    if dp[amount] == amount + 1 {\n        return -1\n    } else {\n        return dp[amount]\n    }\n}\n```\n","source":"_posts/算法/leetcode/322.零钱兑换.md","raw":"---\ntitle: 322.零钱兑换\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n动态规划\n\n自底向上，计算1~amount每个数作为结果所需要的最小硬币数量。\n\n时间复杂度：O(Sn)，其中 SS 是金额，nn 是面额数\n空间复杂度：O(S)\n<!-- more -->\n```Go\nfunc coinChange(coins []int, amount int) int {\n    if amount == 0 {\n        return 0\n    }\n    \n    dp := make([]int, amount + 1)\n    dp[0] = 0\n    for i := 1; i < amount+1; i++ {\n        dp[i] = amount + 1\n    }\n\n    // 计算1~amount的每种情况下所需硬币数\n    for i := 1; i <= amount; i++{\n        for _, coin := range coins {\n            //硬币面额大于amount则跳过\n            if coin <= i {\n                // 求最小dp[i-coin]\n                if dp[i] > dp[i-coin] + 1{\n                    dp[i] = dp[i-coin] + 1\n                }\n            }\n        }\n    }\n\n    if dp[amount] == amount + 1 {\n        return -1\n    } else {\n        return dp[amount]\n    }\n}\n```\n","slug":"leetcode/322.零钱兑换","published":1,"category":"算法","updated":"2022-11-01T02:33:31.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfk00170k4lc0es21sw","content":"<p>动态规划</p>\n<p>自底向上，计算1~amount每个数作为结果所需要的最小硬币数量。</p>\n<p>时间复杂度：O(Sn)，其中 SS 是金额，nn 是面额数<br>空间复杂度：O(S)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">coinChange</span><span class=\"hljs-params\">(coins []<span class=\"hljs-type\">int</span>, amount <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> amount == <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>    &#125;<br>    <br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, amount + <span class=\"hljs-number\">1</span>)<br>    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; amount+<span class=\"hljs-number\">1</span>; i++ &#123;<br>        dp[i] = amount + <span class=\"hljs-number\">1</span><br>    &#125;<br><br>    <span class=\"hljs-comment\">// 计算1~amount的每种情况下所需硬币数</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= amount; i++&#123;<br>        <span class=\"hljs-keyword\">for</span> _, coin := <span class=\"hljs-keyword\">range</span> coins &#123;<br>            <span class=\"hljs-comment\">//硬币面额大于amount则跳过</span><br>            <span class=\"hljs-keyword\">if</span> coin &lt;= i &#123;<br>                <span class=\"hljs-comment\">// 求最小dp[i-coin]</span><br>                <span class=\"hljs-keyword\">if</span> dp[i] &gt; dp[i-coin] + <span class=\"hljs-number\">1</span>&#123;<br>                    dp[i] = dp[i-coin] + <span class=\"hljs-number\">1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> dp[amount] == amount + <span class=\"hljs-number\">1</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> dp[amount]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":562,"excerpt":"<p>动态规划</p>\n<p>自底向上，计算1~amount每个数作为结果所需要的最小硬币数量。</p>\n<p>时间复杂度：O(Sn)，其中 SS 是金额，nn 是面额数<br>空间复杂度：O(S)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">coinChange</span><span class=\"hljs-params\">(coins []<span class=\"hljs-type\">int</span>, amount <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> amount == <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>    &#125;<br>    <br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, amount + <span class=\"hljs-number\">1</span>)<br>    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; amount+<span class=\"hljs-number\">1</span>; i++ &#123;<br>        dp[i] = amount + <span class=\"hljs-number\">1</span><br>    &#125;<br><br>    <span class=\"hljs-comment\">// 计算1~amount的每种情况下所需硬币数</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= amount; i++&#123;<br>        <span class=\"hljs-keyword\">for</span> _, coin := <span class=\"hljs-keyword\">range</span> coins &#123;<br>            <span class=\"hljs-comment\">//硬币面额大于amount则跳过</span><br>            <span class=\"hljs-keyword\">if</span> coin &lt;= i &#123;<br>                <span class=\"hljs-comment\">// 求最小dp[i-coin]</span><br>                <span class=\"hljs-keyword\">if</span> dp[i] &gt; dp[i-coin] + <span class=\"hljs-number\">1</span>&#123;<br>                    dp[i] = dp[i-coin] + <span class=\"hljs-number\">1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> dp[amount] == amount + <span class=\"hljs-number\">1</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> dp[amount]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"297.二叉树的序列化与反序列化","category_bar":true,"date":"2021-09-29T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/submissions/)\n\n时间复杂度： O(n)\n空间复杂度： O(n)\n\n<!-- more -->\n```Go\n/**  \n * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */  \ntype Codec struct {  \n   StrArray []string  \n   path int  \n}  \n  \nfunc Constructor() Codec {  \n   return Codec{  \n      StrArray: []string{},  \n      path: 0,  \n   }  \n}  \n  \n// Serializes a tree to a single string.  \nfunc (this *Codec) serialize(root *TreeNode) string {  \n   this.SeRecusival(root)  \n   // fmt.Printf(\"array: %v\\n\", this.StrArray)  \n  \n   return strings.Join(this.StrArray, \",\")  \n}  \n  \n// Deserializes your encoded data to tree.  \nfunc (this *Codec) deserialize(data string) *TreeNode {  \n   this.StrArray = strings.Split(data, \",\")  \n   this.path = 0  \n  \n   return this.DeRecusival()  \n}  \n  \n// 1 2 nil nil 3 4 nil nil 5 nil nil  \n  \nfunc (this *Codec) DeRecusival() *TreeNode {  \n   if this.StrArray[this.path] == \"nil\" {  \n      return nil  \n   }  \n  \n   intVar, _ := strconv.Atoi(this.StrArray[this.path])  \n  \n   root := &TreeNode{Val: intVar}  \n   this.path++  \n   root.Left = this.DeRecusival()  \n   this.path++  \n   root.Right = this.DeRecusival()  \n  \n   return root  \n}  \n  \nfunc (this *Codec) SeRecusival(root *TreeNode) {  \n   if root == nil {  \n      this.StrArray = append(this.StrArray, \"nil\")  \n      return  \n   }  \n  \n   // fmt.Printf(\"val: %v\\n\", strconv.Itoa(root.Val))  \n  \n   this.StrArray = append(this.StrArray, strconv.Itoa(root.Val))  \n   this.SeRecusival(root.Left)  \n   this.SeRecusival(root.Right)  \n}  \n  \n  \n/**\n\n* Your Codec object will be instantiated and called as such:\n\n* ser := Constructor();\n\n* deser := Constructor();\n\n* data := ser.serialize(root);\n\n* ans := deser.deserialize(data);\n\n*/<!-- more -->\n```\n","source":"_posts/算法/leetcode/297.二叉树的序列化与反序列化.md","raw":"---\ntitle: 297.二叉树的序列化与反序列化\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-30 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/submissions/)\n\n时间复杂度： O(n)\n空间复杂度： O(n)\n\n<!-- more -->\n```Go\n/**  \n * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */  \ntype Codec struct {  \n   StrArray []string  \n   path int  \n}  \n  \nfunc Constructor() Codec {  \n   return Codec{  \n      StrArray: []string{},  \n      path: 0,  \n   }  \n}  \n  \n// Serializes a tree to a single string.  \nfunc (this *Codec) serialize(root *TreeNode) string {  \n   this.SeRecusival(root)  \n   // fmt.Printf(\"array: %v\\n\", this.StrArray)  \n  \n   return strings.Join(this.StrArray, \",\")  \n}  \n  \n// Deserializes your encoded data to tree.  \nfunc (this *Codec) deserialize(data string) *TreeNode {  \n   this.StrArray = strings.Split(data, \",\")  \n   this.path = 0  \n  \n   return this.DeRecusival()  \n}  \n  \n// 1 2 nil nil 3 4 nil nil 5 nil nil  \n  \nfunc (this *Codec) DeRecusival() *TreeNode {  \n   if this.StrArray[this.path] == \"nil\" {  \n      return nil  \n   }  \n  \n   intVar, _ := strconv.Atoi(this.StrArray[this.path])  \n  \n   root := &TreeNode{Val: intVar}  \n   this.path++  \n   root.Left = this.DeRecusival()  \n   this.path++  \n   root.Right = this.DeRecusival()  \n  \n   return root  \n}  \n  \nfunc (this *Codec) SeRecusival(root *TreeNode) {  \n   if root == nil {  \n      this.StrArray = append(this.StrArray, \"nil\")  \n      return  \n   }  \n  \n   // fmt.Printf(\"val: %v\\n\", strconv.Itoa(root.Val))  \n  \n   this.StrArray = append(this.StrArray, strconv.Itoa(root.Val))  \n   this.SeRecusival(root.Left)  \n   this.SeRecusival(root.Right)  \n}  \n  \n  \n/**\n\n* Your Codec object will be instantiated and called as such:\n\n* ser := Constructor();\n\n* deser := Constructor();\n\n* data := ser.serialize(root);\n\n* ans := deser.deserialize(data);\n\n*/<!-- more -->\n```\n","slug":"leetcode/297.二叉树的序列化与反序列化","published":1,"category":"算法","updated":"2022-11-01T02:35:30.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfk00190k4l00no69ho","content":"<p><a href=\"https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/submissions/\">leetcode</a></p>\n<p>时间复杂度： O(n)<br>空间复杂度： O(n)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">/**  </span><br><span class=\"hljs-comment\"> * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */</span>  <br><span class=\"hljs-keyword\">type</span> Codec <span class=\"hljs-keyword\">struct</span> &#123;  <br>   StrArray []<span class=\"hljs-type\">string</span>  <br>   path <span class=\"hljs-type\">int</span>  <br>&#125;  <br>  <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> Codec &#123;  <br>   <span class=\"hljs-keyword\">return</span> Codec&#123;  <br>      StrArray: []<span class=\"hljs-type\">string</span>&#123;&#125;,  <br>      path: <span class=\"hljs-number\">0</span>,  <br>   &#125;  <br>&#125;  <br>  <br><span class=\"hljs-comment\">// Serializes a tree to a single string.  </span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Codec)</span></span> serialize(root *TreeNode) <span class=\"hljs-type\">string</span> &#123;  <br>   this.SeRecusival(root)  <br>   <span class=\"hljs-comment\">// fmt.Printf(&quot;array: %v\\n&quot;, this.StrArray)  </span><br>  <br>   <span class=\"hljs-keyword\">return</span> strings.Join(this.StrArray, <span class=\"hljs-string\">&quot;,&quot;</span>)  <br>&#125;  <br>  <br><span class=\"hljs-comment\">// Deserializes your encoded data to tree.  </span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Codec)</span></span> deserialize(data <span class=\"hljs-type\">string</span>) *TreeNode &#123;  <br>   this.StrArray = strings.Split(data, <span class=\"hljs-string\">&quot;,&quot;</span>)  <br>   this.path = <span class=\"hljs-number\">0</span>  <br>  <br>   <span class=\"hljs-keyword\">return</span> this.DeRecusival()  <br>&#125;  <br>  <br><span class=\"hljs-comment\">// 1 2 nil nil 3 4 nil nil 5 nil nil  </span><br>  <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Codec)</span></span> DeRecusival() *TreeNode &#123;  <br>   <span class=\"hljs-keyword\">if</span> this.StrArray[this.path] == <span class=\"hljs-string\">&quot;nil&quot;</span> &#123;  <br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>  <br>   &#125;  <br>  <br>   intVar, _ := strconv.Atoi(this.StrArray[this.path])  <br>  <br>   root := &amp;TreeNode&#123;Val: intVar&#125;  <br>   this.path++  <br>   root.Left = this.DeRecusival()  <br>   this.path++  <br>   root.Right = this.DeRecusival()  <br>  <br>   <span class=\"hljs-keyword\">return</span> root  <br>&#125;  <br>  <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Codec)</span></span> SeRecusival(root *TreeNode) &#123;  <br>   <span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;  <br>      this.StrArray = <span class=\"hljs-built_in\">append</span>(this.StrArray, <span class=\"hljs-string\">&quot;nil&quot;</span>)  <br>      <span class=\"hljs-keyword\">return</span>  <br>   &#125;  <br>  <br>   <span class=\"hljs-comment\">// fmt.Printf(&quot;val: %v\\n&quot;, strconv.Itoa(root.Val))  </span><br>  <br>   this.StrArray = <span class=\"hljs-built_in\">append</span>(this.StrArray, strconv.Itoa(root.Val))  <br>   this.SeRecusival(root.Left)  <br>   this.SeRecusival(root.Right)  <br>&#125;  <br>  <br>  <br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* Your Codec object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* ser := Constructor();</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* deser := Constructor();</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* data := ser.serialize(root);</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* ans := deser.deserialize(data);</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">*/</span>&lt;!-- more --&gt;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1596,"excerpt":"<p><a href=\"https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/submissions/\">leetcode</a></p>\n<p>时间复杂度： O(n)<br>空间复杂度： O(n)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">/**  </span><br><span class=\"hljs-comment\"> * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */</span>  <br><span class=\"hljs-keyword\">type</span> Codec <span class=\"hljs-keyword\">struct</span> &#123;  <br>   StrArray []<span class=\"hljs-type\">string</span>  <br>   path <span class=\"hljs-type\">int</span>  <br>&#125;  <br>  <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> Codec &#123;  <br>   <span class=\"hljs-keyword\">return</span> Codec&#123;  <br>      StrArray: []<span class=\"hljs-type\">string</span>&#123;&#125;,  <br>      path: <span class=\"hljs-number\">0</span>,  <br>   &#125;  <br>&#125;  <br>  <br><span class=\"hljs-comment\">// Serializes a tree to a single string.  </span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Codec)</span></span> serialize(root *TreeNode) <span class=\"hljs-type\">string</span> &#123;  <br>   this.SeRecusival(root)  <br>   <span class=\"hljs-comment\">// fmt.Printf(&quot;array: %v\\n&quot;, this.StrArray)  </span><br>  <br>   <span class=\"hljs-keyword\">return</span> strings.Join(this.StrArray, <span class=\"hljs-string\">&quot;,&quot;</span>)  <br>&#125;  <br>  <br><span class=\"hljs-comment\">// Deserializes your encoded data to tree.  </span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Codec)</span></span> deserialize(data <span class=\"hljs-type\">string</span>) *TreeNode &#123;  <br>   this.StrArray = strings.Split(data, <span class=\"hljs-string\">&quot;,&quot;</span>)  <br>   this.path = <span class=\"hljs-number\">0</span>  <br>  <br>   <span class=\"hljs-keyword\">return</span> this.DeRecusival()  <br>&#125;  <br>  <br><span class=\"hljs-comment\">// 1 2 nil nil 3 4 nil nil 5 nil nil  </span><br>  <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Codec)</span></span> DeRecusival() *TreeNode &#123;  <br>   <span class=\"hljs-keyword\">if</span> this.StrArray[this.path] == <span class=\"hljs-string\">&quot;nil&quot;</span> &#123;  <br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>  <br>   &#125;  <br>  <br>   intVar, _ := strconv.Atoi(this.StrArray[this.path])  <br>  <br>   root := &amp;TreeNode&#123;Val: intVar&#125;  <br>   this.path++  <br>   root.Left = this.DeRecusival()  <br>   this.path++  <br>   root.Right = this.DeRecusival()  <br>  <br>   <span class=\"hljs-keyword\">return</span> root  <br>&#125;  <br>  <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Codec)</span></span> SeRecusival(root *TreeNode) &#123;  <br>   <span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;  <br>      this.StrArray = <span class=\"hljs-built_in\">append</span>(this.StrArray, <span class=\"hljs-string\">&quot;nil&quot;</span>)  <br>      <span class=\"hljs-keyword\">return</span>  <br>   &#125;  <br>  <br>   <span class=\"hljs-comment\">// fmt.Printf(&quot;val: %v\\n&quot;, strconv.Itoa(root.Val))  </span><br>  <br>   this.StrArray = <span class=\"hljs-built_in\">append</span>(this.StrArray, strconv.Itoa(root.Val))  <br>   this.SeRecusival(root.Left)  <br>   this.SeRecusival(root.Right)  <br>&#125;  <br>  <br>  <br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* Your Codec object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* ser := Constructor();</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* deser := Constructor();</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* data := ser.serialize(root);</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">* ans := deser.deserialize(data);</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">*/</span>&lt;!-- more --&gt;<br></code></pre></td></tr></table></figure>"},{"title":"337.打家劫舍 III","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n后序遍历+动态规划\n\n看到树形结构优先考虑root和左右子树的关系。\n\n使用后序遍历是因为需要得到两个子节点的状态才能计算当前节点。\n\n时间复杂度：O(N)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc rob(root *TreeNode) int {\n    // root[1] = root.left[0] + root.right[0] \n    // root[0] = max(root.left[0], root.left[1]) + max(root.right[0], root.right[1])\n\n    var dfs func(*TreeNode) []int\n    dfs = func(root *TreeNode) []int {\n        if root == nil {\n            return []int{0, 0}\n        }\n\n\t\t// 得到子节点的状态\n        left := dfs(root.Left)\n        right := dfs(root.Right)\n\n\t\t// 状态转移\n        selected := root.Val + left[0] + right[0]\n        noSelected := max(left[0], left[1]) + max(right[0], right[1])\n\n\t\t// 返回状态给上一层使用\n        return []int{noSelected, selected}\n    }\n\n    temp := dfs(root)\n\n    return max(temp[0], temp[1])\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n","source":"_posts/算法/leetcode/337.打家劫舍 III.md","raw":"---\ntitle: 337.打家劫舍 III\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n后序遍历+动态规划\n\n看到树形结构优先考虑root和左右子树的关系。\n\n使用后序遍历是因为需要得到两个子节点的状态才能计算当前节点。\n\n时间复杂度：O(N)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc rob(root *TreeNode) int {\n    // root[1] = root.left[0] + root.right[0] \n    // root[0] = max(root.left[0], root.left[1]) + max(root.right[0], root.right[1])\n\n    var dfs func(*TreeNode) []int\n    dfs = func(root *TreeNode) []int {\n        if root == nil {\n            return []int{0, 0}\n        }\n\n\t\t// 得到子节点的状态\n        left := dfs(root.Left)\n        right := dfs(root.Right)\n\n\t\t// 状态转移\n        selected := root.Val + left[0] + right[0]\n        noSelected := max(left[0], left[1]) + max(right[0], right[1])\n\n\t\t// 返回状态给上一层使用\n        return []int{noSelected, selected}\n    }\n\n    temp := dfs(root)\n\n    return max(temp[0], temp[1])\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n","slug":"leetcode/337.打家劫舍 III","published":1,"category":"算法","updated":"2022-11-01T02:33:32.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfl001c0k4l8ugd1k0z","content":"<p>后序遍历+动态规划</p>\n<p>看到树形结构优先考虑root和左右子树的关系。</p>\n<p>使用后序遍历是因为需要得到两个子节点的状态才能计算当前节点。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">rob</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// root[1] = root.left[0] + root.right[0] </span><br>    <span class=\"hljs-comment\">// root[0] = max(root.left[0], root.left[1]) + max(root.right[0], root.right[1])</span><br><br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(*TreeNode)</span></span> []<span class=\"hljs-type\">int</span><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>&#125;<br>        &#125;<br><br>\t\t<span class=\"hljs-comment\">// 得到子节点的状态</span><br>        left := dfs(root.Left)<br>        right := dfs(root.Right)<br><br>\t\t<span class=\"hljs-comment\">// 状态转移</span><br>        selected := root.Val + left[<span class=\"hljs-number\">0</span>] + right[<span class=\"hljs-number\">0</span>]<br>        noSelected := max(left[<span class=\"hljs-number\">0</span>], left[<span class=\"hljs-number\">1</span>]) + max(right[<span class=\"hljs-number\">0</span>], right[<span class=\"hljs-number\">1</span>])<br><br>\t\t<span class=\"hljs-comment\">// 返回状态给上一层使用</span><br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;noSelected, selected&#125;<br>    &#125;<br><br>    temp := dfs(root)<br><br>    <span class=\"hljs-keyword\">return</span> max(temp[<span class=\"hljs-number\">0</span>], temp[<span class=\"hljs-number\">1</span>])<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":707,"excerpt":"<p>后序遍历+动态规划</p>\n<p>看到树形结构优先考虑root和左右子树的关系。</p>\n<p>使用后序遍历是因为需要得到两个子节点的状态才能计算当前节点。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">rob</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// root[1] = root.left[0] + root.right[0] </span><br>    <span class=\"hljs-comment\">// root[0] = max(root.left[0], root.left[1]) + max(root.right[0], root.right[1])</span><br><br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(*TreeNode)</span></span> []<span class=\"hljs-type\">int</span><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>&#125;<br>        &#125;<br><br>\t\t<span class=\"hljs-comment\">// 得到子节点的状态</span><br>        left := dfs(root.Left)<br>        right := dfs(root.Right)<br><br>\t\t<span class=\"hljs-comment\">// 状态转移</span><br>        selected := root.Val + left[<span class=\"hljs-number\">0</span>] + right[<span class=\"hljs-number\">0</span>]<br>        noSelected := max(left[<span class=\"hljs-number\">0</span>], left[<span class=\"hljs-number\">1</span>]) + max(right[<span class=\"hljs-number\">0</span>], right[<span class=\"hljs-number\">1</span>])<br><br>\t\t<span class=\"hljs-comment\">// 返回状态给上一层使用</span><br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;noSelected, selected&#125;<br>    &#125;<br><br>    temp := dfs(root)<br><br>    <span class=\"hljs-keyword\">return</span> max(temp[<span class=\"hljs-number\">0</span>], temp[<span class=\"hljs-number\">1</span>])<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"327.区间的个数","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n归并排序，排序时统计符合条件的下标对。\n\n<!-- more -->\n```GO\nfunc countRangeSum(nums []int, lower int, upper int) int {\n    // 计算前缀和\n    preSum := make([]int, len(nums) + 1)\n    for i, v := range nums {\n        preSum[i + 1] = preSum[i] + v\n    }\n\n    var countSum func([]int) int\n\n    countSum = func(arr []int) int {\n        length := len(arr)\n        if length <= 1 {\n            return 0\n        }\n\n        left := append([]int{}, arr[:length/2]...)\n        right := append([]int{}, arr[length/2:]...)\n\n        count := countSum(left) + countSum(right)\n\n\t\t// 统计符合条件的下标对\n        l, r := 0, 0\n        for _, v := range left {\n            for l < len(right) && right[l] - v < lower {\n                l++\n            }\n\n            for r < len(right) && right[r] - v <= upper {\n                r++\n            }\n\n            count += r - l\n        }\n\n        // 合并左右数组\n        p1, p2 := 0, 0\n        for i := range arr {\n            if p1 < len(left) && ( p2 == len(right) || left[p1] <= right[p2]) {\n                arr[i] = left[p1]\n                p1++\n            } else {\n                arr[i] = right[p2]\n                p2++\n            }\n        }\n\n        return count\n    }\n\n    return countSum(preSum)\n}\n```\n","source":"_posts/算法/leetcode/327.区间的个数.md","raw":"---\ntitle: 327.区间的个数\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n归并排序，排序时统计符合条件的下标对。\n\n<!-- more -->\n```GO\nfunc countRangeSum(nums []int, lower int, upper int) int {\n    // 计算前缀和\n    preSum := make([]int, len(nums) + 1)\n    for i, v := range nums {\n        preSum[i + 1] = preSum[i] + v\n    }\n\n    var countSum func([]int) int\n\n    countSum = func(arr []int) int {\n        length := len(arr)\n        if length <= 1 {\n            return 0\n        }\n\n        left := append([]int{}, arr[:length/2]...)\n        right := append([]int{}, arr[length/2:]...)\n\n        count := countSum(left) + countSum(right)\n\n\t\t// 统计符合条件的下标对\n        l, r := 0, 0\n        for _, v := range left {\n            for l < len(right) && right[l] - v < lower {\n                l++\n            }\n\n            for r < len(right) && right[r] - v <= upper {\n                r++\n            }\n\n            count += r - l\n        }\n\n        // 合并左右数组\n        p1, p2 := 0, 0\n        for i := range arr {\n            if p1 < len(left) && ( p2 == len(right) || left[p1] <= right[p2]) {\n                arr[i] = left[p1]\n                p1++\n            } else {\n                arr[i] = right[p2]\n                p2++\n            }\n        }\n\n        return count\n    }\n\n    return countSum(preSum)\n}\n```\n","slug":"leetcode/327.区间的个数","published":1,"category":"算法","updated":"2022-11-01T02:33:31.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfl001e0k4l03091tlr","content":"<p>归并排序，排序时统计符合条件的下标对。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs GO\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">countRangeSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, lower <span class=\"hljs-type\">int</span>, upper <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// 计算前缀和</span><br>    preSum := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(nums) + <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>        preSum[i + <span class=\"hljs-number\">1</span>] = preSum[i] + v<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> countSum <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">([]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span><br><br>    countSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(arr []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        length := <span class=\"hljs-built_in\">len</span>(arr)<br>        <span class=\"hljs-keyword\">if</span> length &lt;= <span class=\"hljs-number\">1</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>        &#125;<br><br>        left := <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, arr[:length/<span class=\"hljs-number\">2</span>]...)<br>        right := <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, arr[length/<span class=\"hljs-number\">2</span>:]...)<br><br>        count := countSum(left) + countSum(right)<br><br>\t\t<span class=\"hljs-comment\">// 统计符合条件的下标对</span><br>        l, r := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> left &#123;<br>            <span class=\"hljs-keyword\">for</span> l &lt; <span class=\"hljs-built_in\">len</span>(right) &amp;&amp; right[l] - v &lt; lower &#123;<br>                l++<br>            &#125;<br><br>            <span class=\"hljs-keyword\">for</span> r &lt; <span class=\"hljs-built_in\">len</span>(right) &amp;&amp; right[r] - v &lt;= upper &#123;<br>                r++<br>            &#125;<br><br>            count += r - l<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 合并左右数组</span><br>        p1, p2 := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> arr &#123;<br>            <span class=\"hljs-keyword\">if</span> p1 &lt; <span class=\"hljs-built_in\">len</span>(left) &amp;&amp; ( p2 == <span class=\"hljs-built_in\">len</span>(right) || left[p1] &lt;= right[p2]) &#123;<br>                arr[i] = left[p1]<br>                p1++<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                arr[i] = right[p2]<br>                p2++<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> count<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> countSum(preSum)<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":906,"excerpt":"<p>归并排序，排序时统计符合条件的下标对。</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs GO\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">countRangeSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, lower <span class=\"hljs-type\">int</span>, upper <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// 计算前缀和</span><br>    preSum := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(nums) + <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>        preSum[i + <span class=\"hljs-number\">1</span>] = preSum[i] + v<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> countSum <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">([]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span><br><br>    countSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(arr []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        length := <span class=\"hljs-built_in\">len</span>(arr)<br>        <span class=\"hljs-keyword\">if</span> length &lt;= <span class=\"hljs-number\">1</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>        &#125;<br><br>        left := <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, arr[:length/<span class=\"hljs-number\">2</span>]...)<br>        right := <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, arr[length/<span class=\"hljs-number\">2</span>:]...)<br><br>        count := countSum(left) + countSum(right)<br><br>\t\t<span class=\"hljs-comment\">// 统计符合条件的下标对</span><br>        l, r := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> left &#123;<br>            <span class=\"hljs-keyword\">for</span> l &lt; <span class=\"hljs-built_in\">len</span>(right) &amp;&amp; right[l] - v &lt; lower &#123;<br>                l++<br>            &#125;<br><br>            <span class=\"hljs-keyword\">for</span> r &lt; <span class=\"hljs-built_in\">len</span>(right) &amp;&amp; right[r] - v &lt;= upper &#123;<br>                r++<br>            &#125;<br><br>            count += r - l<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 合并左右数组</span><br>        p1, p2 := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> arr &#123;<br>            <span class=\"hljs-keyword\">if</span> p1 &lt; <span class=\"hljs-built_in\">len</span>(left) &amp;&amp; ( p2 == <span class=\"hljs-built_in\">len</span>(right) || left[p1] &lt;= right[p2]) &#123;<br>                arr[i] = left[p1]<br>                p1++<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                arr[i] = right[p2]<br>                p2++<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> count<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> countSum(preSum)<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"34.在排序数组中查找元素的第一个和最后一个位置","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n进行两次二分查找\n\n时间复杂度：O(logN)\n空间复杂度：O(1)\n<!-- more -->\n```Go\n// 手写二分查找\nfunc searchRange(nums []int, target int) []int {\n    if len(nums) == 0 {\n        return []int{-1, -1}\n    }\n\n    ans := []int{}\n    left, right := 0, len(nums) - 1\n    for left < right {\n        mid := (left + right) / 2\n        if nums[mid] >= target {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n\n    if nums[right] != target {\n        ans = []int{-1, -1}\n        return ans\n    } else {\n        ans = append(ans, right)\n    }\n\n    right = len(nums) - 1\n    for left < right {\n        mid := (left + right + 1) / 2\n        if nums[mid] <= target {\n            left = mid\n        } else {\n            right = mid - 1\n        }\n    }\n\n    if nums[right] == target {\n        ans = append(ans, right)\n    } else {\n        ans = append(ans, ans[0])\n    }\n\n    return ans\n\n}\n```\n<!-- more -->\n```Go\n// 使用标准库\n\nfunc searchRange(nums []int, target int) []int {\n\tleftmost := sort.SearchInts(nums, target)\n\tif leftmost == len(nums) || nums[leftmost] != target {\n\t\t// 没有找到target\n\t\treturn []int{-1, -1}\n\t}\n\n\t// nums中至少有一个target\n\trightmost := sort.SearchInts(nums, target + 1) - 1\n\treturn []int{leftmost, rightmost}\n}\n```\n","source":"_posts/算法/leetcode/34.在排序数组中查找元素的第一个和最后一个位置.md","raw":"---\ntitle: 34.在排序数组中查找元素的第一个和最后一个位置\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n进行两次二分查找\n\n时间复杂度：O(logN)\n空间复杂度：O(1)\n<!-- more -->\n```Go\n// 手写二分查找\nfunc searchRange(nums []int, target int) []int {\n    if len(nums) == 0 {\n        return []int{-1, -1}\n    }\n\n    ans := []int{}\n    left, right := 0, len(nums) - 1\n    for left < right {\n        mid := (left + right) / 2\n        if nums[mid] >= target {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n\n    if nums[right] != target {\n        ans = []int{-1, -1}\n        return ans\n    } else {\n        ans = append(ans, right)\n    }\n\n    right = len(nums) - 1\n    for left < right {\n        mid := (left + right + 1) / 2\n        if nums[mid] <= target {\n            left = mid\n        } else {\n            right = mid - 1\n        }\n    }\n\n    if nums[right] == target {\n        ans = append(ans, right)\n    } else {\n        ans = append(ans, ans[0])\n    }\n\n    return ans\n\n}\n```\n<!-- more -->\n```Go\n// 使用标准库\n\nfunc searchRange(nums []int, target int) []int {\n\tleftmost := sort.SearchInts(nums, target)\n\tif leftmost == len(nums) || nums[leftmost] != target {\n\t\t// 没有找到target\n\t\treturn []int{-1, -1}\n\t}\n\n\t// nums中至少有一个target\n\trightmost := sort.SearchInts(nums, target + 1) - 1\n\treturn []int{leftmost, rightmost}\n}\n```\n","slug":"leetcode/34.在排序数组中查找元素的第一个和最后一个位置","published":1,"category":"算法","updated":"2022-11-01T02:33:32.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfo001h0k4l4ceab3by","content":"<p>进行两次二分查找</p>\n<p>时间复杂度：O(logN)<br>空间复杂度：O(1)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 手写二分查找</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(nums) == <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>    &#125;<br><br>    ans := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>    left, right := <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        mid := (left + right) / <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[mid] &gt;= target &#123;<br>            right = mid<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            left = mid + <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> nums[right] != target &#123;<br>        ans = []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>        <span class=\"hljs-keyword\">return</span> ans<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, right)<br>    &#125;<br><br>    right = <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        mid := (left + right + <span class=\"hljs-number\">1</span>) / <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[mid] &lt;= target &#123;<br>            left = mid<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            right = mid - <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> nums[right] == target &#123;<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, right)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, ans[<span class=\"hljs-number\">0</span>])<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<!-- more -->\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 使用标准库</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tleftmost := sort.SearchInts(nums, target)<br>\t<span class=\"hljs-keyword\">if</span> leftmost == <span class=\"hljs-built_in\">len</span>(nums) || nums[leftmost] != target &#123;<br>\t\t<span class=\"hljs-comment\">// 没有找到target</span><br>\t\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// nums中至少有一个target</span><br>\trightmost := sort.SearchInts(nums, target + <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;leftmost, rightmost&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1041,"excerpt":"<p>进行两次二分查找</p>\n<p>时间复杂度：O(logN)<br>空间复杂度：O(1)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 手写二分查找</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(nums) == <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>    &#125;<br><br>    ans := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>    left, right := <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        mid := (left + right) / <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[mid] &gt;= target &#123;<br>            right = mid<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            left = mid + <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> nums[right] != target &#123;<br>        ans = []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>        <span class=\"hljs-keyword\">return</span> ans<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, right)<br>    &#125;<br><br>    right = <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        mid := (left + right + <span class=\"hljs-number\">1</span>) / <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[mid] &lt;= target &#123;<br>            left = mid<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            right = mid - <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> nums[right] == target &#123;<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, right)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, ans[<span class=\"hljs-number\">0</span>])<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<!-- more -->\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 使用标准库</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tleftmost := sort.SearchInts(nums, target)<br>\t<span class=\"hljs-keyword\">if</span> leftmost == <span class=\"hljs-built_in\">len</span>(nums) || nums[leftmost] != target &#123;<br>\t\t<span class=\"hljs-comment\">// 没有找到target</span><br>\t\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// nums中至少有一个target</span><br>\trightmost := sort.SearchInts(nums, target + <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;leftmost, rightmost&#125;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"394. 字符串解码","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n递归处理\n<!-- more -->\n```Go\nfunc decodeString(s string) string {\n    // fmt.Printf(\"s: %v\\n\", s)\n    ans := \"\"\n\n    l, r, lc := 0, 0, 0\n    n := len(s)\n    count := \"\"\n\n    for i := 0; i < n; i++ {\n\n        if s[i] == '[' {\n            if lc == 0 {\n                l = i + 1\n            }\n            lc++\n            continue\n        }\n\n        if s[i] == ']' {\n            lc--\n            if lc == 0 {\n                r = i\n                temp := decodeString(s[l:r])\n                // fmt.Printf(\"temp: %v\\n\", s[l:r])\n                cnt, _ := strconv.Atoi(count)\n                \n                \n                for j := 0; j < cnt; j++ {\n                    ans += string(temp)\n                }\n                count = \"\"\n            }\n\n            continue\n        }\n\n        if lc == 0 {\n            if s[i] < '0' || s[i] > '9' {\n                ans += string(s[i])\n            } else  {\n                count += string(s[i])\n                // fmt.Printf(\"count: %v\\n\", count)\n            }\n        }\n\n    }\n\n    // fmt.Printf(\"ans: %v\\n\", ans)\n    return ans\n}\n```\n","source":"_posts/算法/leetcode/394. 字符串解码.md","raw":"---\ntitle: 394. 字符串解码\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n递归处理\n<!-- more -->\n```Go\nfunc decodeString(s string) string {\n    // fmt.Printf(\"s: %v\\n\", s)\n    ans := \"\"\n\n    l, r, lc := 0, 0, 0\n    n := len(s)\n    count := \"\"\n\n    for i := 0; i < n; i++ {\n\n        if s[i] == '[' {\n            if lc == 0 {\n                l = i + 1\n            }\n            lc++\n            continue\n        }\n\n        if s[i] == ']' {\n            lc--\n            if lc == 0 {\n                r = i\n                temp := decodeString(s[l:r])\n                // fmt.Printf(\"temp: %v\\n\", s[l:r])\n                cnt, _ := strconv.Atoi(count)\n                \n                \n                for j := 0; j < cnt; j++ {\n                    ans += string(temp)\n                }\n                count = \"\"\n            }\n\n            continue\n        }\n\n        if lc == 0 {\n            if s[i] < '0' || s[i] > '9' {\n                ans += string(s[i])\n            } else  {\n                count += string(s[i])\n                // fmt.Printf(\"count: %v\\n\", count)\n            }\n        }\n\n    }\n\n    // fmt.Printf(\"ans: %v\\n\", ans)\n    return ans\n}\n```\n","slug":"leetcode/394. 字符串解码","published":1,"category":"算法","updated":"2022-11-01T02:33:31.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfo001j0k4l5gqhhzm7","content":"<p>递归处理</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">decodeString</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;s: %v\\n&quot;, s)</span><br>    ans := <span class=\"hljs-string\">&quot;&quot;</span><br><br>    l, r, lc := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>    n := <span class=\"hljs-built_in\">len</span>(s)<br>    count := <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br><br>        <span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27;[&#x27;</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> lc == <span class=\"hljs-number\">0</span> &#123;<br>                l = i + <span class=\"hljs-number\">1</span><br>            &#125;<br>            lc++<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27;]&#x27;</span> &#123;<br>            lc--<br>            <span class=\"hljs-keyword\">if</span> lc == <span class=\"hljs-number\">0</span> &#123;<br>                r = i<br>                temp := decodeString(s[l:r])<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;temp: %v\\n&quot;, s[l:r])</span><br>                cnt, _ := strconv.Atoi(count)<br>                <br>                <br>                <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; cnt; j++ &#123;<br>                    ans += <span class=\"hljs-type\">string</span>(temp)<br>                &#125;<br>                count = <span class=\"hljs-string\">&quot;&quot;</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> lc == <span class=\"hljs-number\">0</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> s[i] &lt; <span class=\"hljs-string\">&#x27;0&#x27;</span> || s[i] &gt; <span class=\"hljs-string\">&#x27;9&#x27;</span> &#123;<br>                ans += <span class=\"hljs-type\">string</span>(s[i])<br>            &#125; <span class=\"hljs-keyword\">else</span>  &#123;<br>                count += <span class=\"hljs-type\">string</span>(s[i])<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;count: %v\\n&quot;, count)</span><br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;ans: %v\\n&quot;, ans)</span><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":775,"excerpt":"<p>递归处理</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">decodeString</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;s: %v\\n&quot;, s)</span><br>    ans := <span class=\"hljs-string\">&quot;&quot;</span><br><br>    l, r, lc := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>    n := <span class=\"hljs-built_in\">len</span>(s)<br>    count := <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br><br>        <span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27;[&#x27;</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> lc == <span class=\"hljs-number\">0</span> &#123;<br>                l = i + <span class=\"hljs-number\">1</span><br>            &#125;<br>            lc++<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27;]&#x27;</span> &#123;<br>            lc--<br>            <span class=\"hljs-keyword\">if</span> lc == <span class=\"hljs-number\">0</span> &#123;<br>                r = i<br>                temp := decodeString(s[l:r])<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;temp: %v\\n&quot;, s[l:r])</span><br>                cnt, _ := strconv.Atoi(count)<br>                <br>                <br>                <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; cnt; j++ &#123;<br>                    ans += <span class=\"hljs-type\">string</span>(temp)<br>                &#125;<br>                count = <span class=\"hljs-string\">&quot;&quot;</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> lc == <span class=\"hljs-number\">0</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> s[i] &lt; <span class=\"hljs-string\">&#x27;0&#x27;</span> || s[i] &gt; <span class=\"hljs-string\">&#x27;9&#x27;</span> &#123;<br>                ans += <span class=\"hljs-type\">string</span>(s[i])<br>            &#125; <span class=\"hljs-keyword\">else</span>  &#123;<br>                count += <span class=\"hljs-type\">string</span>(s[i])<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;count: %v\\n&quot;, count)</span><br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;ans: %v\\n&quot;, ans)</span><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"45. 跳跃游戏 II","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n动态规划\n\n从后往前考虑。\n\n时间复杂度：O(N^2)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc jump(nums []int) int {\n    count := 0\n    r := len(nums) - 1\n\n    for r > 0 {\n        for i := 0; i < r; i++ {\n            if nums[i] >= r - i {\n                r = i\n                count++\n                break\n            }\n        }\n    }\n\n    return count\n}\n```\n\n从前往后考虑。\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc jump(nums []int) int {\n    count := 0\n    n := len(nums)\n    maxPosition := 0\n    end := 0\n    // r := len(nums) - 1\n\n\tfor i := 0; i < n - 1; i++ {\n\t\tmaxPosition = max(maxPosition, i + nums[i])\n\t\tif i == end {\n\t\t\tend = maxPosition\n\t\t\tcount++\n\t\t}\n\t}\n    \n    return count\n}\n\nfunc max(x, y int) int {\n    if x > y {\n        return x\n    }\n    return y\n}\n```\n","source":"_posts/算法/leetcode/45. 跳跃游戏 II.md","raw":"---\ntitle: 45. 跳跃游戏 II\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n动态规划\n\n从后往前考虑。\n\n时间复杂度：O(N^2)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc jump(nums []int) int {\n    count := 0\n    r := len(nums) - 1\n\n    for r > 0 {\n        for i := 0; i < r; i++ {\n            if nums[i] >= r - i {\n                r = i\n                count++\n                break\n            }\n        }\n    }\n\n    return count\n}\n```\n\n从前往后考虑。\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc jump(nums []int) int {\n    count := 0\n    n := len(nums)\n    maxPosition := 0\n    end := 0\n    // r := len(nums) - 1\n\n\tfor i := 0; i < n - 1; i++ {\n\t\tmaxPosition = max(maxPosition, i + nums[i])\n\t\tif i == end {\n\t\t\tend = maxPosition\n\t\t\tcount++\n\t\t}\n\t}\n    \n    return count\n}\n\nfunc max(x, y int) int {\n    if x > y {\n        return x\n    }\n    return y\n}\n```\n","slug":"leetcode/45. 跳跃游戏 II","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfp001l0k4l3q6e08de","content":"<p>动态规划</p>\n<p>从后往前考虑。</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(1)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">jump</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    count := <span class=\"hljs-number\">0</span><br>    r := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> r &gt; <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; r; i++ &#123;<br>            <span class=\"hljs-keyword\">if</span> nums[i] &gt;= r - i &#123;<br>                r = i<br>                count++<br>                <span class=\"hljs-keyword\">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从前往后考虑。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(1)</p>\n<!-- more -->\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">jump</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    count := <span class=\"hljs-number\">0</span><br>    n := <span class=\"hljs-built_in\">len</span>(nums)<br>    maxPosition := <span class=\"hljs-number\">0</span><br>    end := <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-comment\">// r := len(nums) - 1</span><br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++ &#123;<br>\t\tmaxPosition = max(maxPosition, i + nums[i])<br>\t\t<span class=\"hljs-keyword\">if</span> i == end &#123;<br>\t\t\tend = maxPosition<br>\t\t\tcount++<br>\t\t&#125;<br>\t&#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> count<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> x &gt; y &#123;<br>        <span class=\"hljs-keyword\">return</span> x<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":561,"excerpt":"<p>动态规划</p>\n<p>从后往前考虑。</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(1)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">jump</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    count := <span class=\"hljs-number\">0</span><br>    r := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> r &gt; <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; r; i++ &#123;<br>            <span class=\"hljs-keyword\">if</span> nums[i] &gt;= r - i &#123;<br>                r = i<br>                count++<br>                <span class=\"hljs-keyword\">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从前往后考虑。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(1)</p>\n<!-- more -->\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">jump</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    count := <span class=\"hljs-number\">0</span><br>    n := <span class=\"hljs-built_in\">len</span>(nums)<br>    maxPosition := <span class=\"hljs-number\">0</span><br>    end := <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-comment\">// r := len(nums) - 1</span><br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++ &#123;<br>\t\tmaxPosition = max(maxPosition, i + nums[i])<br>\t\t<span class=\"hljs-keyword\">if</span> i == end &#123;<br>\t\t\tend = maxPosition<br>\t\t\tcount++<br>\t\t&#125;<br>\t&#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> count<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> x &gt; y &#123;<br>        <span class=\"hljs-keyword\">return</span> x<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"433.最小基因变化","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/minimum-genetic-mutation/)\n\n广度优先搜索\n\n广度优先搜索的时候，注意要去掉已遍历过的情况，方法是从bankMap中删除已遍历的元素。\n\n时间复杂度：O(C x n x m)，其中C为基因位的可选项数量（此处为ACGT四种，C为4）， m为bank的长度，n为基因序列的长度。\n空间复杂度： O(m x n)。合法性的哈希表中一共存有 m个元素，队列中最多有 mm 个元素，每个元素的空间为 O(n)。O(m + n x m) = O(m x n)\n\n<!-- more -->\n```Go\nfunc minMutation(start string, end string, bank []string) int {\n    if start == end {\n        return 0\n    }\n\n    if len(bank) == 0 {\n        return -1\n    }\n\n    bankMap := map[string]bool{}\n    queue := []string{}\n\n    for _, g := range bank {\n        bankMap[g] = true\n    }\n\n    queue = append(queue, start)\n\n    // 最少也进行了一次变化\n    for count := 1; len(queue) != 0; count++ {\n        for _, cur := range queue {\n            queue = queue[1:]\n            for i, x := range cur {\n                for _, y := range \"ACGT\" {\n                    if y != x {\n                        cur := cur[:i] + string(y) + cur[i+1:]\n                        // fmt.Printf(\"index: %v cur: %v\\n\", i, cur)\n                        if _, ok := bankMap[cur]; ok {\n                            if cur == end {\n                                return count\n                            }\n                            queue = append(queue, cur)\n                        \n                            // 去除已经遍历过的情况 \n                            delete(bankMap, cur)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return -1\n\n}\n```\n","source":"_posts/算法/leetcode/433.最小基因变化.md","raw":"---\ntitle: 433.最小基因变化\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/minimum-genetic-mutation/)\n\n广度优先搜索\n\n广度优先搜索的时候，注意要去掉已遍历过的情况，方法是从bankMap中删除已遍历的元素。\n\n时间复杂度：O(C x n x m)，其中C为基因位的可选项数量（此处为ACGT四种，C为4）， m为bank的长度，n为基因序列的长度。\n空间复杂度： O(m x n)。合法性的哈希表中一共存有 m个元素，队列中最多有 mm 个元素，每个元素的空间为 O(n)。O(m + n x m) = O(m x n)\n\n<!-- more -->\n```Go\nfunc minMutation(start string, end string, bank []string) int {\n    if start == end {\n        return 0\n    }\n\n    if len(bank) == 0 {\n        return -1\n    }\n\n    bankMap := map[string]bool{}\n    queue := []string{}\n\n    for _, g := range bank {\n        bankMap[g] = true\n    }\n\n    queue = append(queue, start)\n\n    // 最少也进行了一次变化\n    for count := 1; len(queue) != 0; count++ {\n        for _, cur := range queue {\n            queue = queue[1:]\n            for i, x := range cur {\n                for _, y := range \"ACGT\" {\n                    if y != x {\n                        cur := cur[:i] + string(y) + cur[i+1:]\n                        // fmt.Printf(\"index: %v cur: %v\\n\", i, cur)\n                        if _, ok := bankMap[cur]; ok {\n                            if cur == end {\n                                return count\n                            }\n                            queue = append(queue, cur)\n                        \n                            // 去除已经遍历过的情况 \n                            delete(bankMap, cur)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return -1\n\n}\n```\n","slug":"leetcode/433.最小基因变化","published":1,"category":"算法","updated":"2022-11-01T02:33:32.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfp001n0k4lhvxpbgy2","content":"<p><a href=\"https://leetcode.cn/problems/minimum-genetic-mutation/\">leetcode</a></p>\n<p>广度优先搜索</p>\n<p>广度优先搜索的时候，注意要去掉已遍历过的情况，方法是从bankMap中删除已遍历的元素。</p>\n<p>时间复杂度：O(C x n x m)，其中C为基因位的可选项数量（此处为ACGT四种，C为4）， m为bank的长度，n为基因序列的长度。<br>空间复杂度： O(m x n)。合法性的哈希表中一共存有 m个元素，队列中最多有 mm 个元素，每个元素的空间为 O(n)。O(m + n x m) &#x3D; O(m x n)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minMutation</span><span class=\"hljs-params\">(start <span class=\"hljs-type\">string</span>, end <span class=\"hljs-type\">string</span>, bank []<span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> start == end &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(bank) == <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>    &#125;<br><br>    bankMap := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">bool</span>&#123;&#125;<br>    queue := []<span class=\"hljs-type\">string</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">for</span> _, g := <span class=\"hljs-keyword\">range</span> bank &#123;<br>        bankMap[g] = <span class=\"hljs-literal\">true</span><br>    &#125;<br><br>    queue = <span class=\"hljs-built_in\">append</span>(queue, start)<br><br>    <span class=\"hljs-comment\">// 最少也进行了一次变化</span><br>    <span class=\"hljs-keyword\">for</span> count := <span class=\"hljs-number\">1</span>; <span class=\"hljs-built_in\">len</span>(queue) != <span class=\"hljs-number\">0</span>; count++ &#123;<br>        <span class=\"hljs-keyword\">for</span> _, cur := <span class=\"hljs-keyword\">range</span> queue &#123;<br>            queue = queue[<span class=\"hljs-number\">1</span>:]<br>            <span class=\"hljs-keyword\">for</span> i, x := <span class=\"hljs-keyword\">range</span> cur &#123;<br>                <span class=\"hljs-keyword\">for</span> _, y := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-string\">&quot;ACGT&quot;</span> &#123;<br>                    <span class=\"hljs-keyword\">if</span> y != x &#123;<br>                        cur := cur[:i] + <span class=\"hljs-type\">string</span>(y) + cur[i+<span class=\"hljs-number\">1</span>:]<br>                        <span class=\"hljs-comment\">// fmt.Printf(&quot;index: %v cur: %v\\n&quot;, i, cur)</span><br>                        <span class=\"hljs-keyword\">if</span> _, ok := bankMap[cur]; ok &#123;<br>                            <span class=\"hljs-keyword\">if</span> cur == end &#123;<br>                                <span class=\"hljs-keyword\">return</span> count<br>                            &#125;<br>                            queue = <span class=\"hljs-built_in\">append</span>(queue, cur)<br>                        <br>                            <span class=\"hljs-comment\">// 去除已经遍历过的情况 </span><br>                            <span class=\"hljs-built_in\">delete</span>(bankMap, cur)<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br><br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":942,"excerpt":"<p><a href=\"https://leetcode.cn/problems/minimum-genetic-mutation/\">leetcode</a></p>\n<p>广度优先搜索</p>\n<p>广度优先搜索的时候，注意要去掉已遍历过的情况，方法是从bankMap中删除已遍历的元素。</p>\n<p>时间复杂度：O(C x n x m)，其中C为基因位的可选项数量（此处为ACGT四种，C为4）， m为bank的长度，n为基因序列的长度。<br>空间复杂度： O(m x n)。合法性的哈希表中一共存有 m个元素，队列中最多有 mm 个元素，每个元素的空间为 O(n)。O(m + n x m) &#x3D; O(m x n)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minMutation</span><span class=\"hljs-params\">(start <span class=\"hljs-type\">string</span>, end <span class=\"hljs-type\">string</span>, bank []<span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> start == end &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(bank) == <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>    &#125;<br><br>    bankMap := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">bool</span>&#123;&#125;<br>    queue := []<span class=\"hljs-type\">string</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">for</span> _, g := <span class=\"hljs-keyword\">range</span> bank &#123;<br>        bankMap[g] = <span class=\"hljs-literal\">true</span><br>    &#125;<br><br>    queue = <span class=\"hljs-built_in\">append</span>(queue, start)<br><br>    <span class=\"hljs-comment\">// 最少也进行了一次变化</span><br>    <span class=\"hljs-keyword\">for</span> count := <span class=\"hljs-number\">1</span>; <span class=\"hljs-built_in\">len</span>(queue) != <span class=\"hljs-number\">0</span>; count++ &#123;<br>        <span class=\"hljs-keyword\">for</span> _, cur := <span class=\"hljs-keyword\">range</span> queue &#123;<br>            queue = queue[<span class=\"hljs-number\">1</span>:]<br>            <span class=\"hljs-keyword\">for</span> i, x := <span class=\"hljs-keyword\">range</span> cur &#123;<br>                <span class=\"hljs-keyword\">for</span> _, y := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-string\">&quot;ACGT&quot;</span> &#123;<br>                    <span class=\"hljs-keyword\">if</span> y != x &#123;<br>                        cur := cur[:i] + <span class=\"hljs-type\">string</span>(y) + cur[i+<span class=\"hljs-number\">1</span>:]<br>                        <span class=\"hljs-comment\">// fmt.Printf(&quot;index: %v cur: %v\\n&quot;, i, cur)</span><br>                        <span class=\"hljs-keyword\">if</span> _, ok := bankMap[cur]; ok &#123;<br>                            <span class=\"hljs-keyword\">if</span> cur == end &#123;<br>                                <span class=\"hljs-keyword\">return</span> count<br>                            &#125;<br>                            queue = <span class=\"hljs-built_in\">append</span>(queue, cur)<br>                        <br>                            <span class=\"hljs-comment\">// 去除已经遍历过的情况 </span><br>                            <span class=\"hljs-built_in\">delete</span>(bankMap, cur)<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br><br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"47.全排列2","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/permutations-ii/)\n\n深度优先搜索\n<!-- more -->\n```Go\nvar ans [][]int\n\n  \n\nfunc permuteUnique(nums []int) [][]int {\n\n\tsort.Ints(nums)\n\t\n\tused := make([]bool, len(nums))\n\t\n\tarr := []int{}\n\t\n\tans = [][]int{}\n\t\n\t  \n\t\n\tdfs(nums, used, arr)\n\t\n\treturn ans\n\n}\n\n  \n\nfunc dfs(nums []int, used []bool, arr []int) {\n\n\tif len(arr) == len(nums) {\n\t\n\t\tans = append(ans, append([]int{}, arr...))\n\t\t\n\t\treturn\n\t\t\n\t}\n\t\n\t  \n\t\n\tfor i := 0; i < len(nums); i++ {\n\t\n\t\tif used[i] {\n\t\t\n\t\t\tcontinue\n\t\t\n\t\t}\n\t\t\n\t\t  \n\t\t\n\t\t// 上一个元素如果和当前元素相同且没使用过，则跳过当前元素，防止重复\n\t\t\n\t\tif i > 0 && nums[i] == nums[i-1] && !used[i-1] {\n\t\t\n\t\t\tcontinue\n\t\t\n\t\t}\n\t\t\n\t\t  \n\t\t\n\t\tarr = append(arr, nums[i])\n\t\t\n\t\tused[i] = true\n\t\t\n\t\tdfs(nums, used, arr)\n\t\t\n\t\tused[i] = false\n\t\t\n\t\tarr = arr[:len(arr)-1]\n\t\n\t}\n\n}\n```\n","source":"_posts/算法/leetcode/47.全排列2.md","raw":"---\ntitle: 47.全排列2\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/permutations-ii/)\n\n深度优先搜索\n<!-- more -->\n```Go\nvar ans [][]int\n\n  \n\nfunc permuteUnique(nums []int) [][]int {\n\n\tsort.Ints(nums)\n\t\n\tused := make([]bool, len(nums))\n\t\n\tarr := []int{}\n\t\n\tans = [][]int{}\n\t\n\t  \n\t\n\tdfs(nums, used, arr)\n\t\n\treturn ans\n\n}\n\n  \n\nfunc dfs(nums []int, used []bool, arr []int) {\n\n\tif len(arr) == len(nums) {\n\t\n\t\tans = append(ans, append([]int{}, arr...))\n\t\t\n\t\treturn\n\t\t\n\t}\n\t\n\t  \n\t\n\tfor i := 0; i < len(nums); i++ {\n\t\n\t\tif used[i] {\n\t\t\n\t\t\tcontinue\n\t\t\n\t\t}\n\t\t\n\t\t  \n\t\t\n\t\t// 上一个元素如果和当前元素相同且没使用过，则跳过当前元素，防止重复\n\t\t\n\t\tif i > 0 && nums[i] == nums[i-1] && !used[i-1] {\n\t\t\n\t\t\tcontinue\n\t\t\n\t\t}\n\t\t\n\t\t  \n\t\t\n\t\tarr = append(arr, nums[i])\n\t\t\n\t\tused[i] = true\n\t\t\n\t\tdfs(nums, used, arr)\n\t\t\n\t\tused[i] = false\n\t\t\n\t\tarr = arr[:len(arr)-1]\n\t\n\t}\n\n}\n```\n","slug":"leetcode/47.全排列2","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfp001p0k4l61r775p5","content":"<p><a href=\"https://leetcode.cn/problems/permutations-ii/\">leetcode</a></p>\n<p>深度优先搜索</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">var</span> ans [][]<span class=\"hljs-type\">int</span><br><br>  <br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">permuteUnique</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br><br>\tsort.Ints(nums)<br>\t<br>\tused := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, <span class=\"hljs-built_in\">len</span>(nums))<br>\t<br>\tarr := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<br>\tans = [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<br>\t  <br>\t<br>\tdfs(nums, used, arr)<br>\t<br>\t<span class=\"hljs-keyword\">return</span> ans<br><br>&#125;<br><br>  <br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, used []<span class=\"hljs-type\">bool</span>, arr []<span class=\"hljs-type\">int</span>)</span></span> &#123;<br><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(arr) == <span class=\"hljs-built_in\">len</span>(nums) &#123;<br>\t<br>\t\tans = <span class=\"hljs-built_in\">append</span>(ans, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, arr...))<br>\t\t<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t<br>\t\t<span class=\"hljs-keyword\">if</span> used[i] &#123;<br>\t\t<br>\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t<br>\t\t&#125;<br>\t\t<br>\t\t  <br>\t\t<br>\t\t<span class=\"hljs-comment\">// 上一个元素如果和当前元素相同且没使用过，则跳过当前元素，防止重复</span><br>\t\t<br>\t\t<span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] == nums[i<span class=\"hljs-number\">-1</span>] &amp;&amp; !used[i<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t<br>\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t<br>\t\t&#125;<br>\t\t<br>\t\t  <br>\t\t<br>\t\tarr = <span class=\"hljs-built_in\">append</span>(arr, nums[i])<br>\t\t<br>\t\tused[i] = <span class=\"hljs-literal\">true</span><br>\t\t<br>\t\tdfs(nums, used, arr)<br>\t\t<br>\t\tused[i] = <span class=\"hljs-literal\">false</span><br>\t\t<br>\t\tarr = arr[:<span class=\"hljs-built_in\">len</span>(arr)<span class=\"hljs-number\">-1</span>]<br>\t<br>\t&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":718,"excerpt":"<p><a href=\"https://leetcode.cn/problems/permutations-ii/\">leetcode</a></p>\n<p>深度优先搜索</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">var</span> ans [][]<span class=\"hljs-type\">int</span><br><br>  <br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">permuteUnique</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br><br>\tsort.Ints(nums)<br>\t<br>\tused := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, <span class=\"hljs-built_in\">len</span>(nums))<br>\t<br>\tarr := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<br>\tans = [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<br>\t  <br>\t<br>\tdfs(nums, used, arr)<br>\t<br>\t<span class=\"hljs-keyword\">return</span> ans<br><br>&#125;<br><br>  <br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, used []<span class=\"hljs-type\">bool</span>, arr []<span class=\"hljs-type\">int</span>)</span></span> &#123;<br><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(arr) == <span class=\"hljs-built_in\">len</span>(nums) &#123;<br>\t<br>\t\tans = <span class=\"hljs-built_in\">append</span>(ans, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, arr...))<br>\t\t<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t\t<br>\t&#125;<br>\t<br>\t  <br>\t<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t<br>\t\t<span class=\"hljs-keyword\">if</span> used[i] &#123;<br>\t\t<br>\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t<br>\t\t&#125;<br>\t\t<br>\t\t  <br>\t\t<br>\t\t<span class=\"hljs-comment\">// 上一个元素如果和当前元素相同且没使用过，则跳过当前元素，防止重复</span><br>\t\t<br>\t\t<span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] == nums[i<span class=\"hljs-number\">-1</span>] &amp;&amp; !used[i<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t<br>\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t<br>\t\t&#125;<br>\t\t<br>\t\t  <br>\t\t<br>\t\tarr = <span class=\"hljs-built_in\">append</span>(arr, nums[i])<br>\t\t<br>\t\tused[i] = <span class=\"hljs-literal\">true</span><br>\t\t<br>\t\tdfs(nums, used, arr)<br>\t\t<br>\t\tused[i] = <span class=\"hljs-literal\">false</span><br>\t\t<br>\t\tarr = arr[:<span class=\"hljs-built_in\">len</span>(arr)<span class=\"hljs-number\">-1</span>]<br>\t<br>\t&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"450.删除二叉搜索树中的节点","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/delete-node-in-a-bst/)\n\n递归方法\n\n1. 根据二叉搜索树的特性寻找要删除的节点\n2. 如果删除节点就是叶子节点，直接删除\n3. 如果删除节点的左孩子或者有孩子为空，则直接删除当前节点，把非空的孩子节点替换当前节点\n4. 如果删除节点左右孩子都不为空，则寻找大于删除节点的最小节点来替代删除节点，这个节点在删除节点右子树的最左端叶子节点。该节点没有左子树，删除该节点后也比较好处理，且可以保证被删除节点的左子树都小于它，被删除节点的右子树也都大于它。\n5. 特殊情况，若删除节点右子树的最左端叶子节点就是删除节点的右孩子，则只需替换右子树的最左端叶子节点的左孩子为删除节点的左孩子即可。\n\n时间复杂度：O(N)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\n    if root == nil {\n        return nil\n    }\n\n    if root.Val < key {\n        root.Right = deleteNode(root.Right, key)\n    } else if root.Val > key {\n        root.Left = deleteNode(root.Left, key)\n    } else {\n        if root.Left == nil || root.Right == nil {\n            if root.Left == nil {\n                return root.Right\n            } else {\n                return root.Left\n            }\n        } else {\n            tempParent := root\n            temp := root.Right\n\n            // root.Right 就是右子树的最小值\n            if temp.Left == nil {\n                temp.Left = root.Left\n                return temp\n            }\n\n            // 寻找右子树的最小值\n            for temp.Left != nil {\n                tempParent = temp\n                temp = temp.Left\n            }\n\n            temp.Left = root.Left\n            tempParent.Left = temp.Right\n            temp.Right = root.Right\n            return temp\n        }\n    }\n\n    return root\n}\n```\n","source":"_posts/算法/leetcode/450.删除二叉搜索树中的节点.md","raw":"---\ntitle: 450.删除二叉搜索树中的节点\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/delete-node-in-a-bst/)\n\n递归方法\n\n1. 根据二叉搜索树的特性寻找要删除的节点\n2. 如果删除节点就是叶子节点，直接删除\n3. 如果删除节点的左孩子或者有孩子为空，则直接删除当前节点，把非空的孩子节点替换当前节点\n4. 如果删除节点左右孩子都不为空，则寻找大于删除节点的最小节点来替代删除节点，这个节点在删除节点右子树的最左端叶子节点。该节点没有左子树，删除该节点后也比较好处理，且可以保证被删除节点的左子树都小于它，被删除节点的右子树也都大于它。\n5. 特殊情况，若删除节点右子树的最左端叶子节点就是删除节点的右孩子，则只需替换右子树的最左端叶子节点的左孩子为删除节点的左孩子即可。\n\n时间复杂度：O(N)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\n    if root == nil {\n        return nil\n    }\n\n    if root.Val < key {\n        root.Right = deleteNode(root.Right, key)\n    } else if root.Val > key {\n        root.Left = deleteNode(root.Left, key)\n    } else {\n        if root.Left == nil || root.Right == nil {\n            if root.Left == nil {\n                return root.Right\n            } else {\n                return root.Left\n            }\n        } else {\n            tempParent := root\n            temp := root.Right\n\n            // root.Right 就是右子树的最小值\n            if temp.Left == nil {\n                temp.Left = root.Left\n                return temp\n            }\n\n            // 寻找右子树的最小值\n            for temp.Left != nil {\n                tempParent = temp\n                temp = temp.Left\n            }\n\n            temp.Left = root.Left\n            tempParent.Left = temp.Right\n            temp.Right = root.Right\n            return temp\n        }\n    }\n\n    return root\n}\n```\n","slug":"leetcode/450.删除二叉搜索树中的节点","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfq001r0k4lakbs9j3f","content":"<p><a href=\"https://leetcode.cn/problems/delete-node-in-a-bst/\">leetcode</a></p>\n<p>递归方法</p>\n<ol>\n<li>根据二叉搜索树的特性寻找要删除的节点</li>\n<li>如果删除节点就是叶子节点，直接删除</li>\n<li>如果删除节点的左孩子或者有孩子为空，则直接删除当前节点，把非空的孩子节点替换当前节点</li>\n<li>如果删除节点左右孩子都不为空，则寻找大于删除节点的最小节点来替代删除节点，这个节点在删除节点右子树的最左端叶子节点。该节点没有左子树，删除该节点后也比较好处理，且可以保证被删除节点的左子树都小于它，被删除节点的右子树也都大于它。</li>\n<li>特殊情况，若删除节点右子树的最左端叶子节点就是删除节点的右孩子，则只需替换右子树的最左端叶子节点的左孩子为删除节点的左孩子即可。</li>\n</ol>\n<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">deleteNode</span><span class=\"hljs-params\">(root *TreeNode, key <span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>    <span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> root.Val &lt; key &#123;<br>        root.Right = deleteNode(root.Right, key)<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> root.Val &gt; key &#123;<br>        root.Left = deleteNode(root.Left, key)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> || root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> root.Right<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> root.Left<br>            &#125;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            tempParent := root<br>            temp := root.Right<br><br>            <span class=\"hljs-comment\">// root.Right 就是右子树的最小值</span><br>            <span class=\"hljs-keyword\">if</span> temp.Left == <span class=\"hljs-literal\">nil</span> &#123;<br>                temp.Left = root.Left<br>                <span class=\"hljs-keyword\">return</span> temp<br>            &#125;<br><br>            <span class=\"hljs-comment\">// 寻找右子树的最小值</span><br>            <span class=\"hljs-keyword\">for</span> temp.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>                tempParent = temp<br>                temp = temp.Left<br>            &#125;<br><br>            temp.Left = root.Left<br>            tempParent.Left = temp.Right<br>            temp.Right = root.Right<br>            <span class=\"hljs-keyword\">return</span> temp<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1000,"excerpt":"<p><a href=\"https://leetcode.cn/problems/delete-node-in-a-bst/\">leetcode</a></p>\n<p>递归方法</p>\n<ol>\n<li>根据二叉搜索树的特性寻找要删除的节点</li>\n<li>如果删除节点就是叶子节点，直接删除</li>\n<li>如果删除节点的左孩子或者有孩子为空，则直接删除当前节点，把非空的孩子节点替换当前节点</li>\n<li>如果删除节点左右孩子都不为空，则寻找大于删除节点的最小节点来替代删除节点，这个节点在删除节点右子树的最左端叶子节点。该节点没有左子树，删除该节点后也比较好处理，且可以保证被删除节点的左子树都小于它，被删除节点的右子树也都大于它。</li>\n<li>特殊情况，若删除节点右子树的最左端叶子节点就是删除节点的右孩子，则只需替换右子树的最左端叶子节点的左孩子为删除节点的左孩子即可。</li>\n</ol>\n<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">deleteNode</span><span class=\"hljs-params\">(root *TreeNode, key <span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>    <span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> root.Val &lt; key &#123;<br>        root.Right = deleteNode(root.Right, key)<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> root.Val &gt; key &#123;<br>        root.Left = deleteNode(root.Left, key)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> || root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> root.Right<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> root.Left<br>            &#125;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            tempParent := root<br>            temp := root.Right<br><br>            <span class=\"hljs-comment\">// root.Right 就是右子树的最小值</span><br>            <span class=\"hljs-keyword\">if</span> temp.Left == <span class=\"hljs-literal\">nil</span> &#123;<br>                temp.Left = root.Left<br>                <span class=\"hljs-keyword\">return</span> temp<br>            &#125;<br><br>            <span class=\"hljs-comment\">// 寻找右子树的最小值</span><br>            <span class=\"hljs-keyword\">for</span> temp.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>                tempParent = temp<br>                temp = temp.Left<br>            &#125;<br><br>            temp.Left = root.Left<br>            tempParent.Left = temp.Right<br>            temp.Right = root.Right<br>            <span class=\"hljs-keyword\">return</span> temp<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"50.x的n次幂","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/powx-n/submissions/)\n\n递归\n时间复杂度 O(log n)\n空间复杂度O(log n)\n<!-- more -->\n```Go\nfunc myPow(x float64, n int) float64 {\n\n    var helper func(float64, int) float64\n    helper = func(x float64, n int) float64 {\n        if n == 0 {\n            return 1\n        }\n\n        temp := helper(x, n / 2)\n\n        if n % 2 == 0 {\n            temp = temp * temp\n        } else {\n            temp = temp * temp * x\n        }\n\n        return temp\n    }\n\n    if n < 0 {\n        return 1 / helper(x, n)\n    }\n    \n    return helper(x, n)    \n}\n```\n","source":"_posts/算法/leetcode/50.x的n次幂.md","raw":"---\ntitle: 50.x的n次幂\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/powx-n/submissions/)\n\n递归\n时间复杂度 O(log n)\n空间复杂度O(log n)\n<!-- more -->\n```Go\nfunc myPow(x float64, n int) float64 {\n\n    var helper func(float64, int) float64\n    helper = func(x float64, n int) float64 {\n        if n == 0 {\n            return 1\n        }\n\n        temp := helper(x, n / 2)\n\n        if n % 2 == 0 {\n            temp = temp * temp\n        } else {\n            temp = temp * temp * x\n        }\n\n        return temp\n    }\n\n    if n < 0 {\n        return 1 / helper(x, n)\n    }\n    \n    return helper(x, n)    \n}\n```\n","slug":"leetcode/50.x的n次幂","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfq001t0k4lgvw6cc61","content":"<p><a href=\"https://leetcode.cn/problems/powx-n/submissions/\">leetcode</a></p>\n<p>递归<br>时间复杂度 O(log n)<br>空间复杂度O(log n)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">myPow</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">float64</span>, n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">float64</span> &#123;<br><br>    <span class=\"hljs-keyword\">var</span> helper <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float64</span>, <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">float64</span><br>    helper = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">float64</span>, n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">float64</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">0</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>        &#125;<br><br>        temp := helper(x, n / <span class=\"hljs-number\">2</span>)<br><br>        <span class=\"hljs-keyword\">if</span> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span> &#123;<br>            temp = temp * temp<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            temp = temp * temp * x<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> temp<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> n &lt; <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> / helper(x, n)<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> helper(x, n)    <br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":372,"excerpt":"<p><a href=\"https://leetcode.cn/problems/powx-n/submissions/\">leetcode</a></p>\n<p>递归<br>时间复杂度 O(log n)<br>空间复杂度O(log n)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">myPow</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">float64</span>, n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">float64</span> &#123;<br><br>    <span class=\"hljs-keyword\">var</span> helper <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float64</span>, <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">float64</span><br>    helper = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">float64</span>, n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">float64</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">0</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>        &#125;<br><br>        temp := helper(x, n / <span class=\"hljs-number\">2</span>)<br><br>        <span class=\"hljs-keyword\">if</span> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span> &#123;<br>            temp = temp * temp<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            temp = temp * temp * x<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> temp<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> n &lt; <span class=\"hljs-number\">0</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> / helper(x, n)<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> helper(x, n)    <br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"516.最大回文子序列","category_bar":true,"date":"2021-09-29T16:00:00.000Z","_content":"\n动态规划\n\n`dp[i][j]` 用来记录从i到j位置的字符串的最大回文子序列长度。\n\n`dp[i][i]` 都为1。\n\n状态转移时考虑最左和最右元素是否相等，相等则转移至 `dp[i+1][j-1]` ，否则考虑 `dp[i+1][j]` 和 `dp[i][j-1]` 的较大者 。\n\n注意遍历时，i从右边开始，可以保证每个子问题都计算过了。\n\n时间复杂度：O(N^2)\n空间复杂度：O(N^2)\n\n<!-- more -->\n```Go\nfunc longestPalindromeSubseq(s string) int {\n\t// s[i] != s[j]\n\t// dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n\t// s[i] == s[j]\n\t// dp[i][j] = dp[i+1][j-1] + 2\n\n\tdp := make([][]int, len(s))\n\tfor i := 0; i < len(s); i++ {\n\t\tdp[i] = make([]int, len(s))\n\t\tdp[i][i] = 1\n\t}\n\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tfor j := i + 1; j < len(s); j++ {\n\t\t\tif s[i] == s[j] {\n\t\t\t\tdp[i][j] = dp[i+1][j-1] + 2\n\t\t\t} else {\n\t\t\t\tdp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\t\t\t}\n\t\t\t// fmt.Printf(\"dp[%v][%v], %v\\n\", i, j, dp[i][j])\n\t\t}\n\t}\n\n\treturn dp[0][len(s)-1]\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n","source":"_posts/算法/leetcode/516.最大回文子序列.md","raw":"---\ntitle: 516.最大回文子序列\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-30 00:00:00\ntags:\n---\n\n动态规划\n\n`dp[i][j]` 用来记录从i到j位置的字符串的最大回文子序列长度。\n\n`dp[i][i]` 都为1。\n\n状态转移时考虑最左和最右元素是否相等，相等则转移至 `dp[i+1][j-1]` ，否则考虑 `dp[i+1][j]` 和 `dp[i][j-1]` 的较大者 。\n\n注意遍历时，i从右边开始，可以保证每个子问题都计算过了。\n\n时间复杂度：O(N^2)\n空间复杂度：O(N^2)\n\n<!-- more -->\n```Go\nfunc longestPalindromeSubseq(s string) int {\n\t// s[i] != s[j]\n\t// dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n\t// s[i] == s[j]\n\t// dp[i][j] = dp[i+1][j-1] + 2\n\n\tdp := make([][]int, len(s))\n\tfor i := 0; i < len(s); i++ {\n\t\tdp[i] = make([]int, len(s))\n\t\tdp[i][i] = 1\n\t}\n\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tfor j := i + 1; j < len(s); j++ {\n\t\t\tif s[i] == s[j] {\n\t\t\t\tdp[i][j] = dp[i+1][j-1] + 2\n\t\t\t} else {\n\t\t\t\tdp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\t\t\t}\n\t\t\t// fmt.Printf(\"dp[%v][%v], %v\\n\", i, j, dp[i][j])\n\t\t}\n\t}\n\n\treturn dp[0][len(s)-1]\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n","slug":"leetcode/516.最大回文子序列","published":1,"category":"算法","updated":"2022-11-01T02:38:20.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfr001v0k4l22dc9ain","content":"<p>动态规划</p>\n<p><code>dp[i][j]</code> 用来记录从i到j位置的字符串的最大回文子序列长度。</p>\n<p><code>dp[i][i]</code> 都为1。</p>\n<p>状态转移时考虑最左和最右元素是否相等，相等则转移至 <code>dp[i+1][j-1]</code> ，否则考虑 <code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code> 的较大者 。</p>\n<p>注意遍历时，i从右边开始，可以保证每个子问题都计算过了。</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(N^2)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">longestPalindromeSubseq</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// s[i] != s[j]</span><br>\t<span class=\"hljs-comment\">// dp[i][j] = max(dp[i][j-1], dp[i+1][j])</span><br>\t<span class=\"hljs-comment\">// s[i] == s[j]</span><br>\t<span class=\"hljs-comment\">// dp[i][j] = dp[i+1][j-1] + 2</span><br><br>\tdp := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(s))<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\tdp[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(s))<br>\t\tdp[i][i] = <span class=\"hljs-number\">1</span><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-built_in\">len</span>(s) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; <span class=\"hljs-built_in\">len</span>(s); j++ &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> s[i] == s[j] &#123;<br>\t\t\t\tdp[i][j] = dp[i+<span class=\"hljs-number\">1</span>][j<span class=\"hljs-number\">-1</span>] + <span class=\"hljs-number\">2</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tdp[i][j] = max(dp[i+<span class=\"hljs-number\">1</span>][j], dp[i][j<span class=\"hljs-number\">-1</span>])<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// fmt.Printf(&quot;dp[%v][%v], %v\\n&quot;, i, j, dp[i][j])</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-built_in\">len</span>(s)<span class=\"hljs-number\">-1</span>]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":766,"excerpt":"<p>动态规划</p>\n<p><code>dp[i][j]</code> 用来记录从i到j位置的字符串的最大回文子序列长度。</p>\n<p><code>dp[i][i]</code> 都为1。</p>\n<p>状态转移时考虑最左和最右元素是否相等，相等则转移至 <code>dp[i+1][j-1]</code> ，否则考虑 <code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code> 的较大者 。</p>\n<p>注意遍历时，i从右边开始，可以保证每个子问题都计算过了。</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(N^2)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">longestPalindromeSubseq</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// s[i] != s[j]</span><br>\t<span class=\"hljs-comment\">// dp[i][j] = max(dp[i][j-1], dp[i+1][j])</span><br>\t<span class=\"hljs-comment\">// s[i] == s[j]</span><br>\t<span class=\"hljs-comment\">// dp[i][j] = dp[i+1][j-1] + 2</span><br><br>\tdp := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(s))<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\tdp[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(s))<br>\t\tdp[i][i] = <span class=\"hljs-number\">1</span><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-built_in\">len</span>(s) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; <span class=\"hljs-built_in\">len</span>(s); j++ &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> s[i] == s[j] &#123;<br>\t\t\t\tdp[i][j] = dp[i+<span class=\"hljs-number\">1</span>][j<span class=\"hljs-number\">-1</span>] + <span class=\"hljs-number\">2</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tdp[i][j] = max(dp[i+<span class=\"hljs-number\">1</span>][j], dp[i][j<span class=\"hljs-number\">-1</span>])<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// fmt.Printf(&quot;dp[%v][%v], %v\\n&quot;, i, j, dp[i][j])</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-built_in\">len</span>(s)<span class=\"hljs-number\">-1</span>]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"51.N皇后问题","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode-cn.com/problems/n-queens/)\n\n\n回溯法解题。\n\n1. 考虑给每行设置皇后在哪一列，所以维护一个列数组表示哪些列有皇后了，则这些列不能再分配皇后。\n2. 皇后所在的斜线上也不能有皇后，斜线规律为行数和列数之差相等以及行数和列数之和相等，故维护一个行数列数之差的map以及行数列数之和的map。\n3. 递归遍历每行的列，看是否能够在该行该列防止皇后。\n4. 每层递归结束记得还原现场，即修改列数组和斜线map。\n<!-- more -->\n```Go\nfunc solveNQueens(n int) [][]string {\n    columns := make([]bool, n)\n    crossL := make(map[int]bool)\n    crossR := make(map[int]bool)\n\n    results := [][]int{}\n\n    var backtrack func([]int, int)\n\n    backtrack = func(queens []int, row int){\n        if (row >= n) {\n\t        // 注意二维数组的slice赋值最好新建对象\n            results = append(results, append([]int{}, queens...))\n            // fmt.Printf(\"results: %v\\n\", results)\n            return\n        }\n        for col := 0; col < n; col++ {\n            // fmt.Printf(\"row: %v col: %v\\n\", row, col)\n            if c, ok := crossL[row - col]; ok && c {\n                continue\n            }\n\n            if c, ok := crossR[row + col]; ok && c {\n                continue\n            }\n\n            if !columns[col]  {\n                columns[col] = true\n                crossL[row - col] = true\n                crossR[row + col] = true\n                queens := append(queens, col)\n                // fmt.Printf(\"queens: %v\\n\", queens)\n                backtrack(queens, row + 1)\n                // 还原现场\n                columns[col] = false\n                crossL[row - col] = false\n                crossR[row + col] = false\n            }\n        }\n    }\n\n    backtrack([]int{}, 0)\n    \n    ans := [][]string{}\n\n    for _, result := range results {\n        a := make([]string, n)\n        for row := 0; row < n; row++ {\n            for col := 0; col < n; col++ {\n                if col == result[row] {\n                    a[row] = a[row] + \"Q\"\n                } else {\n                    a[row] = a[row] + \".\"\n                }\n            }\n        }\n        ans = append(ans, a)\n    }\n\n    return ans\n}\n\n<!-- more -->\n```\n","source":"_posts/算法/leetcode/51.N皇后问题.md","raw":"---\ntitle: 51.N皇后问题\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode-cn.com/problems/n-queens/)\n\n\n回溯法解题。\n\n1. 考虑给每行设置皇后在哪一列，所以维护一个列数组表示哪些列有皇后了，则这些列不能再分配皇后。\n2. 皇后所在的斜线上也不能有皇后，斜线规律为行数和列数之差相等以及行数和列数之和相等，故维护一个行数列数之差的map以及行数列数之和的map。\n3. 递归遍历每行的列，看是否能够在该行该列防止皇后。\n4. 每层递归结束记得还原现场，即修改列数组和斜线map。\n<!-- more -->\n```Go\nfunc solveNQueens(n int) [][]string {\n    columns := make([]bool, n)\n    crossL := make(map[int]bool)\n    crossR := make(map[int]bool)\n\n    results := [][]int{}\n\n    var backtrack func([]int, int)\n\n    backtrack = func(queens []int, row int){\n        if (row >= n) {\n\t        // 注意二维数组的slice赋值最好新建对象\n            results = append(results, append([]int{}, queens...))\n            // fmt.Printf(\"results: %v\\n\", results)\n            return\n        }\n        for col := 0; col < n; col++ {\n            // fmt.Printf(\"row: %v col: %v\\n\", row, col)\n            if c, ok := crossL[row - col]; ok && c {\n                continue\n            }\n\n            if c, ok := crossR[row + col]; ok && c {\n                continue\n            }\n\n            if !columns[col]  {\n                columns[col] = true\n                crossL[row - col] = true\n                crossR[row + col] = true\n                queens := append(queens, col)\n                // fmt.Printf(\"queens: %v\\n\", queens)\n                backtrack(queens, row + 1)\n                // 还原现场\n                columns[col] = false\n                crossL[row - col] = false\n                crossR[row + col] = false\n            }\n        }\n    }\n\n    backtrack([]int{}, 0)\n    \n    ans := [][]string{}\n\n    for _, result := range results {\n        a := make([]string, n)\n        for row := 0; row < n; row++ {\n            for col := 0; col < n; col++ {\n                if col == result[row] {\n                    a[row] = a[row] + \"Q\"\n                } else {\n                    a[row] = a[row] + \".\"\n                }\n            }\n        }\n        ans = append(ans, a)\n    }\n\n    return ans\n}\n\n<!-- more -->\n```\n","slug":"leetcode/51.N皇后问题","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfr001x0k4l02p11p5p","content":"<p><a href=\"https://leetcode-cn.com/problems/n-queens/\">leetcode</a></p>\n<p>回溯法解题。</p>\n<ol>\n<li>考虑给每行设置皇后在哪一列，所以维护一个列数组表示哪些列有皇后了，则这些列不能再分配皇后。</li>\n<li>皇后所在的斜线上也不能有皇后，斜线规律为行数和列数之差相等以及行数和列数之和相等，故维护一个行数列数之差的map以及行数列数之和的map。</li>\n<li>递归遍历每行的列，看是否能够在该行该列防止皇后。</li>\n<li>每层递归结束记得还原现场，即修改列数组和斜线map。<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">solveNQueens</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">string</span> &#123;<br>    columns := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, n)<br>    crossL := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">bool</span>)<br>    crossR := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">bool</span>)<br><br>    results := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">var</span> backtrack <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span><br><br>    backtrack = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(queens []<span class=\"hljs-type\">int</span>, row <span class=\"hljs-type\">int</span>)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (row &gt;= n) &#123;<br>\t        <span class=\"hljs-comment\">// 注意二维数组的slice赋值最好新建对象</span><br>            results = <span class=\"hljs-built_in\">append</span>(results, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, queens...))<br>            <span class=\"hljs-comment\">// fmt.Printf(&quot;results: %v\\n&quot;, results)</span><br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> col := <span class=\"hljs-number\">0</span>; col &lt; n; col++ &#123;<br>            <span class=\"hljs-comment\">// fmt.Printf(&quot;row: %v col: %v\\n&quot;, row, col)</span><br>            <span class=\"hljs-keyword\">if</span> c, ok := crossL[row - col]; ok &amp;&amp; c &#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">if</span> c, ok := crossR[row + col]; ok &amp;&amp; c &#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">if</span> !columns[col]  &#123;<br>                columns[col] = <span class=\"hljs-literal\">true</span><br>                crossL[row - col] = <span class=\"hljs-literal\">true</span><br>                crossR[row + col] = <span class=\"hljs-literal\">true</span><br>                queens := <span class=\"hljs-built_in\">append</span>(queens, col)<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;queens: %v\\n&quot;, queens)</span><br>                backtrack(queens, row + <span class=\"hljs-number\">1</span>)<br>                <span class=\"hljs-comment\">// 还原现场</span><br>                columns[col] = <span class=\"hljs-literal\">false</span><br>                crossL[row - col] = <span class=\"hljs-literal\">false</span><br>                crossR[row + col] = <span class=\"hljs-literal\">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    backtrack([]<span class=\"hljs-type\">int</span>&#123;&#125;, <span class=\"hljs-number\">0</span>)<br>    <br>    ans := [][]<span class=\"hljs-type\">string</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">for</span> _, result := <span class=\"hljs-keyword\">range</span> results &#123;<br>        a := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">string</span>, n)<br>        <span class=\"hljs-keyword\">for</span> row := <span class=\"hljs-number\">0</span>; row &lt; n; row++ &#123;<br>            <span class=\"hljs-keyword\">for</span> col := <span class=\"hljs-number\">0</span>; col &lt; n; col++ &#123;<br>                <span class=\"hljs-keyword\">if</span> col == result[row] &#123;<br>                    a[row] = a[row] + <span class=\"hljs-string\">&quot;Q&quot;</span><br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    a[row] = a[row] + <span class=\"hljs-string\">&quot;.&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, a)<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br>&lt;!-- more --&gt;<br></code></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":1442,"excerpt":"<p><a href=\"https://leetcode-cn.com/problems/n-queens/\">leetcode</a></p>\n<p>回溯法解题。</p>\n<ol>\n<li>考虑给每行设置皇后在哪一列，所以维护一个列数组表示哪些列有皇后了，则这些列不能再分配皇后。</li>\n<li>皇后所在的斜线上也不能有皇后，斜线规律为行数和列数之差相等以及行数和列数之和相等，故维护一个行数列数之差的map以及行数列数之和的map。</li>\n<li>递归遍历每行的列，看是否能够在该行该列防止皇后。</li>\n<li>每层递归结束记得还原现场，即修改列数组和斜线map。","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">solveNQueens</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">string</span> &#123;<br>    columns := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, n)<br>    crossL := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">bool</span>)<br>    crossR := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">bool</span>)<br><br>    results := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">var</span> backtrack <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span><br><br>    backtrack = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(queens []<span class=\"hljs-type\">int</span>, row <span class=\"hljs-type\">int</span>)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (row &gt;= n) &#123;<br>\t        <span class=\"hljs-comment\">// 注意二维数组的slice赋值最好新建对象</span><br>            results = <span class=\"hljs-built_in\">append</span>(results, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, queens...))<br>            <span class=\"hljs-comment\">// fmt.Printf(&quot;results: %v\\n&quot;, results)</span><br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> col := <span class=\"hljs-number\">0</span>; col &lt; n; col++ &#123;<br>            <span class=\"hljs-comment\">// fmt.Printf(&quot;row: %v col: %v\\n&quot;, row, col)</span><br>            <span class=\"hljs-keyword\">if</span> c, ok := crossL[row - col]; ok &amp;&amp; c &#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">if</span> c, ok := crossR[row + col]; ok &amp;&amp; c &#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">if</span> !columns[col]  &#123;<br>                columns[col] = <span class=\"hljs-literal\">true</span><br>                crossL[row - col] = <span class=\"hljs-literal\">true</span><br>                crossR[row + col] = <span class=\"hljs-literal\">true</span><br>                queens := <span class=\"hljs-built_in\">append</span>(queens, col)<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;queens: %v\\n&quot;, queens)</span><br>                backtrack(queens, row + <span class=\"hljs-number\">1</span>)<br>                <span class=\"hljs-comment\">// 还原现场</span><br>                columns[col] = <span class=\"hljs-literal\">false</span><br>                crossL[row - col] = <span class=\"hljs-literal\">false</span><br>                crossR[row + col] = <span class=\"hljs-literal\">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    backtrack([]<span class=\"hljs-type\">int</span>&#123;&#125;, <span class=\"hljs-number\">0</span>)<br>    <br>    ans := [][]<span class=\"hljs-type\">string</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">for</span> _, result := <span class=\"hljs-keyword\">range</span> results &#123;<br>        a := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">string</span>, n)<br>        <span class=\"hljs-keyword\">for</span> row := <span class=\"hljs-number\">0</span>; row &lt; n; row++ &#123;<br>            <span class=\"hljs-keyword\">for</span> col := <span class=\"hljs-number\">0</span>; col &lt; n; col++ &#123;<br>                <span class=\"hljs-keyword\">if</span> col == result[row] &#123;<br>                    a[row] = a[row] + <span class=\"hljs-string\">&quot;Q&quot;</span><br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    a[row] = a[row] + <span class=\"hljs-string\">&quot;.&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, a)<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br><br>&lt;!-- more --&gt;<br></code></pre></td></tr></table></figure></li>\n</ol>"},{"title":"56.合并区间","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n排序，然后逐一合并\n\n时间复杂度： O(NlogN)\n空间复杂的： O(logN)\n<!-- more -->\n```Go\nfunc merge(intervals [][]int) [][]int {\n    sort.Slice(intervals, func(i, j int) bool {\n        if intervals[i][0] == intervals[j][0] {\n            return intervals[i][1] < intervals[j][1]\n        } else {\n            return intervals[i][0] < intervals[j][0]\n        }\n    })\n\n    ans := [][]int{}\n    \n    l, r := intervals[0][0], intervals[0][1]\n\n    for i := 1; i < len(intervals); i++ {\n        if intervals[i][0] <= r {\n            if (intervals[i][1] > r) {\n                r = intervals[i][1]\n            }\n            continue\n        }\n\n        ans = append(ans, []int{l, r})\n        l = intervals[i][0]\n        r = intervals[i][1]\n    }\n\n    ans = append(ans, []int{l, r})\n    \n    return ans\n}\n```\n","source":"_posts/算法/leetcode/56.合并区间.md","raw":"---\ntitle: 56.合并区间\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n排序，然后逐一合并\n\n时间复杂度： O(NlogN)\n空间复杂的： O(logN)\n<!-- more -->\n```Go\nfunc merge(intervals [][]int) [][]int {\n    sort.Slice(intervals, func(i, j int) bool {\n        if intervals[i][0] == intervals[j][0] {\n            return intervals[i][1] < intervals[j][1]\n        } else {\n            return intervals[i][0] < intervals[j][0]\n        }\n    })\n\n    ans := [][]int{}\n    \n    l, r := intervals[0][0], intervals[0][1]\n\n    for i := 1; i < len(intervals); i++ {\n        if intervals[i][0] <= r {\n            if (intervals[i][1] > r) {\n                r = intervals[i][1]\n            }\n            continue\n        }\n\n        ans = append(ans, []int{l, r})\n        l = intervals[i][0]\n        r = intervals[i][1]\n    }\n\n    ans = append(ans, []int{l, r})\n    \n    return ans\n}\n```\n","slug":"leetcode/56.合并区间","published":1,"category":"算法","updated":"2022-11-01T02:33:31.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfs001z0k4lhiwzfty3","content":"<p>排序，然后逐一合并</p>\n<p>时间复杂度： O(NlogN)<br>空间复杂的： O(logN)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(intervals [][]<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>    sort.Slice(intervals, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i, j <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> intervals[i][<span class=\"hljs-number\">0</span>] == intervals[j][<span class=\"hljs-number\">0</span>] &#123;<br>            <span class=\"hljs-keyword\">return</span> intervals[i][<span class=\"hljs-number\">1</span>] &lt; intervals[j][<span class=\"hljs-number\">1</span>]<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> intervals[i][<span class=\"hljs-number\">0</span>] &lt; intervals[j][<span class=\"hljs-number\">0</span>]<br>        &#125;<br>    &#125;)<br><br>    ans := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    <br>    l, r := intervals[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>], intervals[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>]<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(intervals); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> intervals[i][<span class=\"hljs-number\">0</span>] &lt;= r &#123;<br>            <span class=\"hljs-keyword\">if</span> (intervals[i][<span class=\"hljs-number\">1</span>] &gt; r) &#123;<br>                r = intervals[i][<span class=\"hljs-number\">1</span>]<br>            &#125;<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        ans = <span class=\"hljs-built_in\">append</span>(ans, []<span class=\"hljs-type\">int</span>&#123;l, r&#125;)<br>        l = intervals[i][<span class=\"hljs-number\">0</span>]<br>        r = intervals[i][<span class=\"hljs-number\">1</span>]<br>    &#125;<br><br>    ans = <span class=\"hljs-built_in\">append</span>(ans, []<span class=\"hljs-type\">int</span>&#123;l, r&#125;)<br>    <br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":639,"excerpt":"<p>排序，然后逐一合并</p>\n<p>时间复杂度： O(NlogN)<br>空间复杂的： O(logN)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(intervals [][]<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>    sort.Slice(intervals, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i, j <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> intervals[i][<span class=\"hljs-number\">0</span>] == intervals[j][<span class=\"hljs-number\">0</span>] &#123;<br>            <span class=\"hljs-keyword\">return</span> intervals[i][<span class=\"hljs-number\">1</span>] &lt; intervals[j][<span class=\"hljs-number\">1</span>]<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> intervals[i][<span class=\"hljs-number\">0</span>] &lt; intervals[j][<span class=\"hljs-number\">0</span>]<br>        &#125;<br>    &#125;)<br><br>    ans := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    <br>    l, r := intervals[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>], intervals[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>]<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(intervals); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> intervals[i][<span class=\"hljs-number\">0</span>] &lt;= r &#123;<br>            <span class=\"hljs-keyword\">if</span> (intervals[i][<span class=\"hljs-number\">1</span>] &gt; r) &#123;<br>                r = intervals[i][<span class=\"hljs-number\">1</span>]<br>            &#125;<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        ans = <span class=\"hljs-built_in\">append</span>(ans, []<span class=\"hljs-type\">int</span>&#123;l, r&#125;)<br>        l = intervals[i][<span class=\"hljs-number\">0</span>]<br>        r = intervals[i][<span class=\"hljs-number\">1</span>]<br>    &#125;<br><br>    ans = <span class=\"hljs-built_in\">append</span>(ans, []<span class=\"hljs-type\">int</span>&#123;l, r&#125;)<br>    <br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"518.零钱兑换 II","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n完全背包\n\n时间复杂度：O(amount x amount x N)\n空间复杂度：O(amount x N)\n<!-- more -->\n```Go\nfunc change(amount int, coins []int) int {\n    dp := make([][]int, len(coins)+1)\n    dp[0] = make([]int, amount+1)\n    dp[0][0] = 1\n\n    for i := 1; i <= len(coins); i++ {\n        dp[i] = make([]int, amount+1)\n        coin := coins[i-1]\n        for j := 0; j <= amount; j++ {\n\t        for k := 0; k*coin <= j; k++ {\n\t\t\t    dp[i][j] += dp[i-1][j-k*coin]     \n\t        }\n        }\n    }\n\n    return dp[len(coins)][amount]\n}\n```\n\n\n\n完全背包一维优化，即动态规划\n\n时间复杂度：O(amount x N)\n空间复杂度：O(amount)\n<!-- more -->\n```Go\nfunc change(amount int, coins []int) int {\n    dp := make([]int, amount+1)\n    dp[0] = 1\n\n    for i := 0; i < len(coins); i++ {\n        coin := coins[i]\n        for j := coin; j <= amount; j++ {\n            dp[j] += dp[j-coin]\n        }\n    }\n\n    return dp[amount]\n}\n```\n","source":"_posts/算法/leetcode/518.零钱兑换 II.md","raw":"---\ntitle: 518.零钱兑换 II\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n完全背包\n\n时间复杂度：O(amount x amount x N)\n空间复杂度：O(amount x N)\n<!-- more -->\n```Go\nfunc change(amount int, coins []int) int {\n    dp := make([][]int, len(coins)+1)\n    dp[0] = make([]int, amount+1)\n    dp[0][0] = 1\n\n    for i := 1; i <= len(coins); i++ {\n        dp[i] = make([]int, amount+1)\n        coin := coins[i-1]\n        for j := 0; j <= amount; j++ {\n\t        for k := 0; k*coin <= j; k++ {\n\t\t\t    dp[i][j] += dp[i-1][j-k*coin]     \n\t        }\n        }\n    }\n\n    return dp[len(coins)][amount]\n}\n```\n\n\n\n完全背包一维优化，即动态规划\n\n时间复杂度：O(amount x N)\n空间复杂度：O(amount)\n<!-- more -->\n```Go\nfunc change(amount int, coins []int) int {\n    dp := make([]int, amount+1)\n    dp[0] = 1\n\n    for i := 0; i < len(coins); i++ {\n        coin := coins[i]\n        for j := coin; j <= amount; j++ {\n            dp[j] += dp[j-coin]\n        }\n    }\n\n    return dp[amount]\n}\n```\n","slug":"leetcode/518.零钱兑换 II","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfs00210k4laipc9htu","content":"<p>完全背包</p>\n<p>时间复杂度：O(amount x amount x N)<br>空间复杂度：O(amount x N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(amount <span class=\"hljs-type\">int</span>, coins []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    dp := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(coins)+<span class=\"hljs-number\">1</span>)<br>    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, amount+<span class=\"hljs-number\">1</span>)<br>    dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-built_in\">len</span>(coins); i++ &#123;<br>        dp[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, amount+<span class=\"hljs-number\">1</span>)<br>        coin := coins[i<span class=\"hljs-number\">-1</span>]<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt;= amount; j++ &#123;<br>\t        <span class=\"hljs-keyword\">for</span> k := <span class=\"hljs-number\">0</span>; k*coin &lt;= j; k++ &#123;<br>\t\t\t    dp[i][j] += dp[i<span class=\"hljs-number\">-1</span>][j-k*coin]     <br>\t        &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> dp[<span class=\"hljs-built_in\">len</span>(coins)][amount]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>完全背包一维优化，即动态规划</p>\n<p>时间复杂度：O(amount x N)<br>空间复杂度：O(amount)</p>\n<!-- more -->\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(amount <span class=\"hljs-type\">int</span>, coins []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, amount+<span class=\"hljs-number\">1</span>)<br>    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(coins); i++ &#123;<br>        coin := coins[i]<br>        <span class=\"hljs-keyword\">for</span> j := coin; j &lt;= amount; j++ &#123;<br>            dp[j] += dp[j-coin]<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":658,"excerpt":"<p>完全背包</p>\n<p>时间复杂度：O(amount x amount x N)<br>空间复杂度：O(amount x N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(amount <span class=\"hljs-type\">int</span>, coins []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    dp := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(coins)+<span class=\"hljs-number\">1</span>)<br>    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, amount+<span class=\"hljs-number\">1</span>)<br>    dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-built_in\">len</span>(coins); i++ &#123;<br>        dp[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, amount+<span class=\"hljs-number\">1</span>)<br>        coin := coins[i<span class=\"hljs-number\">-1</span>]<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt;= amount; j++ &#123;<br>\t        <span class=\"hljs-keyword\">for</span> k := <span class=\"hljs-number\">0</span>; k*coin &lt;= j; k++ &#123;<br>\t\t\t    dp[i][j] += dp[i<span class=\"hljs-number\">-1</span>][j-k*coin]     <br>\t        &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> dp[<span class=\"hljs-built_in\">len</span>(coins)][amount]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>完全背包一维优化，即动态规划</p>\n<p>时间复杂度：O(amount x N)<br>空间复杂度：O(amount)</p>\n<!-- more -->\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(amount <span class=\"hljs-type\">int</span>, coins []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    dp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, amount+<span class=\"hljs-number\">1</span>)<br>    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(coins); i++ &#123;<br>        coin := coins[i]<br>        <span class=\"hljs-keyword\">for</span> j := coin; j &lt;= amount; j++ &#123;<br>            dp[j] += dp[j-coin]<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"560. 和为 K 的子数组","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n前缀和+哈希\n\n滚动计算前缀和，同时查找哈希值中有符合前缀和之差等于k的前缀和的出现次数。\n\n最后累加哈希中前缀和的出现次数。\n\n时间复杂度：O(N)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc subarraySum(nums []int, k int) int {\n    pre, ans := 0, 0\n    m := map[int]int{}\n    m[0] = 1\n\n    for i := 0; i < len(nums); i++ {\n        pre += nums[i]\n\n        if _, ok := m[pre-k]; ok {\n            ans += m[pre-k]\n        }\n        m[pre] += 1\n    }\n\n    return ans\n}\n```\n","source":"_posts/算法/leetcode/560. 和为 K 的子数组.md","raw":"---\ntitle: 560. 和为 K 的子数组\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n前缀和+哈希\n\n滚动计算前缀和，同时查找哈希值中有符合前缀和之差等于k的前缀和的出现次数。\n\n最后累加哈希中前缀和的出现次数。\n\n时间复杂度：O(N)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc subarraySum(nums []int, k int) int {\n    pre, ans := 0, 0\n    m := map[int]int{}\n    m[0] = 1\n\n    for i := 0; i < len(nums); i++ {\n        pre += nums[i]\n\n        if _, ok := m[pre-k]; ok {\n            ans += m[pre-k]\n        }\n        m[pre] += 1\n    }\n\n    return ans\n}\n```\n","slug":"leetcode/560. 和为 K 的子数组","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbft00230k4lg6ebhcbk","content":"<p>前缀和+哈希</p>\n<p>滚动计算前缀和，同时查找哈希值中有符合前缀和之差等于k的前缀和的出现次数。</p>\n<p>最后累加哈希中前缀和的出现次数。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">subarraySum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    pre, ans := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>    m := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    m[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        pre += nums[i]<br><br>        <span class=\"hljs-keyword\">if</span> _, ok := m[pre-k]; ok &#123;<br>            ans += m[pre-k]<br>        &#125;<br>        m[pre] += <span class=\"hljs-number\">1</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":304,"excerpt":"<p>前缀和+哈希</p>\n<p>滚动计算前缀和，同时查找哈希值中有符合前缀和之差等于k的前缀和的出现次数。</p>\n<p>最后累加哈希中前缀和的出现次数。</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">subarraySum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    pre, ans := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span><br>    m := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    m[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        pre += nums[i]<br><br>        <span class=\"hljs-keyword\">if</span> _, ok := m[pre-k]; ok &#123;<br>            ans += m[pre-k]<br>        &#125;<br>        m[pre] += <span class=\"hljs-number\">1</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"547.省份数量","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n深度优先遍历\n\n找到未访问过的城市，深度优先遍历其所有能联通的城市，并标记为已访问。\n\n最后统计有几个联通量。\n\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc findCircleNum(isConnected [][]int) int {\n    ans := 0\n    visited := make([]bool, len(isConnected))\n    var dfs func(int)\n\n    dfs = func(i int) {\n        if visited[i] {\n            return\n        }\n        visited[i] = true\n        for j, connected := range isConnected[i] {\n            if connected == 1 {\n                dfs(j)\n            }\n        }\n    }\n\n    for i := 0; i < len(isConnected); i++ {\n        if !visited[i] {\n            dfs(i)\n            ans++\n        }\n    }\n\n    return ans\n}\n```\n","source":"_posts/算法/leetcode/547.省份数量.md","raw":"---\ntitle: 547.省份数量\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n深度优先遍历\n\n找到未访问过的城市，深度优先遍历其所有能联通的城市，并标记为已访问。\n\n最后统计有几个联通量。\n\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc findCircleNum(isConnected [][]int) int {\n    ans := 0\n    visited := make([]bool, len(isConnected))\n    var dfs func(int)\n\n    dfs = func(i int) {\n        if visited[i] {\n            return\n        }\n        visited[i] = true\n        for j, connected := range isConnected[i] {\n            if connected == 1 {\n                dfs(j)\n            }\n        }\n    }\n\n    for i := 0; i < len(isConnected); i++ {\n        if !visited[i] {\n            dfs(i)\n            ans++\n        }\n    }\n\n    return ans\n}\n```\n","slug":"leetcode/547.省份数量","published":1,"category":"算法","updated":"2022-11-01T02:33:32.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfu00250k4l91ux3ydc","content":"<p>深度优先遍历</p>\n<p>找到未访问过的城市，深度优先遍历其所有能联通的城市，并标记为已访问。</p>\n<p>最后统计有几个联通量。</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findCircleNum</span><span class=\"hljs-params\">(isConnected [][]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    ans := <span class=\"hljs-number\">0</span><br>    visited := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, <span class=\"hljs-built_in\">len</span>(isConnected))<br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        <span class=\"hljs-keyword\">if</span> visited[i] &#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br>        visited[i] = <span class=\"hljs-literal\">true</span><br>        <span class=\"hljs-keyword\">for</span> j, connected := <span class=\"hljs-keyword\">range</span> isConnected[i] &#123;<br>            <span class=\"hljs-keyword\">if</span> connected == <span class=\"hljs-number\">1</span> &#123;<br>                dfs(j)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(isConnected); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> !visited[i] &#123;<br>            dfs(i)<br>            ans++<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":467,"excerpt":"<p>深度优先遍历</p>\n<p>找到未访问过的城市，深度优先遍历其所有能联通的城市，并标记为已访问。</p>\n<p>最后统计有几个联通量。</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findCircleNum</span><span class=\"hljs-params\">(isConnected [][]<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    ans := <span class=\"hljs-number\">0</span><br>    visited := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, <span class=\"hljs-built_in\">len</span>(isConnected))<br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        <span class=\"hljs-keyword\">if</span> visited[i] &#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br>        visited[i] = <span class=\"hljs-literal\">true</span><br>        <span class=\"hljs-keyword\">for</span> j, connected := <span class=\"hljs-keyword\">range</span> isConnected[i] &#123;<br>            <span class=\"hljs-keyword\">if</span> connected == <span class=\"hljs-number\">1</span> &#123;<br>                dfs(j)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(isConnected); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> !visited[i] &#123;<br>            dfs(i)<br>            ans++<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"53.最大子序和","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/maximum-subarray/)\n\n思路：动态规划，前缀和。\n<!-- more -->\n```go\nfunc maxSubArray(nums []int) int {\n\n\tans := nums[0]\n\t\n\tfor i := 1; i < len(nums); i++ {\n\t\t// 当前缀和为正数则累加，否则抛弃\n\t\tif nums[i-1] + nums[i] > nums[i] {\n\t\t\tnums[i] = nums[i-1] + nums[i]\n\t\t}\n\t\n\t\tif nums[i] > ans {\n\t\t\tans = nums[i]\n\t\t}\n\t}\n\t\n\treturn ans\n}\n```\n\n","source":"_posts/算法/leetcode/53.最大子序和.md","raw":"---\ntitle: 53.最大子序和\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/maximum-subarray/)\n\n思路：动态规划，前缀和。\n<!-- more -->\n```go\nfunc maxSubArray(nums []int) int {\n\n\tans := nums[0]\n\t\n\tfor i := 1; i < len(nums); i++ {\n\t\t// 当前缀和为正数则累加，否则抛弃\n\t\tif nums[i-1] + nums[i] > nums[i] {\n\t\t\tnums[i] = nums[i-1] + nums[i]\n\t\t}\n\t\n\t\tif nums[i] > ans {\n\t\t\tans = nums[i]\n\t\t}\n\t}\n\t\n\treturn ans\n}\n```\n\n","slug":"leetcode/53.最大子序和","published":1,"category":"算法","updated":"2022-11-01T02:33:32.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfw00270k4lfags2i8d","content":"<p><a href=\"https://leetcode.cn/problems/maximum-subarray/\">leetcode</a></p>\n<p>思路：动态规划，前缀和。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxSubArray</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br><br>\tans := nums[<span class=\"hljs-number\">0</span>]<br>\t<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\t<span class=\"hljs-comment\">// 当前缀和为正数则累加，否则抛弃</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[i<span class=\"hljs-number\">-1</span>] + nums[i] &gt; nums[i] &#123;<br>\t\t\tnums[i] = nums[i<span class=\"hljs-number\">-1</span>] + nums[i]<br>\t\t&#125;<br>\t<br>\t\t<span class=\"hljs-keyword\">if</span> nums[i] &gt; ans &#123;<br>\t\t\tans = nums[i]<br>\t\t&#125;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":268,"excerpt":"<p><a href=\"https://leetcode.cn/problems/maximum-subarray/\">leetcode</a></p>\n<p>思路：动态规划，前缀和。</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxSubArray</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br><br>\tans := nums[<span class=\"hljs-number\">0</span>]<br>\t<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\t<span class=\"hljs-comment\">// 当前缀和为正数则累加，否则抛弃</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[i<span class=\"hljs-number\">-1</span>] + nums[i] &gt; nums[i] &#123;<br>\t\t\tnums[i] = nums[i<span class=\"hljs-number\">-1</span>] + nums[i]<br>\t\t&#125;<br>\t<br>\t\t<span class=\"hljs-keyword\">if</span> nums[i] &gt; ans &#123;<br>\t\t\tans = nums[i]<br>\t\t&#125;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"673.最长递增子序列的个数","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n动态规划\n\n要注意统计个数的时候，dp相等时要把之前的数量累加上，dp大的时候则是直接继承之前的数量。\n\n时间复杂度： O(N^2)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc findNumberOfLIS(nums []int) int {\n    n := len(nums)\n    dp := make([]int, n)\n    count := make([]int, n)\n    maxLength := 0\n    ans := 0\n\n    for i := 0; i < n; i++ {\n        dp[i] = 1\n        count[i] = 1\n\n        for j := 0; j < i; j++ {\n            if nums[i] > nums[j] {\n                if dp[j] + 1 == dp[i] {\n\t\t            // j位置的所有个数都要加上\n                    count[i] += count[j]\n                }\n                if dp[j] + 1 > dp[i] {\n                    dp[i] = dp[j] + 1\n                    // 针对j位置的每一种最长子序列都有一个对应的新序列\n                    count[i] = count[j]\n                }\n            }\n            \n        }\n\n\t\t// 所有最长的子序和都要考虑\n        if dp[i] == maxLength {\n            ans += count[i]\n        }\n        if dp[i] > maxLength {\n            maxLength = dp[i]\n            ans = count[i]\n        }\n    }\n\n    return ans\n}```\n","source":"_posts/算法/leetcode/673.最长递增子序列的个数.md","raw":"---\ntitle: 673.最长递增子序列的个数\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n动态规划\n\n要注意统计个数的时候，dp相等时要把之前的数量累加上，dp大的时候则是直接继承之前的数量。\n\n时间复杂度： O(N^2)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc findNumberOfLIS(nums []int) int {\n    n := len(nums)\n    dp := make([]int, n)\n    count := make([]int, n)\n    maxLength := 0\n    ans := 0\n\n    for i := 0; i < n; i++ {\n        dp[i] = 1\n        count[i] = 1\n\n        for j := 0; j < i; j++ {\n            if nums[i] > nums[j] {\n                if dp[j] + 1 == dp[i] {\n\t\t            // j位置的所有个数都要加上\n                    count[i] += count[j]\n                }\n                if dp[j] + 1 > dp[i] {\n                    dp[i] = dp[j] + 1\n                    // 针对j位置的每一种最长子序列都有一个对应的新序列\n                    count[i] = count[j]\n                }\n            }\n            \n        }\n\n\t\t// 所有最长的子序和都要考虑\n        if dp[i] == maxLength {\n            ans += count[i]\n        }\n        if dp[i] > maxLength {\n            maxLength = dp[i]\n            ans = count[i]\n        }\n    }\n\n    return ans\n}```\n","slug":"leetcode/673.最长递增子序列的个数","published":1,"category":"算法","updated":"2022-11-01T02:33:31.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfx00290k4l6fj12p73","content":"<p>动态规划</p>\n<p>要注意统计个数的时候，dp相等时要把之前的数量累加上，dp大的时候则是直接继承之前的数量。</p>\n<p>时间复杂度： O(N^2)<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<pre><code class=\"Go\">func findNumberOfLIS(nums []int) int &#123;\n    n := len(nums)\n    dp := make([]int, n)\n    count := make([]int, n)\n    maxLength := 0\n    ans := 0\n\n    for i := 0; i &lt; n; i++ &#123;\n        dp[i] = 1\n        count[i] = 1\n\n        for j := 0; j &lt; i; j++ &#123;\n            if nums[i] &gt; nums[j] &#123;\n                if dp[j] + 1 == dp[i] &#123;\n                    // j位置的所有个数都要加上\n                    count[i] += count[j]\n                &#125;\n                if dp[j] + 1 &gt; dp[i] &#123;\n                    dp[i] = dp[j] + 1\n                    // 针对j位置的每一种最长子序列都有一个对应的新序列\n                    count[i] = count[j]\n                &#125;\n            &#125;\n            \n        &#125;\n\n        // 所有最长的子序和都要考虑\n        if dp[i] == maxLength &#123;\n            ans += count[i]\n        &#125;\n        if dp[i] &gt; maxLength &#123;\n            maxLength = dp[i]\n            ans = count[i]\n        &#125;\n    &#125;\n\n    return ans\n&#125;```\n</code></pre>\n","site":{"data":{}},"wordcount":566,"excerpt":"<p>动态规划</p>\n<p>要注意统计个数的时候，dp相等时要把之前的数量累加上，dp大的时候则是直接继承之前的数量。</p>\n<p>时间复杂度： O(N^2)<br>空间复杂度：O(N)</p>","more":"<pre><code class=\"Go\">func findNumberOfLIS(nums []int) int &#123;\n    n := len(nums)\n    dp := make([]int, n)\n    count := make([]int, n)\n    maxLength := 0\n    ans := 0\n\n    for i := 0; i &lt; n; i++ &#123;\n        dp[i] = 1\n        count[i] = 1\n\n        for j := 0; j &lt; i; j++ &#123;\n            if nums[i] &gt; nums[j] &#123;\n                if dp[j] + 1 == dp[i] &#123;\n                    // j位置的所有个数都要加上\n                    count[i] += count[j]\n                &#125;\n                if dp[j] + 1 &gt; dp[i] &#123;\n                    dp[i] = dp[j] + 1\n                    // 针对j位置的每一种最长子序列都有一个对应的新序列\n                    count[i] = count[j]\n                &#125;\n            &#125;\n            \n        &#125;\n\n        // 所有最长的子序和都要考虑\n        if dp[i] == maxLength &#123;\n            ans += count[i]\n        &#125;\n        if dp[i] &gt; maxLength &#123;\n            maxLength = dp[i]\n            ans = count[i]\n        &#125;\n    &#125;\n\n    return ans\n&#125;```\n</code></pre>"},{"title":"684.冗余链接","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/redundant-connection/)\n\n使用并查集方法，维护联通分量数组，检验每条边的两个节点，如果已经联通了，则当前边导致成环，为冗余链接。\n\n时间复杂度：\n空间复杂度：O(n)\n<!-- more -->\n```Go\nfunc findRedundantConnection(edges [][]int) []int {\n    group := make([]int, len(edges) + 1)\n    for i := 0; i < len(edges) + 1; i++ {\n       group[i] = i\n    }\n\n    var find func(i int) int\n\n    // 查找真正的联通分量\n    find = func(i int) int {\n        if group[i] == i {\n            return i\n        }\n\n        return find(group[i])\n    }\n\n    // 合并两个联通分量，返回这个两个联通分量是否本来就联通了\n    union := func(from int, to int) bool {\n        from = find(from)\n        to = find(to)\n\n        if from == to {\n            return true\n        }\n\n        group[to] = from\n        return false\n    }\n\n    for _, edge := range edges {\n        // 联通分量事先已经联通则表示有环\n        if union(edge[0], edge[1]) {\n            return edge\n        }\n    }\n\n    return []int{}\n}\n```\n","source":"_posts/算法/leetcode/684.冗余链接.md","raw":"---\ntitle: 684.冗余链接\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/redundant-connection/)\n\n使用并查集方法，维护联通分量数组，检验每条边的两个节点，如果已经联通了，则当前边导致成环，为冗余链接。\n\n时间复杂度：\n空间复杂度：O(n)\n<!-- more -->\n```Go\nfunc findRedundantConnection(edges [][]int) []int {\n    group := make([]int, len(edges) + 1)\n    for i := 0; i < len(edges) + 1; i++ {\n       group[i] = i\n    }\n\n    var find func(i int) int\n\n    // 查找真正的联通分量\n    find = func(i int) int {\n        if group[i] == i {\n            return i\n        }\n\n        return find(group[i])\n    }\n\n    // 合并两个联通分量，返回这个两个联通分量是否本来就联通了\n    union := func(from int, to int) bool {\n        from = find(from)\n        to = find(to)\n\n        if from == to {\n            return true\n        }\n\n        group[to] = from\n        return false\n    }\n\n    for _, edge := range edges {\n        // 联通分量事先已经联通则表示有环\n        if union(edge[0], edge[1]) {\n            return edge\n        }\n    }\n\n    return []int{}\n}\n```\n","slug":"leetcode/684.冗余链接","published":1,"category":"算法","updated":"2022-11-01T02:33:31.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfz002b0k4lg23xgr9s","content":"<p><a href=\"https://leetcode.cn/problems/redundant-connection/\">leetcode</a></p>\n<p>使用并查集方法，维护联通分量数组，检验每条边的两个节点，如果已经联通了，则当前边导致成环，为冗余链接。</p>\n<p>时间复杂度：<br>空间复杂度：O(n)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findRedundantConnection</span><span class=\"hljs-params\">(edges [][]<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    group := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(edges) + <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(edges) + <span class=\"hljs-number\">1</span>; i++ &#123;<br>       group[i] = i<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> find <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span><br><br>    <span class=\"hljs-comment\">// 查找真正的联通分量</span><br>    find = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> group[i] == i &#123;<br>            <span class=\"hljs-keyword\">return</span> i<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> find(group[i])<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 合并两个联通分量，返回这个两个联通分量是否本来就联通了</span><br>    union := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(from <span class=\"hljs-type\">int</span>, to <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>        from = find(from)<br>        to = find(to)<br><br>        <span class=\"hljs-keyword\">if</span> from == to &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br><br>        group[to] = from<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> _, edge := <span class=\"hljs-keyword\">range</span> edges &#123;<br>        <span class=\"hljs-comment\">// 联通分量事先已经联通则表示有环</span><br>        <span class=\"hljs-keyword\">if</span> union(edge[<span class=\"hljs-number\">0</span>], edge[<span class=\"hljs-number\">1</span>]) &#123;<br>            <span class=\"hljs-keyword\">return</span> edge<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":670,"excerpt":"<p><a href=\"https://leetcode.cn/problems/redundant-connection/\">leetcode</a></p>\n<p>使用并查集方法，维护联通分量数组，检验每条边的两个节点，如果已经联通了，则当前边导致成环，为冗余链接。</p>\n<p>时间复杂度：<br>空间复杂度：O(n)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findRedundantConnection</span><span class=\"hljs-params\">(edges [][]<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    group := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(edges) + <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(edges) + <span class=\"hljs-number\">1</span>; i++ &#123;<br>       group[i] = i<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> find <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span><br><br>    <span class=\"hljs-comment\">// 查找真正的联通分量</span><br>    find = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> group[i] == i &#123;<br>            <span class=\"hljs-keyword\">return</span> i<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> find(group[i])<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 合并两个联通分量，返回这个两个联通分量是否本来就联通了</span><br>    union := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(from <span class=\"hljs-type\">int</span>, to <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>        from = find(from)<br>        to = find(to)<br><br>        <span class=\"hljs-keyword\">if</span> from == to &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br><br>        group[to] = from<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> _, edge := <span class=\"hljs-keyword\">range</span> edges &#123;<br>        <span class=\"hljs-comment\">// 联通分量事先已经联通则表示有环</span><br>        <span class=\"hljs-keyword\">if</span> union(edge[<span class=\"hljs-number\">0</span>], edge[<span class=\"hljs-number\">1</span>]) &#123;<br>            <span class=\"hljs-keyword\">return</span> edge<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"699. 掉落的方块","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"<!-- more -->\n```Go\ntype Box struct {\n    Left int\n    Right int\n    Height int\n}\n\nfunc fallingSquares(positions [][]int) []int {\n    boxes := []Box{}\n    ans := []int{}\n    max := 0\n\n    for _, p := range positions {\n        left := p[0]\n        right := p[0] + p[1]\n        height := p[1]\n        bottom := 0\n\n        for _, b := range boxes {\n            if !(left >= b.Right || right <= b.Left) && bottom < b.Height {\n                bottom = b.Height\n            }\n        }\n\n        height += bottom\n        if height > max {\n            ans = append(ans, height)\n            max = height\n        } else {\n            ans = append(ans, max)\n        }\n\n        boxes = append(boxes, Box{Left: left, Right: right, Height: height})\n    }\n\n\n    return ans\n}\n```\n","source":"_posts/算法/leetcode/699. 掉落的方块.md","raw":"---\ntitle: 699. 掉落的方块\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n<!-- more -->\n```Go\ntype Box struct {\n    Left int\n    Right int\n    Height int\n}\n\nfunc fallingSquares(positions [][]int) []int {\n    boxes := []Box{}\n    ans := []int{}\n    max := 0\n\n    for _, p := range positions {\n        left := p[0]\n        right := p[0] + p[1]\n        height := p[1]\n        bottom := 0\n\n        for _, b := range boxes {\n            if !(left >= b.Right || right <= b.Left) && bottom < b.Height {\n                bottom = b.Height\n            }\n        }\n\n        height += bottom\n        if height > max {\n            ans = append(ans, height)\n            max = height\n        } else {\n            ans = append(ans, max)\n        }\n\n        boxes = append(boxes, Box{Left: left, Right: right, Height: height})\n    }\n\n\n    return ans\n}\n```\n","slug":"leetcode/699. 掉落的方块","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfz002d0k4l7q1ddf7r","content":"<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Box <span class=\"hljs-keyword\">struct</span> &#123;<br>    Left <span class=\"hljs-type\">int</span><br>    Right <span class=\"hljs-type\">int</span><br>    Height <span class=\"hljs-type\">int</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fallingSquares</span><span class=\"hljs-params\">(positions [][]<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    boxes := []Box&#123;&#125;<br>    ans := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>    max := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">for</span> _, p := <span class=\"hljs-keyword\">range</span> positions &#123;<br>        left := p[<span class=\"hljs-number\">0</span>]<br>        right := p[<span class=\"hljs-number\">0</span>] + p[<span class=\"hljs-number\">1</span>]<br>        height := p[<span class=\"hljs-number\">1</span>]<br>        bottom := <span class=\"hljs-number\">0</span><br><br>        <span class=\"hljs-keyword\">for</span> _, b := <span class=\"hljs-keyword\">range</span> boxes &#123;<br>            <span class=\"hljs-keyword\">if</span> !(left &gt;= b.Right || right &lt;= b.Left) &amp;&amp; bottom &lt; b.Height &#123;<br>                bottom = b.Height<br>            &#125;<br>        &#125;<br><br>        height += bottom<br>        <span class=\"hljs-keyword\">if</span> height &gt; max &#123;<br>            ans = <span class=\"hljs-built_in\">append</span>(ans, height)<br>            max = height<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            ans = <span class=\"hljs-built_in\">append</span>(ans, max)<br>        &#125;<br><br>        boxes = <span class=\"hljs-built_in\">append</span>(boxes, Box&#123;Left: left, Right: right, Height: height&#125;)<br>    &#125;<br><br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":611,"excerpt":"","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Box <span class=\"hljs-keyword\">struct</span> &#123;<br>    Left <span class=\"hljs-type\">int</span><br>    Right <span class=\"hljs-type\">int</span><br>    Height <span class=\"hljs-type\">int</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fallingSquares</span><span class=\"hljs-params\">(positions [][]<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    boxes := []Box&#123;&#125;<br>    ans := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>    max := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">for</span> _, p := <span class=\"hljs-keyword\">range</span> positions &#123;<br>        left := p[<span class=\"hljs-number\">0</span>]<br>        right := p[<span class=\"hljs-number\">0</span>] + p[<span class=\"hljs-number\">1</span>]<br>        height := p[<span class=\"hljs-number\">1</span>]<br>        bottom := <span class=\"hljs-number\">0</span><br><br>        <span class=\"hljs-keyword\">for</span> _, b := <span class=\"hljs-keyword\">range</span> boxes &#123;<br>            <span class=\"hljs-keyword\">if</span> !(left &gt;= b.Right || right &lt;= b.Left) &amp;&amp; bottom &lt; b.Height &#123;<br>                bottom = b.Height<br>            &#125;<br>        &#125;<br><br>        height += bottom<br>        <span class=\"hljs-keyword\">if</span> height &gt; max &#123;<br>            ans = <span class=\"hljs-built_in\">append</span>(ans, height)<br>            max = height<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            ans = <span class=\"hljs-built_in\">append</span>(ans, max)<br>        &#125;<br><br>        boxes = <span class=\"hljs-built_in\">append</span>(boxes, Box&#123;Left: left, Right: right, Height: height&#125;)<br>    &#125;<br><br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"685.冗余链接2","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/redundant-connection-ii/)\n\n建立出边邻接表，节点入度数组。\n\n因为需要返回最后的一个可以去除的边，故倒序删除边，删除后满足树的条件则表明该边为要找的冗余边。\n\n为树的条件：\n\n1. 有且只有一个入度大于0的点（防止成环）\n2. 且最长路径的步数和节点数相等（防止有独立的多块不联通的图）\n<!-- more -->\n```Go\nfunc findRedundantDirectedConnection(edges [][]int) []int {\n\tto := make(map[int][]int)\n\tdegrees := make([]int, len(edges)+1)\n\n\tfor _, edge := range edges {\n\t\tto[edge[0]] = append(to[edge[0]], edge[1])\n\t\tdegrees[edge[1]]++\n\t}\n\n\t// fmt.Printf(\"to: %v\\n\", to)\n\t// fmt.Printf(\"degress: %v\\n\", degrees)\n\n\tvalid := func() bool {\n\t\tvar root int\n\t\tfor i := 1; i < len(degrees); i++ {\n\t\t\tif degrees[i] == 0 {\n\t\t\t\troot = i\n\t\t\t}\n\n\t\t\t// 有入度大于0的点，表示有环\n\t\t\tif degrees[i] > 1 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\t// 没有入度为0的点，表示有环\n\t\tif root == 0 {\n\t\t\treturn false\n\t\t}\n\n\t\tseen := []int{}\n\n\t\tvar bfs func(int)\n\n\t\tbfs = func(root int) {\n\t\t\tseen = append(seen, root)\n\t\t\tfor _, c := range to[root] {\n\t\t\t\tbfs(c)\n\t\t\t}\n\t\t}\n\n\t\tbfs(root)\n\n\t\treturn len(seen) == len(edges)\n\t}\n\n\t// 倒序删除边\n\tfor i := len(edges) - 1; i >= 0; i-- {\n\t\tedge := edges[i]\n\t\tfor j, t := range to[edge[0]] {\n\t\t\tif t == edge[1] {\n\t\t\t\tto[edge[0]] = append(to[edge[0]][:j], to[edge[0]][j+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tdegrees[edge[1]]--\n\t\tif valid() {\n\t\t\treturn edges[i]\n\t\t}\n\n\t\t// 还原\n\t\tto[edge[0]] = append(to[edge[0]], edge[1])\n\t\tdegrees[edge[1]]++\n\t}\n\n\treturn []int{}\n}\n```\n","source":"_posts/算法/leetcode/685.冗余链接2.md","raw":"---\ntitle: 685.冗余链接2\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/redundant-connection-ii/)\n\n建立出边邻接表，节点入度数组。\n\n因为需要返回最后的一个可以去除的边，故倒序删除边，删除后满足树的条件则表明该边为要找的冗余边。\n\n为树的条件：\n\n1. 有且只有一个入度大于0的点（防止成环）\n2. 且最长路径的步数和节点数相等（防止有独立的多块不联通的图）\n<!-- more -->\n```Go\nfunc findRedundantDirectedConnection(edges [][]int) []int {\n\tto := make(map[int][]int)\n\tdegrees := make([]int, len(edges)+1)\n\n\tfor _, edge := range edges {\n\t\tto[edge[0]] = append(to[edge[0]], edge[1])\n\t\tdegrees[edge[1]]++\n\t}\n\n\t// fmt.Printf(\"to: %v\\n\", to)\n\t// fmt.Printf(\"degress: %v\\n\", degrees)\n\n\tvalid := func() bool {\n\t\tvar root int\n\t\tfor i := 1; i < len(degrees); i++ {\n\t\t\tif degrees[i] == 0 {\n\t\t\t\troot = i\n\t\t\t}\n\n\t\t\t// 有入度大于0的点，表示有环\n\t\t\tif degrees[i] > 1 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\t// 没有入度为0的点，表示有环\n\t\tif root == 0 {\n\t\t\treturn false\n\t\t}\n\n\t\tseen := []int{}\n\n\t\tvar bfs func(int)\n\n\t\tbfs = func(root int) {\n\t\t\tseen = append(seen, root)\n\t\t\tfor _, c := range to[root] {\n\t\t\t\tbfs(c)\n\t\t\t}\n\t\t}\n\n\t\tbfs(root)\n\n\t\treturn len(seen) == len(edges)\n\t}\n\n\t// 倒序删除边\n\tfor i := len(edges) - 1; i >= 0; i-- {\n\t\tedge := edges[i]\n\t\tfor j, t := range to[edge[0]] {\n\t\t\tif t == edge[1] {\n\t\t\t\tto[edge[0]] = append(to[edge[0]][:j], to[edge[0]][j+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tdegrees[edge[1]]--\n\t\tif valid() {\n\t\t\treturn edges[i]\n\t\t}\n\n\t\t// 还原\n\t\tto[edge[0]] = append(to[edge[0]], edge[1])\n\t\tdegrees[edge[1]]++\n\t}\n\n\treturn []int{}\n}\n```\n","slug":"leetcode/685.冗余链接2","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbfz002f0k4l5afle1ii","content":"<p><a href=\"https://leetcode.cn/problems/redundant-connection-ii/\">leetcode</a></p>\n<p>建立出边邻接表，节点入度数组。</p>\n<p>因为需要返回最后的一个可以去除的边，故倒序删除边，删除后满足树的条件则表明该边为要找的冗余边。</p>\n<p>为树的条件：</p>\n<ol>\n<li>有且只有一个入度大于0的点（防止成环）</li>\n<li>且最长路径的步数和节点数相等（防止有独立的多块不联通的图）<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findRedundantDirectedConnection</span><span class=\"hljs-params\">(edges [][]<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tto := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>][]<span class=\"hljs-type\">int</span>)<br>\tdegrees := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(edges)+<span class=\"hljs-number\">1</span>)<br><br>\t<span class=\"hljs-keyword\">for</span> _, edge := <span class=\"hljs-keyword\">range</span> edges &#123;<br>\t\tto[edge[<span class=\"hljs-number\">0</span>]] = <span class=\"hljs-built_in\">append</span>(to[edge[<span class=\"hljs-number\">0</span>]], edge[<span class=\"hljs-number\">1</span>])<br>\t\tdegrees[edge[<span class=\"hljs-number\">1</span>]]++<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// fmt.Printf(&quot;to: %v\\n&quot;, to)</span><br>\t<span class=\"hljs-comment\">// fmt.Printf(&quot;degress: %v\\n&quot;, degrees)</span><br><br>\tvalid := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t\t<span class=\"hljs-keyword\">var</span> root <span class=\"hljs-type\">int</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(degrees); i++ &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> degrees[i] == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\troot = i<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 有入度大于0的点，表示有环</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> degrees[i] &gt; <span class=\"hljs-number\">1</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 没有入度为0的点，表示有环</span><br>\t\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br><br>\t\tseen := []<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>\t\t<span class=\"hljs-keyword\">var</span> bfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br><br>\t\tbfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(root <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t\t\tseen = <span class=\"hljs-built_in\">append</span>(seen, root)<br>\t\t\t<span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> to[root] &#123;<br>\t\t\t\tbfs(c)<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\tbfs(root)<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(seen) == <span class=\"hljs-built_in\">len</span>(edges)<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 倒序删除边</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-built_in\">len</span>(edges) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;<br>\t\tedge := edges[i]<br>\t\t<span class=\"hljs-keyword\">for</span> j, t := <span class=\"hljs-keyword\">range</span> to[edge[<span class=\"hljs-number\">0</span>]] &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> t == edge[<span class=\"hljs-number\">1</span>] &#123;<br>\t\t\t\tto[edge[<span class=\"hljs-number\">0</span>]] = <span class=\"hljs-built_in\">append</span>(to[edge[<span class=\"hljs-number\">0</span>]][:j], to[edge[<span class=\"hljs-number\">0</span>]][j+<span class=\"hljs-number\">1</span>:]...)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdegrees[edge[<span class=\"hljs-number\">1</span>]]--<br>\t\t<span class=\"hljs-keyword\">if</span> valid() &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> edges[i]<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 还原</span><br>\t\tto[edge[<span class=\"hljs-number\">0</span>]] = <span class=\"hljs-built_in\">append</span>(to[edge[<span class=\"hljs-number\">0</span>]], edge[<span class=\"hljs-number\">1</span>])<br>\t\tdegrees[edge[<span class=\"hljs-number\">1</span>]]++<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":1243,"excerpt":"<p><a href=\"https://leetcode.cn/problems/redundant-connection-ii/\">leetcode</a></p>\n<p>建立出边邻接表，节点入度数组。</p>\n<p>因为需要返回最后的一个可以去除的边，故倒序删除边，删除后满足树的条件则表明该边为要找的冗余边。</p>\n<p>为树的条件：</p>\n<ol>\n<li>有且只有一个入度大于0的点（防止成环）</li>\n<li>且最长路径的步数和节点数相等（防止有独立的多块不联通的图）","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findRedundantDirectedConnection</span><span class=\"hljs-params\">(edges [][]<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tto := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>][]<span class=\"hljs-type\">int</span>)<br>\tdegrees := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(edges)+<span class=\"hljs-number\">1</span>)<br><br>\t<span class=\"hljs-keyword\">for</span> _, edge := <span class=\"hljs-keyword\">range</span> edges &#123;<br>\t\tto[edge[<span class=\"hljs-number\">0</span>]] = <span class=\"hljs-built_in\">append</span>(to[edge[<span class=\"hljs-number\">0</span>]], edge[<span class=\"hljs-number\">1</span>])<br>\t\tdegrees[edge[<span class=\"hljs-number\">1</span>]]++<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// fmt.Printf(&quot;to: %v\\n&quot;, to)</span><br>\t<span class=\"hljs-comment\">// fmt.Printf(&quot;degress: %v\\n&quot;, degrees)</span><br><br>\tvalid := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t\t<span class=\"hljs-keyword\">var</span> root <span class=\"hljs-type\">int</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(degrees); i++ &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> degrees[i] == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\troot = i<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 有入度大于0的点，表示有环</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> degrees[i] &gt; <span class=\"hljs-number\">1</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 没有入度为0的点，表示有环</span><br>\t\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br><br>\t\tseen := []<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>\t\t<span class=\"hljs-keyword\">var</span> bfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br><br>\t\tbfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(root <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t\t\tseen = <span class=\"hljs-built_in\">append</span>(seen, root)<br>\t\t\t<span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> to[root] &#123;<br>\t\t\t\tbfs(c)<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\tbfs(root)<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(seen) == <span class=\"hljs-built_in\">len</span>(edges)<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 倒序删除边</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-built_in\">len</span>(edges) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;<br>\t\tedge := edges[i]<br>\t\t<span class=\"hljs-keyword\">for</span> j, t := <span class=\"hljs-keyword\">range</span> to[edge[<span class=\"hljs-number\">0</span>]] &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> t == edge[<span class=\"hljs-number\">1</span>] &#123;<br>\t\t\t\tto[edge[<span class=\"hljs-number\">0</span>]] = <span class=\"hljs-built_in\">append</span>(to[edge[<span class=\"hljs-number\">0</span>]][:j], to[edge[<span class=\"hljs-number\">0</span>]][j+<span class=\"hljs-number\">1</span>:]...)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdegrees[edge[<span class=\"hljs-number\">1</span>]]--<br>\t\t<span class=\"hljs-keyword\">if</span> valid() &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> edges[i]<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 还原</span><br>\t\tto[edge[<span class=\"hljs-number\">0</span>]] = <span class=\"hljs-built_in\">append</span>(to[edge[<span class=\"hljs-number\">0</span>]], edge[<span class=\"hljs-number\">1</span>])<br>\t\tdegrees[edge[<span class=\"hljs-number\">1</span>]]++<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>"},{"title":"72.编辑距离","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n动态规划\n\n`f[i][j]` 记录 `word1[1..i]` 到 `word2[1..j]` 的最短编辑距离。则考虑三种情况：\n\n1. word1插入一个字符和word2相等：`f[i][j-1] + 1`\n2. word1删除一个字符和word2相等： `f[i-1][j] + 1`\n3. word1替换一个字符和word2相等：`f[i-1]f[j-1] + eq` 。其中eq考虑两种状态，如果word1要替换的这个字符和word2的最后一个字符相等，则表示不需要替换已经相等，eq等0，否则eq等于1\n\n时间复杂度： O(MN)\n空间复杂度： O(MN)\n<!-- more -->\n```Go\nfunc minDistance(word1 string, word2 string) int {\n    // f[i][j] = min(f[i][j-1]+1, f[i-1][j]+1, f[i-1][j-1] + eq)\n\n    m := len(word1)\n    n := len(word2)\n    f := make([][]int, m+1)\n\n    for i := 0; i <= m; i++ {\n        f[i] = make([]int, n+1)\n        for j := 0; j <= n; j ++ {\n            if i == 0 {\n                f[i][j] = j\n                continue\n            }\n\n            if j == 0 {\n                f[i][j] = i\n                continue\n            }\n\n            temp := min(f[i][j-1] + 1, f[i-1][j] + 1)\n\n            eq := 1\n            if word1[i-1] == word2[j-1] {\n                eq = 0\n            }\n            temp = min(temp, f[i-1][j-1]+eq)\n\n            // fmt.Printf(\"f[%v][%v]: %v\\n\", i, j, temp)\n\n            f[i][j] = temp\n        }\n    }\n\n    return f[m][n]\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n","source":"_posts/算法/leetcode/72.编辑距离.md","raw":"---\ntitle: 72.编辑距离\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n动态规划\n\n`f[i][j]` 记录 `word1[1..i]` 到 `word2[1..j]` 的最短编辑距离。则考虑三种情况：\n\n1. word1插入一个字符和word2相等：`f[i][j-1] + 1`\n2. word1删除一个字符和word2相等： `f[i-1][j] + 1`\n3. word1替换一个字符和word2相等：`f[i-1]f[j-1] + eq` 。其中eq考虑两种状态，如果word1要替换的这个字符和word2的最后一个字符相等，则表示不需要替换已经相等，eq等0，否则eq等于1\n\n时间复杂度： O(MN)\n空间复杂度： O(MN)\n<!-- more -->\n```Go\nfunc minDistance(word1 string, word2 string) int {\n    // f[i][j] = min(f[i][j-1]+1, f[i-1][j]+1, f[i-1][j-1] + eq)\n\n    m := len(word1)\n    n := len(word2)\n    f := make([][]int, m+1)\n\n    for i := 0; i <= m; i++ {\n        f[i] = make([]int, n+1)\n        for j := 0; j <= n; j ++ {\n            if i == 0 {\n                f[i][j] = j\n                continue\n            }\n\n            if j == 0 {\n                f[i][j] = i\n                continue\n            }\n\n            temp := min(f[i][j-1] + 1, f[i-1][j] + 1)\n\n            eq := 1\n            if word1[i-1] == word2[j-1] {\n                eq = 0\n            }\n            temp = min(temp, f[i-1][j-1]+eq)\n\n            // fmt.Printf(\"f[%v][%v]: %v\\n\", i, j, temp)\n\n            f[i][j] = temp\n        }\n    }\n\n    return f[m][n]\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n","slug":"leetcode/72.编辑距离","published":1,"category":"算法","updated":"2022-11-01T02:33:31.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg0002h0k4l4x9d7oy4","content":"<p>动态规划</p>\n<p><code>f[i][j]</code> 记录 <code>word1[1..i]</code> 到 <code>word2[1..j]</code> 的最短编辑距离。则考虑三种情况：</p>\n<ol>\n<li>word1插入一个字符和word2相等：<code>f[i][j-1] + 1</code></li>\n<li>word1删除一个字符和word2相等： <code>f[i-1][j] + 1</code></li>\n<li>word1替换一个字符和word2相等：<code>f[i-1]f[j-1] + eq</code> 。其中eq考虑两种状态，如果word1要替换的这个字符和word2的最后一个字符相等，则表示不需要替换已经相等，eq等0，否则eq等于1</li>\n</ol>\n<p>时间复杂度： O(MN)<br>空间复杂度： O(MN)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDistance</span><span class=\"hljs-params\">(word1 <span class=\"hljs-type\">string</span>, word2 <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// f[i][j] = min(f[i][j-1]+1, f[i-1][j]+1, f[i-1][j-1] + eq)</span><br><br>    m := <span class=\"hljs-built_in\">len</span>(word1)<br>    n := <span class=\"hljs-built_in\">len</span>(word2)<br>    f := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, m+<span class=\"hljs-number\">1</span>)<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt;= m; i++ &#123;<br>        f[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n+<span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt;= n; j ++ &#123;<br>            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-number\">0</span> &#123;<br>                f[i][j] = j<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">if</span> j == <span class=\"hljs-number\">0</span> &#123;<br>                f[i][j] = i<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            temp := min(f[i][j<span class=\"hljs-number\">-1</span>] + <span class=\"hljs-number\">1</span>, f[i<span class=\"hljs-number\">-1</span>][j] + <span class=\"hljs-number\">1</span>)<br><br>            eq := <span class=\"hljs-number\">1</span><br>            <span class=\"hljs-keyword\">if</span> word1[i<span class=\"hljs-number\">-1</span>] == word2[j<span class=\"hljs-number\">-1</span>] &#123;<br>                eq = <span class=\"hljs-number\">0</span><br>            &#125;<br>            temp = min(temp, f[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+eq)<br><br>            <span class=\"hljs-comment\">// fmt.Printf(&quot;f[%v][%v]: %v\\n&quot;, i, j, temp)</span><br><br>            f[i][j] = temp<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> f[m][n]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":868,"excerpt":"<p>动态规划</p>\n<p><code>f[i][j]</code> 记录 <code>word1[1..i]</code> 到 <code>word2[1..j]</code> 的最短编辑距离。则考虑三种情况：</p>\n<ol>\n<li>word1插入一个字符和word2相等：<code>f[i][j-1] + 1</code></li>\n<li>word1删除一个字符和word2相等： <code>f[i-1][j] + 1</code></li>\n<li>word1替换一个字符和word2相等：<code>f[i-1]f[j-1] + eq</code> 。其中eq考虑两种状态，如果word1要替换的这个字符和word2的最后一个字符相等，则表示不需要替换已经相等，eq等0，否则eq等于1</li>\n</ol>\n<p>时间复杂度： O(MN)<br>空间复杂度： O(MN)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDistance</span><span class=\"hljs-params\">(word1 <span class=\"hljs-type\">string</span>, word2 <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// f[i][j] = min(f[i][j-1]+1, f[i-1][j]+1, f[i-1][j-1] + eq)</span><br><br>    m := <span class=\"hljs-built_in\">len</span>(word1)<br>    n := <span class=\"hljs-built_in\">len</span>(word2)<br>    f := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, m+<span class=\"hljs-number\">1</span>)<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt;= m; i++ &#123;<br>        f[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n+<span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt;= n; j ++ &#123;<br>            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-number\">0</span> &#123;<br>                f[i][j] = j<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">if</span> j == <span class=\"hljs-number\">0</span> &#123;<br>                f[i][j] = i<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            temp := min(f[i][j<span class=\"hljs-number\">-1</span>] + <span class=\"hljs-number\">1</span>, f[i<span class=\"hljs-number\">-1</span>][j] + <span class=\"hljs-number\">1</span>)<br><br>            eq := <span class=\"hljs-number\">1</span><br>            <span class=\"hljs-keyword\">if</span> word1[i<span class=\"hljs-number\">-1</span>] == word2[j<span class=\"hljs-number\">-1</span>] &#123;<br>                eq = <span class=\"hljs-number\">0</span><br>            &#125;<br>            temp = min(temp, f[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+eq)<br><br>            <span class=\"hljs-comment\">// fmt.Printf(&quot;f[%v][%v]: %v\\n&quot;, i, j, temp)</span><br><br>            f[i][j] = temp<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> f[m][n]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"704.二分查找","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n二分查找标准模板\n\n时间复杂度：O(logn)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc search(nums []int, target int) int {\n    left, right := 0, len(nums) -1\n\n    for left < right {\n        mid := (left + right) / 2\n\t\t// 找到第一个大于等于target的数\n        if nums[mid] >= target {\n\t        right = mid\n        }else{\n            left = mid + 1\n        }\n    }\n\n\t// 这个数等于target则返回下标\n    if nums[right] == target {\n        return right\n    }\n    \n    return -1\n}\n```\n","source":"_posts/算法/leetcode/704.二分查找.md","raw":"---\ntitle: 704.二分查找\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n二分查找标准模板\n\n时间复杂度：O(logn)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc search(nums []int, target int) int {\n    left, right := 0, len(nums) -1\n\n    for left < right {\n        mid := (left + right) / 2\n\t\t// 找到第一个大于等于target的数\n        if nums[mid] >= target {\n\t        right = mid\n        }else{\n            left = mid + 1\n        }\n    }\n\n\t// 这个数等于target则返回下标\n    if nums[right] == target {\n        return right\n    }\n    \n    return -1\n}\n```\n","slug":"leetcode/704.二分查找","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg0002j0k4lfhtj7odp","content":"<p>二分查找标准模板</p>\n<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    left, right := <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(nums) <span class=\"hljs-number\">-1</span><br><br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        mid := (left + right) / <span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-comment\">// 找到第一个大于等于target的数</span><br>        <span class=\"hljs-keyword\">if</span> nums[mid] &gt;= target &#123;<br>\t        right = mid<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            left = mid + <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 这个数等于target则返回下标</span><br>    <span class=\"hljs-keyword\">if</span> nums[right] == target &#123;<br>        <span class=\"hljs-keyword\">return</span> right<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":338,"excerpt":"<p>二分查找标准模板</p>\n<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    left, right := <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(nums) <span class=\"hljs-number\">-1</span><br><br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        mid := (left + right) / <span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-comment\">// 找到第一个大于等于target的数</span><br>        <span class=\"hljs-keyword\">if</span> nums[mid] &gt;= target &#123;<br>\t        right = mid<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            left = mid + <span class=\"hljs-number\">1</span><br>        &#125;<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 这个数等于target则返回下标</span><br>    <span class=\"hljs-keyword\">if</span> nums[right] == target &#123;<br>        <span class=\"hljs-keyword\">return</span> right<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"721.账户合并","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n并查集\n\n注意使用Hashmap来存储邮箱和父节点邮箱。\n\n时间复杂度： O(NlogN)\n空间复杂度： O(N)\n<!-- more -->\n```Go\nfunc accountsMerge(accounts [][]string) [][]string {\n\n    ans := [][]string{}\n    email_to_name := make(map[string]string)\n    emails_list := make(map[string]string)\n\n\t// 查找\n    var find func(string) string\n    find = func(email string) string{\n        if emails_list[email] == email {\n            return email\n        }\n\n        emails_list[email] = find(emails_list[email])\n        return emails_list[email]\n    }\n\n\t// 合并\n    union := func(email1 string,  email2 string) {\n        e1 := find(email1)\n        e2 := find(email2)\n\n        // fmt.Printf(\"union: %v, %v\\n\", email1, email2)\n        emails_list[e1] = e2\n    }\n    \n    for _, account := range accounts {\n        name := account[0]\n        emails := account[1:]\n\n        for i, email := range emails {\n            if i == 0 {\n                email_to_name[email] = name\n            }\n            // 没出现过的邮箱关联父节点到当前账号的首个邮箱\n            if _, ok := emails_list[email]; !ok {\n                emails_list[email] = emails[0]\n            } else {\n            // 出现过的邮箱则把当前账号和出现过的账号合并\n                union(emails[0], email)\n            }\n        }\n    }\n\n    group := make(map[string][]string)\n    for email, fa := range emails_list {\n\t    // 获取邮箱的真实父节点邮箱\n        fa = find(fa)\n        if _, ok := group[fa]; ok {\n            group[fa] = append(group[fa], email)\n        } else {\n            group[fa] = []string{email}\n        }\n    }\n\n    for fa, emails := range group {\n        sort.Strings(emails)\n        ans = append(ans, append([]string{email_to_name[fa]}, emails...))\n    }\n\n    // fmt.Printf(\"group: %v\", group)\n    \n\n    return ans\n}\n```\n","source":"_posts/算法/leetcode/721.账户合并.md","raw":"---\ntitle: 721.账户合并\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n并查集\n\n注意使用Hashmap来存储邮箱和父节点邮箱。\n\n时间复杂度： O(NlogN)\n空间复杂度： O(N)\n<!-- more -->\n```Go\nfunc accountsMerge(accounts [][]string) [][]string {\n\n    ans := [][]string{}\n    email_to_name := make(map[string]string)\n    emails_list := make(map[string]string)\n\n\t// 查找\n    var find func(string) string\n    find = func(email string) string{\n        if emails_list[email] == email {\n            return email\n        }\n\n        emails_list[email] = find(emails_list[email])\n        return emails_list[email]\n    }\n\n\t// 合并\n    union := func(email1 string,  email2 string) {\n        e1 := find(email1)\n        e2 := find(email2)\n\n        // fmt.Printf(\"union: %v, %v\\n\", email1, email2)\n        emails_list[e1] = e2\n    }\n    \n    for _, account := range accounts {\n        name := account[0]\n        emails := account[1:]\n\n        for i, email := range emails {\n            if i == 0 {\n                email_to_name[email] = name\n            }\n            // 没出现过的邮箱关联父节点到当前账号的首个邮箱\n            if _, ok := emails_list[email]; !ok {\n                emails_list[email] = emails[0]\n            } else {\n            // 出现过的邮箱则把当前账号和出现过的账号合并\n                union(emails[0], email)\n            }\n        }\n    }\n\n    group := make(map[string][]string)\n    for email, fa := range emails_list {\n\t    // 获取邮箱的真实父节点邮箱\n        fa = find(fa)\n        if _, ok := group[fa]; ok {\n            group[fa] = append(group[fa], email)\n        } else {\n            group[fa] = []string{email}\n        }\n    }\n\n    for fa, emails := range group {\n        sort.Strings(emails)\n        ans = append(ans, append([]string{email_to_name[fa]}, emails...))\n    }\n\n    // fmt.Printf(\"group: %v\", group)\n    \n\n    return ans\n}\n```\n","slug":"leetcode/721.账户合并","published":1,"category":"算法","updated":"2022-11-01T02:33:32.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg1002l0k4lhyd3389a","content":"<p>并查集</p>\n<p>注意使用Hashmap来存储邮箱和父节点邮箱。</p>\n<p>时间复杂度： O(NlogN)<br>空间复杂度： O(N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">accountsMerge</span><span class=\"hljs-params\">(accounts [][]<span class=\"hljs-type\">string</span>)</span></span> [][]<span class=\"hljs-type\">string</span> &#123;<br><br>    ans := [][]<span class=\"hljs-type\">string</span>&#123;&#125;<br>    email_to_name := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">string</span>)<br>    emails_list := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">string</span>)<br><br>\t<span class=\"hljs-comment\">// 查找</span><br>    <span class=\"hljs-keyword\">var</span> find <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span><br>    find = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(email <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span>&#123;<br>        <span class=\"hljs-keyword\">if</span> emails_list[email] == email &#123;<br>            <span class=\"hljs-keyword\">return</span> email<br>        &#125;<br><br>        emails_list[email] = find(emails_list[email])<br>        <span class=\"hljs-keyword\">return</span> emails_list[email]<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 合并</span><br>    union := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(email1 <span class=\"hljs-type\">string</span>,  email2 <span class=\"hljs-type\">string</span>)</span></span> &#123;<br>        e1 := find(email1)<br>        e2 := find(email2)<br><br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;union: %v, %v\\n&quot;, email1, email2)</span><br>        emails_list[e1] = e2<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span> _, account := <span class=\"hljs-keyword\">range</span> accounts &#123;<br>        name := account[<span class=\"hljs-number\">0</span>]<br>        emails := account[<span class=\"hljs-number\">1</span>:]<br><br>        <span class=\"hljs-keyword\">for</span> i, email := <span class=\"hljs-keyword\">range</span> emails &#123;<br>            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-number\">0</span> &#123;<br>                email_to_name[email] = name<br>            &#125;<br>            <span class=\"hljs-comment\">// 没出现过的邮箱关联父节点到当前账号的首个邮箱</span><br>            <span class=\"hljs-keyword\">if</span> _, ok := emails_list[email]; !ok &#123;<br>                emails_list[email] = emails[<span class=\"hljs-number\">0</span>]<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 出现过的邮箱则把当前账号和出现过的账号合并</span><br>                union(emails[<span class=\"hljs-number\">0</span>], email)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    group := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>][]<span class=\"hljs-type\">string</span>)<br>    <span class=\"hljs-keyword\">for</span> email, fa := <span class=\"hljs-keyword\">range</span> emails_list &#123;<br>\t    <span class=\"hljs-comment\">// 获取邮箱的真实父节点邮箱</span><br>        fa = find(fa)<br>        <span class=\"hljs-keyword\">if</span> _, ok := group[fa]; ok &#123;<br>            group[fa] = <span class=\"hljs-built_in\">append</span>(group[fa], email)<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            group[fa] = []<span class=\"hljs-type\">string</span>&#123;email&#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> fa, emails := <span class=\"hljs-keyword\">range</span> group &#123;<br>        sort.Strings(emails)<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">string</span>&#123;email_to_name[fa]&#125;, emails...))<br>    &#125;<br><br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;group: %v&quot;, group)</span><br>    <br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1371,"excerpt":"<p>并查集</p>\n<p>注意使用Hashmap来存储邮箱和父节点邮箱。</p>\n<p>时间复杂度： O(NlogN)<br>空间复杂度： O(N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">accountsMerge</span><span class=\"hljs-params\">(accounts [][]<span class=\"hljs-type\">string</span>)</span></span> [][]<span class=\"hljs-type\">string</span> &#123;<br><br>    ans := [][]<span class=\"hljs-type\">string</span>&#123;&#125;<br>    email_to_name := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">string</span>)<br>    emails_list := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">string</span>)<br><br>\t<span class=\"hljs-comment\">// 查找</span><br>    <span class=\"hljs-keyword\">var</span> find <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span><br>    find = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(email <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span>&#123;<br>        <span class=\"hljs-keyword\">if</span> emails_list[email] == email &#123;<br>            <span class=\"hljs-keyword\">return</span> email<br>        &#125;<br><br>        emails_list[email] = find(emails_list[email])<br>        <span class=\"hljs-keyword\">return</span> emails_list[email]<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 合并</span><br>    union := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(email1 <span class=\"hljs-type\">string</span>,  email2 <span class=\"hljs-type\">string</span>)</span></span> &#123;<br>        e1 := find(email1)<br>        e2 := find(email2)<br><br>        <span class=\"hljs-comment\">// fmt.Printf(&quot;union: %v, %v\\n&quot;, email1, email2)</span><br>        emails_list[e1] = e2<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span> _, account := <span class=\"hljs-keyword\">range</span> accounts &#123;<br>        name := account[<span class=\"hljs-number\">0</span>]<br>        emails := account[<span class=\"hljs-number\">1</span>:]<br><br>        <span class=\"hljs-keyword\">for</span> i, email := <span class=\"hljs-keyword\">range</span> emails &#123;<br>            <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-number\">0</span> &#123;<br>                email_to_name[email] = name<br>            &#125;<br>            <span class=\"hljs-comment\">// 没出现过的邮箱关联父节点到当前账号的首个邮箱</span><br>            <span class=\"hljs-keyword\">if</span> _, ok := emails_list[email]; !ok &#123;<br>                emails_list[email] = emails[<span class=\"hljs-number\">0</span>]<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 出现过的邮箱则把当前账号和出现过的账号合并</span><br>                union(emails[<span class=\"hljs-number\">0</span>], email)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    group := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>][]<span class=\"hljs-type\">string</span>)<br>    <span class=\"hljs-keyword\">for</span> email, fa := <span class=\"hljs-keyword\">range</span> emails_list &#123;<br>\t    <span class=\"hljs-comment\">// 获取邮箱的真实父节点邮箱</span><br>        fa = find(fa)<br>        <span class=\"hljs-keyword\">if</span> _, ok := group[fa]; ok &#123;<br>            group[fa] = <span class=\"hljs-built_in\">append</span>(group[fa], email)<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            group[fa] = []<span class=\"hljs-type\">string</span>&#123;email&#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> fa, emails := <span class=\"hljs-keyword\">range</span> group &#123;<br>        sort.Strings(emails)<br>        ans = <span class=\"hljs-built_in\">append</span>(ans, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">string</span>&#123;email_to_name[fa]&#125;, emails...))<br>    &#125;<br><br>    <span class=\"hljs-comment\">// fmt.Printf(&quot;group: %v&quot;, group)</span><br>    <br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"78.子集","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/subsets/)\n\n递归来枚举子集\n<!-- more -->\n```Go\nfunc subsets(nums []int) [][]int {\n    result := [][]int{}\n    curr := []int{}\n\n    var dfs func(int)\n    dfs = func(i int){\n        if i >= len(nums) {\n\t        // 合并到答案的时候新开变量\n            result = append(result, append([]int{}, curr...))\n            return\n        }\n\n        curr = append(curr, nums[i])\n        dfs(i + 1)\n        curr = curr[:len(curr)-1]\n        dfs(i + 1)\n    }\n\n    dfs(0)\n\n    return result\n}\n```\n","source":"_posts/算法/leetcode/78.子集.md","raw":"---\ntitle: 78.子集\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/subsets/)\n\n递归来枚举子集\n<!-- more -->\n```Go\nfunc subsets(nums []int) [][]int {\n    result := [][]int{}\n    curr := []int{}\n\n    var dfs func(int)\n    dfs = func(i int){\n        if i >= len(nums) {\n\t        // 合并到答案的时候新开变量\n            result = append(result, append([]int{}, curr...))\n            return\n        }\n\n        curr = append(curr, nums[i])\n        dfs(i + 1)\n        curr = curr[:len(curr)-1]\n        dfs(i + 1)\n    }\n\n    dfs(0)\n\n    return result\n}\n```\n","slug":"leetcode/78.子集","published":1,"category":"算法","updated":"2022-11-01T02:33:32.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg1002n0k4l6lbhfn98","content":"<p><a href=\"https://leetcode.cn/problems/subsets/\">leetcode</a></p>\n<p>递归来枚举子集</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">subsets</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>    result := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    curr := []<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span> i &gt;= <span class=\"hljs-built_in\">len</span>(nums) &#123;<br>\t        <span class=\"hljs-comment\">// 合并到答案的时候新开变量</span><br>            result = <span class=\"hljs-built_in\">append</span>(result, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, curr...))<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        curr = <span class=\"hljs-built_in\">append</span>(curr, nums[i])<br>        dfs(i + <span class=\"hljs-number\">1</span>)<br>        curr = curr[:<span class=\"hljs-built_in\">len</span>(curr)<span class=\"hljs-number\">-1</span>]<br>        dfs(i + <span class=\"hljs-number\">1</span>)<br>    &#125;<br><br>    dfs(<span class=\"hljs-number\">0</span>)<br><br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":368,"excerpt":"<p><a href=\"https://leetcode.cn/problems/subsets/\">leetcode</a></p>\n<p>递归来枚举子集</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">subsets</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>    result := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    curr := []<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span> i &gt;= <span class=\"hljs-built_in\">len</span>(nums) &#123;<br>\t        <span class=\"hljs-comment\">// 合并到答案的时候新开变量</span><br>            result = <span class=\"hljs-built_in\">append</span>(result, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, curr...))<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        curr = <span class=\"hljs-built_in\">append</span>(curr, nums[i])<br>        dfs(i + <span class=\"hljs-number\">1</span>)<br>        curr = curr[:<span class=\"hljs-built_in\">len</span>(curr)<span class=\"hljs-number\">-1</span>]<br>        dfs(i + <span class=\"hljs-number\">1</span>)<br>    &#125;<br><br>    dfs(<span class=\"hljs-number\">0</span>)<br><br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"77.组合","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode-cn.com/problems/combinations/)\n\n递归实现：\n<!-- more -->\n```Go\nfunc combine(n int, k int) [][]int {\n    curr := []int{}\n    result := [][]int{}\n\n    var dfs func(int)\n    dfs = func(i int) {\n        //如果剩下的数都取，还不够k，就剪枝\n        if len(curr) + n - i + 1 < k {\n            return\n        }\n\n        if len(curr) == k {\n            result = append(result, append([]int{}, curr...))\n            return\n        }\n\n        curr = append(curr, i)\n        dfs(i + 1)\n\n        curr = curr[:len(curr) - 1]\n        dfs(i + 1)\n    }\n\n    dfs(1)\n    return result\n}\n```\n\n","source":"_posts/算法/leetcode/77.组合.md","raw":"---\ntitle: 77.组合\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode-cn.com/problems/combinations/)\n\n递归实现：\n<!-- more -->\n```Go\nfunc combine(n int, k int) [][]int {\n    curr := []int{}\n    result := [][]int{}\n\n    var dfs func(int)\n    dfs = func(i int) {\n        //如果剩下的数都取，还不够k，就剪枝\n        if len(curr) + n - i + 1 < k {\n            return\n        }\n\n        if len(curr) == k {\n            result = append(result, append([]int{}, curr...))\n            return\n        }\n\n        curr = append(curr, i)\n        dfs(i + 1)\n\n        curr = curr[:len(curr) - 1]\n        dfs(i + 1)\n    }\n\n    dfs(1)\n    return result\n}\n```\n\n","slug":"leetcode/77.组合","published":1,"category":"算法","updated":"2022-11-01T02:33:31.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg1002p0k4l69vkfky0","content":"<p><a href=\"https://leetcode-cn.com/problems/combinations/\">leetcode</a></p>\n<p>递归实现：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">combine</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>    curr := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>    result := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        <span class=\"hljs-comment\">//如果剩下的数都取，还不够k，就剪枝</span><br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(curr) + n - i + <span class=\"hljs-number\">1</span> &lt; k &#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(curr) == k &#123;<br>            result = <span class=\"hljs-built_in\">append</span>(result, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, curr...))<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        curr = <span class=\"hljs-built_in\">append</span>(curr, i)<br>        dfs(i + <span class=\"hljs-number\">1</span>)<br><br>        curr = curr[:<span class=\"hljs-built_in\">len</span>(curr) - <span class=\"hljs-number\">1</span>]<br>        dfs(i + <span class=\"hljs-number\">1</span>)<br>    &#125;<br><br>    dfs(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":410,"excerpt":"<p><a href=\"https://leetcode-cn.com/problems/combinations/\">leetcode</a></p>\n<p>递归实现：</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">combine</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>    curr := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>    result := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        <span class=\"hljs-comment\">//如果剩下的数都取，还不够k，就剪枝</span><br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(curr) + n - i + <span class=\"hljs-number\">1</span> &lt; k &#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(curr) == k &#123;<br>            result = <span class=\"hljs-built_in\">append</span>(result, <span class=\"hljs-built_in\">append</span>([]<span class=\"hljs-type\">int</span>&#123;&#125;, curr...))<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        curr = <span class=\"hljs-built_in\">append</span>(curr, i)<br>        dfs(i + <span class=\"hljs-number\">1</span>)<br><br>        curr = curr[:<span class=\"hljs-built_in\">len</span>(curr) - <span class=\"hljs-number\">1</span>]<br>        dfs(i + <span class=\"hljs-number\">1</span>)<br>    &#125;<br><br>    dfs(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"743. 网络延迟","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\nBellman-Ford算法\n\n最多遍历N-1轮所有边，得到最短或者最长路径。\n\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc networkDelayTime(times [][]int, n int, k int) int {\n    dist := make([]int, n+1)\n    const inf = math.MaxInt / 2\n\n    for i, _ := range dist {\n        if i == k {\n            dist[i] = 0\n        } else {\n            dist[i] = inf\n        }\n    }\n\n    fmt.Println(dist)\n    for j := 1; j < n; j++ {\n        flag := false\n        for i := 0; i < len(times); i++ {\n            x := times[i][0]\n            y := times[i][1]\n            z := times[i][2]\n\n            if dist[y] > dist[x] + z {\n                // fmt.Printf(\"x: %v, y: %v, z: %v\\n\", x, y, z)\n                dist[y] = dist[x] + z\n                // fmt.Printf(\"dist[x]: %v, dist[y]: %v\\n\",dist[x], dist[y])\n                flag = true\n            }\n        }\n        if !flag {\n            break\n        }\n    }\n\n    ans := 0\n\n    for i := 1; i < len(dist); i++ {\n        if dist[i] == inf {\n            return -1\n        }\n\n        if ans < dist[i] {\n            ans = dist[i]\n        }\n    }\n\n    return ans\n}\n```\n","source":"_posts/算法/leetcode/743. 网络延迟.md","raw":"---\ntitle: 743. 网络延迟\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\nBellman-Ford算法\n\n最多遍历N-1轮所有边，得到最短或者最长路径。\n\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n<!-- more -->\n```Go\nfunc networkDelayTime(times [][]int, n int, k int) int {\n    dist := make([]int, n+1)\n    const inf = math.MaxInt / 2\n\n    for i, _ := range dist {\n        if i == k {\n            dist[i] = 0\n        } else {\n            dist[i] = inf\n        }\n    }\n\n    fmt.Println(dist)\n    for j := 1; j < n; j++ {\n        flag := false\n        for i := 0; i < len(times); i++ {\n            x := times[i][0]\n            y := times[i][1]\n            z := times[i][2]\n\n            if dist[y] > dist[x] + z {\n                // fmt.Printf(\"x: %v, y: %v, z: %v\\n\", x, y, z)\n                dist[y] = dist[x] + z\n                // fmt.Printf(\"dist[x]: %v, dist[y]: %v\\n\",dist[x], dist[y])\n                flag = true\n            }\n        }\n        if !flag {\n            break\n        }\n    }\n\n    ans := 0\n\n    for i := 1; i < len(dist); i++ {\n        if dist[i] == inf {\n            return -1\n        }\n\n        if ans < dist[i] {\n            ans = dist[i]\n        }\n    }\n\n    return ans\n}\n```\n","slug":"leetcode/743. 网络延迟","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg2002r0k4l0yoya36z","content":"<p>Bellman-Ford算法</p>\n<p>最多遍历N-1轮所有边，得到最短或者最长路径。</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">networkDelayTime</span><span class=\"hljs-params\">(times [][]<span class=\"hljs-type\">int</span>, n <span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    dist := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n+<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">const</span> inf = math.MaxInt / <span class=\"hljs-number\">2</span><br><br>    <span class=\"hljs-keyword\">for</span> i, _ := <span class=\"hljs-keyword\">range</span> dist &#123;<br>        <span class=\"hljs-keyword\">if</span> i == k &#123;<br>            dist[i] = <span class=\"hljs-number\">0</span><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            dist[i] = inf<br>        &#125;<br>    &#125;<br><br>    fmt.Println(dist)<br>    <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">1</span>; j &lt; n; j++ &#123;<br>        flag := <span class=\"hljs-literal\">false</span><br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(times); i++ &#123;<br>            x := times[i][<span class=\"hljs-number\">0</span>]<br>            y := times[i][<span class=\"hljs-number\">1</span>]<br>            z := times[i][<span class=\"hljs-number\">2</span>]<br><br>            <span class=\"hljs-keyword\">if</span> dist[y] &gt; dist[x] + z &#123;<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;x: %v, y: %v, z: %v\\n&quot;, x, y, z)</span><br>                dist[y] = dist[x] + z<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;dist[x]: %v, dist[y]: %v\\n&quot;,dist[x], dist[y])</span><br>                flag = <span class=\"hljs-literal\">true</span><br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> !flag &#123;<br>            <span class=\"hljs-keyword\">break</span><br>        &#125;<br>    &#125;<br><br>    ans := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(dist); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> dist[i] == inf &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> ans &lt; dist[i] &#123;<br>            ans = dist[i]<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":789,"excerpt":"<p>Bellman-Ford算法</p>\n<p>最多遍历N-1轮所有边，得到最短或者最长路径。</p>\n<p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">networkDelayTime</span><span class=\"hljs-params\">(times [][]<span class=\"hljs-type\">int</span>, n <span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    dist := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n+<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">const</span> inf = math.MaxInt / <span class=\"hljs-number\">2</span><br><br>    <span class=\"hljs-keyword\">for</span> i, _ := <span class=\"hljs-keyword\">range</span> dist &#123;<br>        <span class=\"hljs-keyword\">if</span> i == k &#123;<br>            dist[i] = <span class=\"hljs-number\">0</span><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            dist[i] = inf<br>        &#125;<br>    &#125;<br><br>    fmt.Println(dist)<br>    <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">1</span>; j &lt; n; j++ &#123;<br>        flag := <span class=\"hljs-literal\">false</span><br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(times); i++ &#123;<br>            x := times[i][<span class=\"hljs-number\">0</span>]<br>            y := times[i][<span class=\"hljs-number\">1</span>]<br>            z := times[i][<span class=\"hljs-number\">2</span>]<br><br>            <span class=\"hljs-keyword\">if</span> dist[y] &gt; dist[x] + z &#123;<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;x: %v, y: %v, z: %v\\n&quot;, x, y, z)</span><br>                dist[y] = dist[x] + z<br>                <span class=\"hljs-comment\">// fmt.Printf(&quot;dist[x]: %v, dist[y]: %v\\n&quot;,dist[x], dist[y])</span><br>                flag = <span class=\"hljs-literal\">true</span><br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> !flag &#123;<br>            <span class=\"hljs-keyword\">break</span><br>        &#125;<br>    &#125;<br><br>    ans := <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(dist); i++ &#123;<br>        <span class=\"hljs-keyword\">if</span> dist[i] == inf &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> ans &lt; dist[i] &#123;<br>            ans = dist[i]<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"8.字符串转换整数 (atoi)","category_bar":true,"date":"2021-09-29T16:00:00.000Z","_content":"\n自动机\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc myAtoi(s string) int {\n\t// start signed number end\n\tconst MinInt32, MaxInt32 = -1 << 31, 1<<31 - 1\n\tstates := map[string][]string{\n\t\t\"start\":  {\"start\", \"signed\", \"number\", \"end\"},\n\t\t\"signed\": {\"end\", \"end\", \"number\", \"end\"},\n\t\t\"number\": {\"end\", \"end\", \"number\", \"end\"},\n\t\t\"end\":    {\"end\", \"end\", \"end\", \"end\"},\n\t}\n\n\tstate := \"start\"\n\tans := 0\n\tsign := 1\n\n\tfor i := 0; i < len(s); i++ {\n\t\tindex := get_state(s, i)\n        curr := states[state][index]\n\n\t\t//fmt.Printf(\"state: %v\\n\", state)\n\t\t//fmt.Printf(\"curr: %v\\n\", curr)\n\t\tswitch curr {\n\t\tcase \"end\":\n\t\t\t//fmt.Printf(\"ans: %v\\n\", ans)\n\t\t\t//fmt.Printf(\"sign: %v\\n\", sign)\n\t\t\treturn ans * sign\n\t\tcase \"number\":\n\t\t\tans = ans*10 + int(s[i]) - 48\n\t\t\tif ans * sign >= MaxInt32 {\n\t\t\t\treturn MaxInt32\n\t\t\t}\n\t\t\tif ans * sign <= MinInt32 {\n\t\t\t\treturn MinInt32\n\t\t\t}\n\t\tcase \"signed\":\n\t\t\tif s[i] == '-' {\n\t\t\t\tsign = -1\n\t\t\t}\n\t\t}\n\n        state = curr\n\n\t}\n\n\treturn ans * sign\n}\n\nfunc get_state(s string, i int) int {\n\tswitch {\n\tcase s[i] == ' ':\n\t\treturn 0\n\tcase s[i] == '+' || s[i] == '-':\n\t\treturn 1\n\tcase s[i] >= '0' && s[i] <= '9':\n\t\treturn 2\n\t}\n\treturn 3\n}\n```\n","source":"_posts/算法/leetcode/8.字符串转换整数 (atoi).md","raw":"---\ntitle: 8.字符串转换整数 (atoi)\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-30 00:00:00\ntags:\n---\n\n自动机\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n<!-- more -->\n```Go\nfunc myAtoi(s string) int {\n\t// start signed number end\n\tconst MinInt32, MaxInt32 = -1 << 31, 1<<31 - 1\n\tstates := map[string][]string{\n\t\t\"start\":  {\"start\", \"signed\", \"number\", \"end\"},\n\t\t\"signed\": {\"end\", \"end\", \"number\", \"end\"},\n\t\t\"number\": {\"end\", \"end\", \"number\", \"end\"},\n\t\t\"end\":    {\"end\", \"end\", \"end\", \"end\"},\n\t}\n\n\tstate := \"start\"\n\tans := 0\n\tsign := 1\n\n\tfor i := 0; i < len(s); i++ {\n\t\tindex := get_state(s, i)\n        curr := states[state][index]\n\n\t\t//fmt.Printf(\"state: %v\\n\", state)\n\t\t//fmt.Printf(\"curr: %v\\n\", curr)\n\t\tswitch curr {\n\t\tcase \"end\":\n\t\t\t//fmt.Printf(\"ans: %v\\n\", ans)\n\t\t\t//fmt.Printf(\"sign: %v\\n\", sign)\n\t\t\treturn ans * sign\n\t\tcase \"number\":\n\t\t\tans = ans*10 + int(s[i]) - 48\n\t\t\tif ans * sign >= MaxInt32 {\n\t\t\t\treturn MaxInt32\n\t\t\t}\n\t\t\tif ans * sign <= MinInt32 {\n\t\t\t\treturn MinInt32\n\t\t\t}\n\t\tcase \"signed\":\n\t\t\tif s[i] == '-' {\n\t\t\t\tsign = -1\n\t\t\t}\n\t\t}\n\n        state = curr\n\n\t}\n\n\treturn ans * sign\n}\n\nfunc get_state(s string, i int) int {\n\tswitch {\n\tcase s[i] == ' ':\n\t\treturn 0\n\tcase s[i] == '+' || s[i] == '-':\n\t\treturn 1\n\tcase s[i] >= '0' && s[i] <= '9':\n\t\treturn 2\n\t}\n\treturn 3\n}\n```\n","slug":"leetcode/8.字符串转换整数 (atoi)","published":1,"category":"算法","updated":"2022-11-01T02:35:52.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg2002t0k4lexaihbcx","content":"<p>自动机</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(1)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">myAtoi</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// start signed number end</span><br>\t<span class=\"hljs-keyword\">const</span> MinInt32, MaxInt32 = <span class=\"hljs-number\">-1</span> &lt;&lt; <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">31</span> - <span class=\"hljs-number\">1</span><br>\tstates := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>][]<span class=\"hljs-type\">string</span>&#123;<br>\t\t<span class=\"hljs-string\">&quot;start&quot;</span>:  &#123;<span class=\"hljs-string\">&quot;start&quot;</span>, <span class=\"hljs-string\">&quot;signed&quot;</span>, <span class=\"hljs-string\">&quot;number&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>&#125;,<br>\t\t<span class=\"hljs-string\">&quot;signed&quot;</span>: &#123;<span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;number&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>&#125;,<br>\t\t<span class=\"hljs-string\">&quot;number&quot;</span>: &#123;<span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;number&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>&#125;,<br>\t\t<span class=\"hljs-string\">&quot;end&quot;</span>:    &#123;<span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>&#125;,<br>\t&#125;<br><br>\tstate := <span class=\"hljs-string\">&quot;start&quot;</span><br>\tans := <span class=\"hljs-number\">0</span><br>\tsign := <span class=\"hljs-number\">1</span><br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\tindex := get_state(s, i)<br>        curr := states[state][index]<br><br>\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;state: %v\\n&quot;, state)</span><br>\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;curr: %v\\n&quot;, curr)</span><br>\t\t<span class=\"hljs-keyword\">switch</span> curr &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;end&quot;</span>:<br>\t\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;ans: %v\\n&quot;, ans)</span><br>\t\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;sign: %v\\n&quot;, sign)</span><br>\t\t\t<span class=\"hljs-keyword\">return</span> ans * sign<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;number&quot;</span>:<br>\t\t\tans = ans*<span class=\"hljs-number\">10</span> + <span class=\"hljs-type\">int</span>(s[i]) - <span class=\"hljs-number\">48</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> ans * sign &gt;= MaxInt32 &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> MaxInt32<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> ans * sign &lt;= MinInt32 &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> MinInt32<br>\t\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;signed&quot;</span>:<br>\t\t\t<span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27;-&#x27;</span> &#123;<br>\t\t\t\tsign = <span class=\"hljs-number\">-1</span><br>\t\t\t&#125;<br>\t\t&#125;<br><br>        state = curr<br><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> ans * sign<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">get_state</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, i <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">switch</span> &#123;<br>\t<span class=\"hljs-keyword\">case</span> s[i] == <span class=\"hljs-string\">&#x27; &#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">case</span> s[i] == <span class=\"hljs-string\">&#x27;+&#x27;</span> || s[i] == <span class=\"hljs-string\">&#x27;-&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">case</span> s[i] &gt;= <span class=\"hljs-string\">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class=\"hljs-string\">&#x27;9&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span><br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1443,"excerpt":"<p>自动机</p>\n<p>时间复杂度：O(N)<br>空间复杂度：O(1)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">myAtoi</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// start signed number end</span><br>\t<span class=\"hljs-keyword\">const</span> MinInt32, MaxInt32 = <span class=\"hljs-number\">-1</span> &lt;&lt; <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">31</span> - <span class=\"hljs-number\">1</span><br>\tstates := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>][]<span class=\"hljs-type\">string</span>&#123;<br>\t\t<span class=\"hljs-string\">&quot;start&quot;</span>:  &#123;<span class=\"hljs-string\">&quot;start&quot;</span>, <span class=\"hljs-string\">&quot;signed&quot;</span>, <span class=\"hljs-string\">&quot;number&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>&#125;,<br>\t\t<span class=\"hljs-string\">&quot;signed&quot;</span>: &#123;<span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;number&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>&#125;,<br>\t\t<span class=\"hljs-string\">&quot;number&quot;</span>: &#123;<span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;number&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>&#125;,<br>\t\t<span class=\"hljs-string\">&quot;end&quot;</span>:    &#123;<span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-string\">&quot;end&quot;</span>&#125;,<br>\t&#125;<br><br>\tstate := <span class=\"hljs-string\">&quot;start&quot;</span><br>\tans := <span class=\"hljs-number\">0</span><br>\tsign := <span class=\"hljs-number\">1</span><br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\tindex := get_state(s, i)<br>        curr := states[state][index]<br><br>\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;state: %v\\n&quot;, state)</span><br>\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;curr: %v\\n&quot;, curr)</span><br>\t\t<span class=\"hljs-keyword\">switch</span> curr &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;end&quot;</span>:<br>\t\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;ans: %v\\n&quot;, ans)</span><br>\t\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;sign: %v\\n&quot;, sign)</span><br>\t\t\t<span class=\"hljs-keyword\">return</span> ans * sign<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;number&quot;</span>:<br>\t\t\tans = ans*<span class=\"hljs-number\">10</span> + <span class=\"hljs-type\">int</span>(s[i]) - <span class=\"hljs-number\">48</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> ans * sign &gt;= MaxInt32 &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> MaxInt32<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> ans * sign &lt;= MinInt32 &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> MinInt32<br>\t\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;signed&quot;</span>:<br>\t\t\t<span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27;-&#x27;</span> &#123;<br>\t\t\t\tsign = <span class=\"hljs-number\">-1</span><br>\t\t\t&#125;<br>\t\t&#125;<br><br>        state = curr<br><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> ans * sign<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">get_state</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, i <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">switch</span> &#123;<br>\t<span class=\"hljs-keyword\">case</span> s[i] == <span class=\"hljs-string\">&#x27; &#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">case</span> s[i] == <span class=\"hljs-string\">&#x27;+&#x27;</span> || s[i] == <span class=\"hljs-string\">&#x27;-&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">case</span> s[i] &gt;= <span class=\"hljs-string\">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class=\"hljs-string\">&#x27;9&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span><br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"918.环形子数组的最大和","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n分为两种情况，最大子数组在中间和最大子数组分散在两边。\n\n通过计算最大子数组和和最小子数组和来求解。\n\n时间复杂度：O(N)\n空间复杂度： O(1)\n\n<!-- more -->\n```Go\nfunc maxSubarraySumCircular(nums []int) int {\n    total := nums[0]\n    currMax := nums[0]\n    currMin := nums[0]\n    sumMax := nums[0]\n    sumMin := nums[0]\n\n   for i := 1; i < len(nums); i++ {\n        total += nums[i]\n        currMax = max(currMax+nums[i], nums[i])\n        sumMax  = max(sumMax, currMax)\n        currMin = min(currMin+nums[i], nums[i])\n        sumMin  = min(sumMin, currMin)\n    }\n\n\t// 特殊情况，值全为负数，最大和就是空数组，不符合题意，要特殊处理\n    if sumMin == total {\n        return sumMax\n    } else {\n        return max(total-sumMin, sumMax)\n    }\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n","source":"_posts/算法/leetcode/918.环形子数组的最大和.md","raw":"---\ntitle: 918.环形子数组的最大和\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n分为两种情况，最大子数组在中间和最大子数组分散在两边。\n\n通过计算最大子数组和和最小子数组和来求解。\n\n时间复杂度：O(N)\n空间复杂度： O(1)\n\n<!-- more -->\n```Go\nfunc maxSubarraySumCircular(nums []int) int {\n    total := nums[0]\n    currMax := nums[0]\n    currMin := nums[0]\n    sumMax := nums[0]\n    sumMin := nums[0]\n\n   for i := 1; i < len(nums); i++ {\n        total += nums[i]\n        currMax = max(currMax+nums[i], nums[i])\n        sumMax  = max(sumMax, currMax)\n        currMin = min(currMin+nums[i], nums[i])\n        sumMin  = min(sumMin, currMin)\n    }\n\n\t// 特殊情况，值全为负数，最大和就是空数组，不符合题意，要特殊处理\n    if sumMin == total {\n        return sumMax\n    } else {\n        return max(total-sumMin, sumMax)\n    }\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n","slug":"leetcode/918.环形子数组的最大和","published":1,"category":"算法","updated":"2022-11-01T02:33:31.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg3002v0k4l7zezeukg","content":"<p>分为两种情况，最大子数组在中间和最大子数组分散在两边。</p>\n<p>通过计算最大子数组和和最小子数组和来求解。</p>\n<p>时间复杂度：O(N)<br>空间复杂度： O(1)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxSubarraySumCircular</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    total := nums[<span class=\"hljs-number\">0</span>]<br>    currMax := nums[<span class=\"hljs-number\">0</span>]<br>    currMin := nums[<span class=\"hljs-number\">0</span>]<br>    sumMax := nums[<span class=\"hljs-number\">0</span>]<br>    sumMin := nums[<span class=\"hljs-number\">0</span>]<br><br>   <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        total += nums[i]<br>        currMax = max(currMax+nums[i], nums[i])<br>        sumMax  = max(sumMax, currMax)<br>        currMin = min(currMin+nums[i], nums[i])<br>        sumMin  = min(sumMin, currMin)<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 特殊情况，值全为负数，最大和就是空数组，不符合题意，要特殊处理</span><br>    <span class=\"hljs-keyword\">if</span> sumMin == total &#123;<br>        <span class=\"hljs-keyword\">return</span> sumMax<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> max(total-sumMin, sumMax)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":681,"excerpt":"<p>分为两种情况，最大子数组在中间和最大子数组分散在两边。</p>\n<p>通过计算最大子数组和和最小子数组和来求解。</p>\n<p>时间复杂度：O(N)<br>空间复杂度： O(1)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxSubarraySumCircular</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    total := nums[<span class=\"hljs-number\">0</span>]<br>    currMax := nums[<span class=\"hljs-number\">0</span>]<br>    currMin := nums[<span class=\"hljs-number\">0</span>]<br>    sumMax := nums[<span class=\"hljs-number\">0</span>]<br>    sumMin := nums[<span class=\"hljs-number\">0</span>]<br><br>   <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>        total += nums[i]<br>        currMax = max(currMax+nums[i], nums[i])<br>        sumMax  = max(sumMax, currMax)<br>        currMin = min(currMin+nums[i], nums[i])<br>        sumMin  = min(sumMin, currMin)<br>    &#125;<br><br>\t<span class=\"hljs-comment\">// 特殊情况，值全为负数，最大和就是空数组，不符合题意，要特殊处理</span><br>    <span class=\"hljs-keyword\">if</span> sumMin == total &#123;<br>        <span class=\"hljs-keyword\">return</span> sumMax<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> max(total-sumMin, sumMax)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> a<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"98.验证二叉搜索树","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode.cn/problems/validate-binary-search-tree/submissions/)\n\n递归实现\n<!-- more -->\n```Go\nfunc isValidBST(root *TreeNode) bool {\n\treturn dfs(root, math.MinInt64, math.MaxInt64)\n}\n\nfunc dfs(root *TreeNode, min int, max int) bool {\n\tif root == nil {\n\t\treturn true\n\t}\n\n\t// 注意和上下边界相等的情况应该返回false\n\tif root.Val >= max || root.Val <= min {\n\t\treturn false\n\t}\n\t\n\treturn dfs(root.Left, min, root.Val) && dfs(root.Right, root.Val, max)\n}\n```\n","source":"_posts/算法/leetcode/98.验证二叉搜索树.md","raw":"---\ntitle: 98.验证二叉搜索树\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode.cn/problems/validate-binary-search-tree/submissions/)\n\n递归实现\n<!-- more -->\n```Go\nfunc isValidBST(root *TreeNode) bool {\n\treturn dfs(root, math.MinInt64, math.MaxInt64)\n}\n\nfunc dfs(root *TreeNode, min int, max int) bool {\n\tif root == nil {\n\t\treturn true\n\t}\n\n\t// 注意和上下边界相等的情况应该返回false\n\tif root.Val >= max || root.Val <= min {\n\t\treturn false\n\t}\n\t\n\treturn dfs(root.Left, min, root.Val) && dfs(root.Right, root.Val, max)\n}\n```\n","slug":"leetcode/98.验证二叉搜索树","published":1,"category":"算法","updated":"2022-11-01T02:33:31.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg3002x0k4l8w8vfy2d","content":"<p><a href=\"https://leetcode.cn/problems/validate-binary-search-tree/submissions/\">leetcode</a></p>\n<p>递归实现</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isValidBST</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> dfs(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(root *TreeNode, min <span class=\"hljs-type\">int</span>, max <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 注意和上下边界相等的情况应该返回false</span><br>\t<span class=\"hljs-keyword\">if</span> root.Val &gt;= max || root.Val &lt;= min &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> dfs(root.Left, min, root.Val) &amp;&amp; dfs(root.Right, root.Val, max)<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":361,"excerpt":"<p><a href=\"https://leetcode.cn/problems/validate-binary-search-tree/submissions/\">leetcode</a></p>\n<p>递归实现</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isValidBST</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> dfs(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(root *TreeNode, min <span class=\"hljs-type\">int</span>, max <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 注意和上下边界相等的情况应该返回false</span><br>\t<span class=\"hljs-keyword\">if</span> root.Val &gt;= max || root.Val &lt;= min &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> dfs(root.Left, min, root.Val) &amp;&amp; dfs(root.Right, root.Val, max)<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"17.电话号码的字母组合","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n[leetcode](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)\n\n深度优先遍历，注意这里每次选取数字必定会选取一个对应字母，不存在不选的情况。\n\n时间复杂度：O(3^m x 4^n)\n空间复杂度：O(m+n)\n<!-- more -->\n```Go\nfunc letterCombinations(digits string) []string {\n    if digits == \"\" {\n        return []string{}\n    }\n\n    letterMap := map[string][]string{\n        \"2\": {\"a\", \"b\", \"c\"},\n        \"3\": {\"d\", \"e\", \"f\"},\n        \"4\": {\"g\", \"h\", \"i\"},\n        \"5\": {\"j\", \"k\", \"l\"},\n        \"6\": {\"m\", \"n\", \"o\"},\n        \"7\": {\"p\", \"q\", \"r\", \"s\"},\n        \"8\": {\"t\", \"u\", \"v\"},\n        \"9\": {\"w\", \"x\", \"y\", \"z\"},\n    }\n\n    cur := \"\"\n    results := []string{}\n    var dfs func(int)\n\n    dfs = func(i int) {\n        if i == len(digits) {\n            results = append(results, cur)\n            return\n        }\n\n        d := string(digits[i])\n        letters := letterMap[d]\n\n        for _, l := range letters {\n            cur = cur + l\n            dfs(i + 1)\n            cur = string(cur[:len(cur) - 1])\n        }\n    }\n\n    dfs(0)\n\n    return results\n}\n```\n","source":"_posts/算法/leetcode/17.电话号码的字母组合.md","raw":"---\ntitle: 17.电话号码的字母组合\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n[leetcode](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)\n\n深度优先遍历，注意这里每次选取数字必定会选取一个对应字母，不存在不选的情况。\n\n时间复杂度：O(3^m x 4^n)\n空间复杂度：O(m+n)\n<!-- more -->\n```Go\nfunc letterCombinations(digits string) []string {\n    if digits == \"\" {\n        return []string{}\n    }\n\n    letterMap := map[string][]string{\n        \"2\": {\"a\", \"b\", \"c\"},\n        \"3\": {\"d\", \"e\", \"f\"},\n        \"4\": {\"g\", \"h\", \"i\"},\n        \"5\": {\"j\", \"k\", \"l\"},\n        \"6\": {\"m\", \"n\", \"o\"},\n        \"7\": {\"p\", \"q\", \"r\", \"s\"},\n        \"8\": {\"t\", \"u\", \"v\"},\n        \"9\": {\"w\", \"x\", \"y\", \"z\"},\n    }\n\n    cur := \"\"\n    results := []string{}\n    var dfs func(int)\n\n    dfs = func(i int) {\n        if i == len(digits) {\n            results = append(results, cur)\n            return\n        }\n\n        d := string(digits[i])\n        letters := letterMap[d]\n\n        for _, l := range letters {\n            cur = cur + l\n            dfs(i + 1)\n            cur = string(cur[:len(cur) - 1])\n        }\n    }\n\n    dfs(0)\n\n    return results\n}\n```\n","slug":"leetcode/17.电话号码的字母组合","published":1,"category":"算法","updated":"2022-11-01T02:33:31.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg3002z0k4l7411ab0c","content":"<p><a href=\"https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/\">leetcode</a></p>\n<p>深度优先遍历，注意这里每次选取数字必定会选取一个对应字母，不存在不选的情况。</p>\n<p>时间复杂度：O(3^m x 4^n)<br>空间复杂度：O(m+n)</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">letterCombinations</span><span class=\"hljs-params\">(digits <span class=\"hljs-type\">string</span>)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> digits == <span class=\"hljs-string\">&quot;&quot;</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">string</span>&#123;&#125;<br>    &#125;<br><br>    letterMap := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>][]<span class=\"hljs-type\">string</span>&#123;<br>        <span class=\"hljs-string\">&quot;2&quot;</span>: &#123;<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;c&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;3&quot;</span>: &#123;<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;e&quot;</span>, <span class=\"hljs-string\">&quot;f&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;4&quot;</span>: &#123;<span class=\"hljs-string\">&quot;g&quot;</span>, <span class=\"hljs-string\">&quot;h&quot;</span>, <span class=\"hljs-string\">&quot;i&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;5&quot;</span>: &#123;<span class=\"hljs-string\">&quot;j&quot;</span>, <span class=\"hljs-string\">&quot;k&quot;</span>, <span class=\"hljs-string\">&quot;l&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;6&quot;</span>: &#123;<span class=\"hljs-string\">&quot;m&quot;</span>, <span class=\"hljs-string\">&quot;n&quot;</span>, <span class=\"hljs-string\">&quot;o&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;7&quot;</span>: &#123;<span class=\"hljs-string\">&quot;p&quot;</span>, <span class=\"hljs-string\">&quot;q&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>, <span class=\"hljs-string\">&quot;s&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;8&quot;</span>: &#123;<span class=\"hljs-string\">&quot;t&quot;</span>, <span class=\"hljs-string\">&quot;u&quot;</span>, <span class=\"hljs-string\">&quot;v&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;9&quot;</span>: &#123;<span class=\"hljs-string\">&quot;w&quot;</span>, <span class=\"hljs-string\">&quot;x&quot;</span>, <span class=\"hljs-string\">&quot;y&quot;</span>, <span class=\"hljs-string\">&quot;z&quot;</span>&#125;,<br>    &#125;<br><br>    cur := <span class=\"hljs-string\">&quot;&quot;</span><br>    results := []<span class=\"hljs-type\">string</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-built_in\">len</span>(digits) &#123;<br>            results = <span class=\"hljs-built_in\">append</span>(results, cur)<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        d := <span class=\"hljs-type\">string</span>(digits[i])<br>        letters := letterMap[d]<br><br>        <span class=\"hljs-keyword\">for</span> _, l := <span class=\"hljs-keyword\">range</span> letters &#123;<br>            cur = cur + l<br>            dfs(i + <span class=\"hljs-number\">1</span>)<br>            cur = <span class=\"hljs-type\">string</span>(cur[:<span class=\"hljs-built_in\">len</span>(cur) - <span class=\"hljs-number\">1</span>])<br>        &#125;<br>    &#125;<br><br>    dfs(<span class=\"hljs-number\">0</span>)<br><br>    <span class=\"hljs-keyword\">return</span> results<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1160,"excerpt":"<p><a href=\"https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/\">leetcode</a></p>\n<p>深度优先遍历，注意这里每次选取数字必定会选取一个对应字母，不存在不选的情况。</p>\n<p>时间复杂度：O(3^m x 4^n)<br>空间复杂度：O(m+n)</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">letterCombinations</span><span class=\"hljs-params\">(digits <span class=\"hljs-type\">string</span>)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> digits == <span class=\"hljs-string\">&quot;&quot;</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">string</span>&#123;&#125;<br>    &#125;<br><br>    letterMap := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>][]<span class=\"hljs-type\">string</span>&#123;<br>        <span class=\"hljs-string\">&quot;2&quot;</span>: &#123;<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;c&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;3&quot;</span>: &#123;<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;e&quot;</span>, <span class=\"hljs-string\">&quot;f&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;4&quot;</span>: &#123;<span class=\"hljs-string\">&quot;g&quot;</span>, <span class=\"hljs-string\">&quot;h&quot;</span>, <span class=\"hljs-string\">&quot;i&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;5&quot;</span>: &#123;<span class=\"hljs-string\">&quot;j&quot;</span>, <span class=\"hljs-string\">&quot;k&quot;</span>, <span class=\"hljs-string\">&quot;l&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;6&quot;</span>: &#123;<span class=\"hljs-string\">&quot;m&quot;</span>, <span class=\"hljs-string\">&quot;n&quot;</span>, <span class=\"hljs-string\">&quot;o&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;7&quot;</span>: &#123;<span class=\"hljs-string\">&quot;p&quot;</span>, <span class=\"hljs-string\">&quot;q&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>, <span class=\"hljs-string\">&quot;s&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;8&quot;</span>: &#123;<span class=\"hljs-string\">&quot;t&quot;</span>, <span class=\"hljs-string\">&quot;u&quot;</span>, <span class=\"hljs-string\">&quot;v&quot;</span>&#125;,<br>        <span class=\"hljs-string\">&quot;9&quot;</span>: &#123;<span class=\"hljs-string\">&quot;w&quot;</span>, <span class=\"hljs-string\">&quot;x&quot;</span>, <span class=\"hljs-string\">&quot;y&quot;</span>, <span class=\"hljs-string\">&quot;z&quot;</span>&#125;,<br>    &#125;<br><br>    cur := <span class=\"hljs-string\">&quot;&quot;</span><br>    results := []<span class=\"hljs-type\">string</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">var</span> dfs <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br><br>    dfs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>        <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-built_in\">len</span>(digits) &#123;<br>            results = <span class=\"hljs-built_in\">append</span>(results, cur)<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        d := <span class=\"hljs-type\">string</span>(digits[i])<br>        letters := letterMap[d]<br><br>        <span class=\"hljs-keyword\">for</span> _, l := <span class=\"hljs-keyword\">range</span> letters &#123;<br>            cur = cur + l<br>            dfs(i + <span class=\"hljs-number\">1</span>)<br>            cur = <span class=\"hljs-type\">string</span>(cur[:<span class=\"hljs-built_in\">len</span>(cur) - <span class=\"hljs-number\">1</span>])<br>        &#125;<br>    &#125;<br><br>    dfs(<span class=\"hljs-number\">0</span>)<br><br>    <span class=\"hljs-keyword\">return</span> results<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"18.四数之和","category_bar":true,"date":"2021-09-19T16:00:00.000Z","_content":"\n排序+双指针，注意剪枝的几种情况。\n\n1. 最小四个数比target大\n2. 选择的前两个数遇到重复数字时\n3. 剩下两数最大比 `target-preSum` 小或者最小比 `target-preSum` 大（也可以不判断）\n4. 剩下两数遇到重复数字时\n\n时间复杂度：O(n^3)\n空间复杂度：O(logN)，快排的递归深度\n<!-- more -->\n```Go\nfunc fourSum(nums []int, target int) [][]int {\n    sort.Ints(nums)\n    n := len(nums)\n    ans := [][]int{}\n\n    // 挑选第一个数\n    for i := 0; i < n - 3; i++ {\n        // 最小四个数比target还大，剪枝\n        if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target{\n            continue\n        }\n\n        // 重复数字跳过\n        if i > 0 && nums[i] == nums[i-1]{\n            continue\n        }\n\n        // 挑选第二个数\n        for j := i + 1; j < n - 2; j++{\n            preSum := nums[i] + nums[j]\n\n            // 重复数字跳过，从第i+2个数字开始\n            if j > i + 1 && nums[j] == nums[j-1]{\n                continue\n            }\n\n            // 剩下求两数之和\n            l, r := j + 1, n - 1\n            // 最大两数和比target小，剪枝\n            if preSum + nums[r] + nums[r-1] < target{\n                continue\n            }\n            // 最小两数和比target大，剪枝\n            if preSum + nums[l] + nums[l+1] > target{\n                continue\n            }\n\n            for l < r {\n                if preSum + nums[l] + nums[r] == target {\n                    ans = append(ans, []int{nums[i], nums[j], nums[l], nums[r]})\n                    for l < r {\n                        l++\n                        // 当前数字和前一个数字不同则停止右移\n                        if nums[l-1] != nums[l] {\n                            break\n                        }\n                    }\n                    for l < r  {\n                        r--\n                        // 当前数字和前一个数字不同则停止左移\n                        if nums[r+1] != nums[j] {\n                            break\n                        }\n                    }\n                }\n                if preSum + nums[l] + nums[r] < target{\n                    l++\n                }\n                if preSum + nums[l] + nums[r] > target{\n                    r--\n                }\n            }\n        }\n    }\n\n    return ans\n}\n```\n\n\n","source":"_posts/算法/leetcode/18.四数之和.md","raw":"---\ntitle: 18.四数之和\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-09-20 00:00:00\ntags:\n---\n\n排序+双指针，注意剪枝的几种情况。\n\n1. 最小四个数比target大\n2. 选择的前两个数遇到重复数字时\n3. 剩下两数最大比 `target-preSum` 小或者最小比 `target-preSum` 大（也可以不判断）\n4. 剩下两数遇到重复数字时\n\n时间复杂度：O(n^3)\n空间复杂度：O(logN)，快排的递归深度\n<!-- more -->\n```Go\nfunc fourSum(nums []int, target int) [][]int {\n    sort.Ints(nums)\n    n := len(nums)\n    ans := [][]int{}\n\n    // 挑选第一个数\n    for i := 0; i < n - 3; i++ {\n        // 最小四个数比target还大，剪枝\n        if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target{\n            continue\n        }\n\n        // 重复数字跳过\n        if i > 0 && nums[i] == nums[i-1]{\n            continue\n        }\n\n        // 挑选第二个数\n        for j := i + 1; j < n - 2; j++{\n            preSum := nums[i] + nums[j]\n\n            // 重复数字跳过，从第i+2个数字开始\n            if j > i + 1 && nums[j] == nums[j-1]{\n                continue\n            }\n\n            // 剩下求两数之和\n            l, r := j + 1, n - 1\n            // 最大两数和比target小，剪枝\n            if preSum + nums[r] + nums[r-1] < target{\n                continue\n            }\n            // 最小两数和比target大，剪枝\n            if preSum + nums[l] + nums[l+1] > target{\n                continue\n            }\n\n            for l < r {\n                if preSum + nums[l] + nums[r] == target {\n                    ans = append(ans, []int{nums[i], nums[j], nums[l], nums[r]})\n                    for l < r {\n                        l++\n                        // 当前数字和前一个数字不同则停止右移\n                        if nums[l-1] != nums[l] {\n                            break\n                        }\n                    }\n                    for l < r  {\n                        r--\n                        // 当前数字和前一个数字不同则停止左移\n                        if nums[r+1] != nums[j] {\n                            break\n                        }\n                    }\n                }\n                if preSum + nums[l] + nums[r] < target{\n                    l++\n                }\n                if preSum + nums[l] + nums[r] > target{\n                    r--\n                }\n            }\n        }\n    }\n\n    return ans\n}\n```\n\n\n","slug":"leetcode/18.四数之和","published":1,"category":"算法","updated":"2022-11-01T02:33:32.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9xltbg400310k4lc63d747z","content":"<p>排序+双指针，注意剪枝的几种情况。</p>\n<ol>\n<li>最小四个数比target大</li>\n<li>选择的前两个数遇到重复数字时</li>\n<li>剩下两数最大比 <code>target-preSum</code> 小或者最小比 <code>target-preSum</code> 大（也可以不判断）</li>\n<li>剩下两数遇到重复数字时</li>\n</ol>\n<p>时间复杂度：O(n^3)<br>空间复杂度：O(logN)，快排的递归深度</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fourSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>    sort.Ints(nums)<br>    n := <span class=\"hljs-built_in\">len</span>(nums)<br>    ans := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-comment\">// 挑选第一个数</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">3</span>; i++ &#123;<br>        <span class=\"hljs-comment\">// 最小四个数比target还大，剪枝</span><br>        <span class=\"hljs-keyword\">if</span> nums[i] + nums[i+<span class=\"hljs-number\">1</span>] + nums[i+<span class=\"hljs-number\">2</span>] + nums[i+<span class=\"hljs-number\">3</span>] &gt; target&#123;<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        <span class=\"hljs-comment\">// 重复数字跳过</span><br>        <span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] == nums[i<span class=\"hljs-number\">-1</span>]&#123;<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        <span class=\"hljs-comment\">// 挑选第二个数</span><br>        <span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; n - <span class=\"hljs-number\">2</span>; j++&#123;<br>            preSum := nums[i] + nums[j]<br><br>            <span class=\"hljs-comment\">// 重复数字跳过，从第i+2个数字开始</span><br>            <span class=\"hljs-keyword\">if</span> j &gt; i + <span class=\"hljs-number\">1</span> &amp;&amp; nums[j] == nums[j<span class=\"hljs-number\">-1</span>]&#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-comment\">// 剩下求两数之和</span><br>            l, r := j + <span class=\"hljs-number\">1</span>, n - <span class=\"hljs-number\">1</span><br>            <span class=\"hljs-comment\">// 最大两数和比target小，剪枝</span><br>            <span class=\"hljs-keyword\">if</span> preSum + nums[r] + nums[r<span class=\"hljs-number\">-1</span>] &lt; target&#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br>            <span class=\"hljs-comment\">// 最小两数和比target大，剪枝</span><br>            <span class=\"hljs-keyword\">if</span> preSum + nums[l] + nums[l+<span class=\"hljs-number\">1</span>] &gt; target&#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">for</span> l &lt; r &#123;<br>                <span class=\"hljs-keyword\">if</span> preSum + nums[l] + nums[r] == target &#123;<br>                    ans = <span class=\"hljs-built_in\">append</span>(ans, []<span class=\"hljs-type\">int</span>&#123;nums[i], nums[j], nums[l], nums[r]&#125;)<br>                    <span class=\"hljs-keyword\">for</span> l &lt; r &#123;<br>                        l++<br>                        <span class=\"hljs-comment\">// 当前数字和前一个数字不同则停止右移</span><br>                        <span class=\"hljs-keyword\">if</span> nums[l<span class=\"hljs-number\">-1</span>] != nums[l] &#123;<br>                            <span class=\"hljs-keyword\">break</span><br>                        &#125;<br>                    &#125;<br>                    <span class=\"hljs-keyword\">for</span> l &lt; r  &#123;<br>                        r--<br>                        <span class=\"hljs-comment\">// 当前数字和前一个数字不同则停止左移</span><br>                        <span class=\"hljs-keyword\">if</span> nums[r+<span class=\"hljs-number\">1</span>] != nums[j] &#123;<br>                            <span class=\"hljs-keyword\">break</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class=\"hljs-keyword\">if</span> preSum + nums[l] + nums[r] &lt; target&#123;<br>                    l++<br>                &#125;<br>                <span class=\"hljs-keyword\">if</span> preSum + nums[l] + nums[r] &gt; target&#123;<br>                    r--<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"wordcount":1262,"excerpt":"<p>排序+双指针，注意剪枝的几种情况。</p>\n<ol>\n<li>最小四个数比target大</li>\n<li>选择的前两个数遇到重复数字时</li>\n<li>剩下两数最大比 <code>target-preSum</code> 小或者最小比 <code>target-preSum</code> 大（也可以不判断）</li>\n<li>剩下两数遇到重复数字时</li>\n</ol>\n<p>时间复杂度：O(n^3)<br>空间复杂度：O(logN)，快排的递归深度</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fourSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>    sort.Ints(nums)<br>    n := <span class=\"hljs-built_in\">len</span>(nums)<br>    ans := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br><br>    <span class=\"hljs-comment\">// 挑选第一个数</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">3</span>; i++ &#123;<br>        <span class=\"hljs-comment\">// 最小四个数比target还大，剪枝</span><br>        <span class=\"hljs-keyword\">if</span> nums[i] + nums[i+<span class=\"hljs-number\">1</span>] + nums[i+<span class=\"hljs-number\">2</span>] + nums[i+<span class=\"hljs-number\">3</span>] &gt; target&#123;<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        <span class=\"hljs-comment\">// 重复数字跳过</span><br>        <span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] == nums[i<span class=\"hljs-number\">-1</span>]&#123;<br>            <span class=\"hljs-keyword\">continue</span><br>        &#125;<br><br>        <span class=\"hljs-comment\">// 挑选第二个数</span><br>        <span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; n - <span class=\"hljs-number\">2</span>; j++&#123;<br>            preSum := nums[i] + nums[j]<br><br>            <span class=\"hljs-comment\">// 重复数字跳过，从第i+2个数字开始</span><br>            <span class=\"hljs-keyword\">if</span> j &gt; i + <span class=\"hljs-number\">1</span> &amp;&amp; nums[j] == nums[j<span class=\"hljs-number\">-1</span>]&#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-comment\">// 剩下求两数之和</span><br>            l, r := j + <span class=\"hljs-number\">1</span>, n - <span class=\"hljs-number\">1</span><br>            <span class=\"hljs-comment\">// 最大两数和比target小，剪枝</span><br>            <span class=\"hljs-keyword\">if</span> preSum + nums[r] + nums[r<span class=\"hljs-number\">-1</span>] &lt; target&#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br>            <span class=\"hljs-comment\">// 最小两数和比target大，剪枝</span><br>            <span class=\"hljs-keyword\">if</span> preSum + nums[l] + nums[l+<span class=\"hljs-number\">1</span>] &gt; target&#123;<br>                <span class=\"hljs-keyword\">continue</span><br>            &#125;<br><br>            <span class=\"hljs-keyword\">for</span> l &lt; r &#123;<br>                <span class=\"hljs-keyword\">if</span> preSum + nums[l] + nums[r] == target &#123;<br>                    ans = <span class=\"hljs-built_in\">append</span>(ans, []<span class=\"hljs-type\">int</span>&#123;nums[i], nums[j], nums[l], nums[r]&#125;)<br>                    <span class=\"hljs-keyword\">for</span> l &lt; r &#123;<br>                        l++<br>                        <span class=\"hljs-comment\">// 当前数字和前一个数字不同则停止右移</span><br>                        <span class=\"hljs-keyword\">if</span> nums[l<span class=\"hljs-number\">-1</span>] != nums[l] &#123;<br>                            <span class=\"hljs-keyword\">break</span><br>                        &#125;<br>                    &#125;<br>                    <span class=\"hljs-keyword\">for</span> l &lt; r  &#123;<br>                        r--<br>                        <span class=\"hljs-comment\">// 当前数字和前一个数字不同则停止左移</span><br>                        <span class=\"hljs-keyword\">if</span> nums[r+<span class=\"hljs-number\">1</span>] != nums[j] &#123;<br>                            <span class=\"hljs-keyword\">break</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class=\"hljs-keyword\">if</span> preSum + nums[l] + nums[r] &lt; target&#123;<br>                    l++<br>                &#125;<br>                <span class=\"hljs-keyword\">if</span> preSum + nums[l] + nums[r] &gt; target&#123;<br>                    r--<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"_content":"","source":"_drafts/ent数据排序mixin.md","raw":"","slug":"ent数据排序mixin","published":0,"date":"2022-11-09T14:31:59.784Z","updated":"2022-11-09T14:31:59.784Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cla9s65sw00005n4lf9u94b0v","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"_content":"","source":"_drafts/Golang性能分析工具pprof.md","raw":"","slug":"Golang性能分析工具pprof","published":0,"date":"2022-11-07T15:11:32.988Z","updated":"2022-11-07T15:11:32.988Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cla9s65sy00015n4l8nmv8rb9","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"212.单词搜索 II","category_bar":true,"date":"2021-11-08T16:00:00.000Z","_content":"\n字典树 + DFS\n\n使用字典树来存储要查找的单词，字典树的节点中记录单词的搜索路径。\n\nDFS每层把字典树节点传入，就只用在当前节点检查相邻单元格是否在字典树节点的子节点中。\n\n<!-- more -->\n\n```Go\ntype Trie struct {\n    Count int\n    Prefix string\n    Edges map[byte]*Trie\n}\n\nfunc (this *Trie) Insert(word string)  {\n    curr := this\n    for i := 0; i < len(word); i++ {\n        next, ok := curr.Edges[word[i]]\n        if !ok {\n            next = &Trie{\n                Count: 0,\n                Prefix: curr.Prefix + string(word[i]),\n                Edges: make(map[byte]*Trie),\n            }\n            curr.Edges[word[i]] = next\n        }\n\n        if i == len(word) - 1 {\n            next.Count++\n        }\n\n        curr = next\n\n    }\n}\n\nfunc findWords(board [][]byte, words []string) []string {\n    m := len(board)\n    n := len(board[0])\n    ans := []string{}\n\n    tire := &Trie{\n        Count: 0,\n        Edges: make(map[byte]*Trie),\n    }\n\n    for i := 0; i < len(words); i++ {\n        tire.Insert(words[i])\n    }\n\n    var search func(int, int, *Trie, [][]bool)\n\n    search = func(i, j int, t *Trie, visited [][]bool) {\n        if i < 0 || i >= m || j < 0 || j >= n || visited[i][j]{\n            return\n        }\n\n        dx := []int{0, 1, -1, 0}\n        dy := []int{1, 0, 0, -1}\n\n        next, ok := t.Edges[board[i][j]]\n        if !ok{\n            return\n        }\n\n        if next.Count > 0 {\n            ans = append(ans, next.Prefix)\n            // 字典树中删除该词\n            next.Count--\n        }\n\n        visited[i][j] = true\n\n        for step := 0; step < 4; step++ {\n            search(i+dy[step], j+dx[step], next, visited)\n        }\n\n        visited[i][j] = false\n    }\n\n    visited := make([][]bool, m)\n\n    for i := 0; i < m; i++ {\n        visited[i] = make([]bool, n)\n    }\n\n    for i, row := range board {\n        for j, _ := range row {\n            search(i, j, tire, visited)\n        }\n    }\n\n    return ans\n}\n```\n","source":"_posts/算法/leetcode/212.单词搜索 II.md","raw":"---\ntitle: 212.单词搜索 II\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-11-09 00:00:00\ntags:\n---\n\n字典树 + DFS\n\n使用字典树来存储要查找的单词，字典树的节点中记录单词的搜索路径。\n\nDFS每层把字典树节点传入，就只用在当前节点检查相邻单元格是否在字典树节点的子节点中。\n\n<!-- more -->\n\n```Go\ntype Trie struct {\n    Count int\n    Prefix string\n    Edges map[byte]*Trie\n}\n\nfunc (this *Trie) Insert(word string)  {\n    curr := this\n    for i := 0; i < len(word); i++ {\n        next, ok := curr.Edges[word[i]]\n        if !ok {\n            next = &Trie{\n                Count: 0,\n                Prefix: curr.Prefix + string(word[i]),\n                Edges: make(map[byte]*Trie),\n            }\n            curr.Edges[word[i]] = next\n        }\n\n        if i == len(word) - 1 {\n            next.Count++\n        }\n\n        curr = next\n\n    }\n}\n\nfunc findWords(board [][]byte, words []string) []string {\n    m := len(board)\n    n := len(board[0])\n    ans := []string{}\n\n    tire := &Trie{\n        Count: 0,\n        Edges: make(map[byte]*Trie),\n    }\n\n    for i := 0; i < len(words); i++ {\n        tire.Insert(words[i])\n    }\n\n    var search func(int, int, *Trie, [][]bool)\n\n    search = func(i, j int, t *Trie, visited [][]bool) {\n        if i < 0 || i >= m || j < 0 || j >= n || visited[i][j]{\n            return\n        }\n\n        dx := []int{0, 1, -1, 0}\n        dy := []int{1, 0, 0, -1}\n\n        next, ok := t.Edges[board[i][j]]\n        if !ok{\n            return\n        }\n\n        if next.Count > 0 {\n            ans = append(ans, next.Prefix)\n            // 字典树中删除该词\n            next.Count--\n        }\n\n        visited[i][j] = true\n\n        for step := 0; step < 4; step++ {\n            search(i+dy[step], j+dx[step], next, visited)\n        }\n\n        visited[i][j] = false\n    }\n\n    visited := make([][]bool, m)\n\n    for i := 0; i < m; i++ {\n        visited[i] = make([]bool, n)\n    }\n\n    for i, row := range board {\n        for j, _ := range row {\n            search(i, j, tire, visited)\n        }\n    }\n\n    return ans\n}\n```\n","slug":"leetcode/212.单词搜索 II","published":1,"category":"算法","updated":"2022-11-09T15:13:01.777Z","_id":"cla9s65sz00025n4l0ebvbeui","comments":1,"layout":"post","photos":[],"link":"","content":"<p>字典树 + DFS</p>\n<p>使用字典树来存储要查找的单词，字典树的节点中记录单词的搜索路径。</p>\n<p>DFS每层把字典树节点传入，就只用在当前节点检查相邻单元格是否在字典树节点的子节点中。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Trie <span class=\"hljs-keyword\">struct</span> &#123;<br>    Count <span class=\"hljs-type\">int</span><br>    Prefix <span class=\"hljs-type\">string</span><br>    Edges <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Trie)</span></span> Insert(word <span class=\"hljs-type\">string</span>)  &#123;<br>    curr := this<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(word); i++ &#123;<br>        next, ok := curr.Edges[word[i]]<br>        <span class=\"hljs-keyword\">if</span> !ok &#123;<br>            next = &amp;Trie&#123;<br>                Count: <span class=\"hljs-number\">0</span>,<br>                Prefix: curr.Prefix + <span class=\"hljs-type\">string</span>(word[i]),<br>                Edges: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie),<br>            &#125;<br>            curr.Edges[word[i]] = next<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-built_in\">len</span>(word) - <span class=\"hljs-number\">1</span> &#123;<br>            next.Count++<br>        &#125;<br><br>        curr = next<br><br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findWords</span><span class=\"hljs-params\">(board [][]<span class=\"hljs-type\">byte</span>, words []<span class=\"hljs-type\">string</span>)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>    m := <span class=\"hljs-built_in\">len</span>(board)<br>    n := <span class=\"hljs-built_in\">len</span>(board[<span class=\"hljs-number\">0</span>])<br>    ans := []<span class=\"hljs-type\">string</span>&#123;&#125;<br><br>    tire := &amp;Trie&#123;<br>        Count: <span class=\"hljs-number\">0</span>,<br>        Edges: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie),<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(words); i++ &#123;<br>        tire.Insert(words[i])<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> search <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, *Trie, [][]<span class=\"hljs-type\">bool</span>)</span></span><br><br>    search = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i, j <span class=\"hljs-type\">int</span>, t *Trie, visited [][]<span class=\"hljs-type\">bool</span>)</span></span> &#123;<br>        <span class=\"hljs-keyword\">if</span> i &lt; <span class=\"hljs-number\">0</span> || i &gt;= m || j &lt; <span class=\"hljs-number\">0</span> || j &gt;= n || visited[i][j]&#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        dx := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>&#125;<br>        dy := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>&#125;<br><br>        next, ok := t.Edges[board[i][j]]<br>        <span class=\"hljs-keyword\">if</span> !ok&#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> next.Count &gt; <span class=\"hljs-number\">0</span> &#123;<br>            ans = <span class=\"hljs-built_in\">append</span>(ans, next.Prefix)<br>            <span class=\"hljs-comment\">// 字典树中删除该词</span><br>            next.Count--<br>        &#125;<br><br>        visited[i][j] = <span class=\"hljs-literal\">true</span><br><br>        <span class=\"hljs-keyword\">for</span> step := <span class=\"hljs-number\">0</span>; step &lt; <span class=\"hljs-number\">4</span>; step++ &#123;<br>            search(i+dy[step], j+dx[step], next, visited)<br>        &#125;<br><br>        visited[i][j] = <span class=\"hljs-literal\">false</span><br>    &#125;<br><br>    visited := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">bool</span>, m)<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; m; i++ &#123;<br>        visited[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, n)<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i, row := <span class=\"hljs-keyword\">range</span> board &#123;<br>        <span class=\"hljs-keyword\">for</span> j, _ := <span class=\"hljs-keyword\">range</span> row &#123;<br>            search(i, j, tire, visited)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1492,"excerpt":"<p>字典树 + DFS</p>\n<p>使用字典树来存储要查找的单词，字典树的节点中记录单词的搜索路径。</p>\n<p>DFS每层把字典树节点传入，就只用在当前节点检查相邻单元格是否在字典树节点的子节点中。</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Trie <span class=\"hljs-keyword\">struct</span> &#123;<br>    Count <span class=\"hljs-type\">int</span><br>    Prefix <span class=\"hljs-type\">string</span><br>    Edges <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Trie)</span></span> Insert(word <span class=\"hljs-type\">string</span>)  &#123;<br>    curr := this<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(word); i++ &#123;<br>        next, ok := curr.Edges[word[i]]<br>        <span class=\"hljs-keyword\">if</span> !ok &#123;<br>            next = &amp;Trie&#123;<br>                Count: <span class=\"hljs-number\">0</span>,<br>                Prefix: curr.Prefix + <span class=\"hljs-type\">string</span>(word[i]),<br>                Edges: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie),<br>            &#125;<br>            curr.Edges[word[i]] = next<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-built_in\">len</span>(word) - <span class=\"hljs-number\">1</span> &#123;<br>            next.Count++<br>        &#125;<br><br>        curr = next<br><br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findWords</span><span class=\"hljs-params\">(board [][]<span class=\"hljs-type\">byte</span>, words []<span class=\"hljs-type\">string</span>)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>    m := <span class=\"hljs-built_in\">len</span>(board)<br>    n := <span class=\"hljs-built_in\">len</span>(board[<span class=\"hljs-number\">0</span>])<br>    ans := []<span class=\"hljs-type\">string</span>&#123;&#125;<br><br>    tire := &amp;Trie&#123;<br>        Count: <span class=\"hljs-number\">0</span>,<br>        Edges: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]*Trie),<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(words); i++ &#123;<br>        tire.Insert(words[i])<br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> search <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, *Trie, [][]<span class=\"hljs-type\">bool</span>)</span></span><br><br>    search = <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i, j <span class=\"hljs-type\">int</span>, t *Trie, visited [][]<span class=\"hljs-type\">bool</span>)</span></span> &#123;<br>        <span class=\"hljs-keyword\">if</span> i &lt; <span class=\"hljs-number\">0</span> || i &gt;= m || j &lt; <span class=\"hljs-number\">0</span> || j &gt;= n || visited[i][j]&#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        dx := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>&#125;<br>        dy := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>&#125;<br><br>        next, ok := t.Edges[board[i][j]]<br>        <span class=\"hljs-keyword\">if</span> !ok&#123;<br>            <span class=\"hljs-keyword\">return</span><br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> next.Count &gt; <span class=\"hljs-number\">0</span> &#123;<br>            ans = <span class=\"hljs-built_in\">append</span>(ans, next.Prefix)<br>            <span class=\"hljs-comment\">// 字典树中删除该词</span><br>            next.Count--<br>        &#125;<br><br>        visited[i][j] = <span class=\"hljs-literal\">true</span><br><br>        <span class=\"hljs-keyword\">for</span> step := <span class=\"hljs-number\">0</span>; step &lt; <span class=\"hljs-number\">4</span>; step++ &#123;<br>            search(i+dy[step], j+dx[step], next, visited)<br>        &#125;<br><br>        visited[i][j] = <span class=\"hljs-literal\">false</span><br>    &#125;<br><br>    visited := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">bool</span>, m)<br><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; m; i++ &#123;<br>        visited[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">bool</span>, n)<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> i, row := <span class=\"hljs-keyword\">range</span> board &#123;<br>        <span class=\"hljs-keyword\">for</span> j, _ := <span class=\"hljs-keyword\">range</span> row &#123;<br>            search(i, j, tire, visited)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"389.找不同","category_bar":true,"date":"2021-11-08T16:00:00.000Z","_content":"\n利用位运算来找不同。\n\n一个数两次异或同一个数就是其本身，所以用一个0分别和 `s` 和 `t` 中每一位异或，得到的结果就是新增加的值。\n\n<!-- more -->\n\n```Go\nfunc findTheDifference(s string, t string) byte {\n    var diff byte\n    for i := 0; i < len(s); i++ {\n        diff ^= s[i]\n        diff ^= t[i]\n    }\n\n    return diff ^ t[len(t) - 1]\n}\n```\n","source":"_posts/算法/leetcode/389.找不同.md","raw":"---\ntitle: 389.找不同\ncategory_bar: true\ncategories:\n  - 算法\n  - leetcode\ndate: 2021-11-09 00:00:00\ntags:\n---\n\n利用位运算来找不同。\n\n一个数两次异或同一个数就是其本身，所以用一个0分别和 `s` 和 `t` 中每一位异或，得到的结果就是新增加的值。\n\n<!-- more -->\n\n```Go\nfunc findTheDifference(s string, t string) byte {\n    var diff byte\n    for i := 0; i < len(s); i++ {\n        diff ^= s[i]\n        diff ^= t[i]\n    }\n\n    return diff ^ t[len(t) - 1]\n}\n```\n","slug":"leetcode/389.找不同","published":1,"category":"算法","updated":"2022-11-09T15:13:01.777Z","_id":"cla9s65sz00035n4lgw5ug7me","comments":1,"layout":"post","photos":[],"link":"","content":"<p>利用位运算来找不同。</p>\n<p>一个数两次异或同一个数就是其本身，所以用一个0分别和 <code>s</code> 和 <code>t</code> 中每一位异或，得到的结果就是新增加的值。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findTheDifference</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, t <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">byte</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> diff <span class=\"hljs-type\">byte</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>        diff ^= s[i]<br>        diff ^= t[i]<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> diff ^ t[<span class=\"hljs-built_in\">len</span>(t) - <span class=\"hljs-number\">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":210,"excerpt":"<p>利用位运算来找不同。</p>\n<p>一个数两次异或同一个数就是其本身，所以用一个0分别和 <code>s</code> 和 <code>t</code> 中每一位异或，得到的结果就是新增加的值。</p>","more":"<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findTheDifference</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, t <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">byte</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> diff <span class=\"hljs-type\">byte</span><br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>        diff ^= s[i]<br>        diff ^= t[i]<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> diff ^ t[<span class=\"hljs-built_in\">len</span>(t) - <span class=\"hljs-number\">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl9xltbfc000g0k4lamic1by3","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfe000l0k4l6y9c6c3n"},{"post_id":"cl9xltbfc000g0k4lamic1by3","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbff000o0k4l2jn50bmr"},{"post_id":"cl9xltbf400070k4ld22hdkho","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfg000q0k4l1icv1s0d"},{"post_id":"cl9xltbf400070k4ld22hdkho","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfh000t0k4l86oi13xo"},{"post_id":"cl9xltbfc000h0k4l709jgp90","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfh000v0k4lduibckz1"},{"post_id":"cl9xltbfc000h0k4l709jgp90","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfi000y0k4lfhxka6e6"},{"post_id":"cl9xltbfd000j0k4l3rin5j9f","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfi00100k4ld2nw0iva"},{"post_id":"cl9xltbfd000j0k4l3rin5j9f","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfj00130k4l4clkgxn8"},{"post_id":"cl9xltbey00030k4ldw2zckm8","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfj00150k4lf9m91o2e"},{"post_id":"cl9xltbey00030k4ldw2zckm8","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfk00180k4l3n77f7c5"},{"post_id":"cl9xltbfe000k0k4l9tx44h4g","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfk001a0k4le22oelu1"},{"post_id":"cl9xltbfe000k0k4l9tx44h4g","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfl001d0k4l47o1b2ob"},{"post_id":"cl9xltbff000n0k4l1pnxbff9","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfn001f0k4lf5ymhcx3"},{"post_id":"cl9xltbff000n0k4l1pnxbff9","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfo001i0k4lghflfx48"},{"post_id":"cl9xltbf500080k4lbjpxdoxi","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfo001k0k4l966pbpan"},{"post_id":"cl9xltbf500080k4lbjpxdoxi","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfp001m0k4l98wq5m22"},{"post_id":"cl9xltbfg000p0k4ld1ft0o0p","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfp001o0k4l1y6o1ld0"},{"post_id":"cl9xltbfg000p0k4ld1ft0o0p","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfq001q0k4lex9a07s7"},{"post_id":"cl9xltbfg000s0k4l99ox1ysk","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfq001s0k4l1q7ud2m8"},{"post_id":"cl9xltbfg000s0k4l99ox1ysk","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfr001u0k4l1ovfa2he"},{"post_id":"cl9xltbf8000a0k4l2dev9pa7","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfr001w0k4lhk6tg8ll"},{"post_id":"cl9xltbf8000a0k4l2dev9pa7","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfs001y0k4lca209coz"},{"post_id":"cl9xltbfh000u0k4l34tx0zqw","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfs00200k4l05ey0hgp"},{"post_id":"cl9xltbfh000u0k4l34tx0zqw","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbft00220k4legivcjht"},{"post_id":"cl9xltbfi000x0k4lcrqj824r","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfu00240k4l5wul8w0b"},{"post_id":"cl9xltbfi000x0k4lcrqj824r","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfv00260k4l08snepas"},{"post_id":"cl9xltbf000040k4l4ttv4698","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfx00280k4l684fcv51"},{"post_id":"cl9xltbf000040k4l4ttv4698","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfy002a0k4l2wimdhma"},{"post_id":"cl9xltbfi000z0k4l1nhd3zex","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbfz002c0k4l1f0m90kl"},{"post_id":"cl9xltbfi000z0k4l1nhd3zex","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbfz002e0k4l1dix1wqd"},{"post_id":"cl9xltbfj00120k4ldrew02wj","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg0002g0k4lb9dyelj0"},{"post_id":"cl9xltbfj00120k4ldrew02wj","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg0002i0k4l70wlc8tt"},{"post_id":"cl9xltbf9000b0k4l9k820dgi","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg1002k0k4l1dw873td"},{"post_id":"cl9xltbf9000b0k4l9k820dgi","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg1002m0k4lfahs51v5"},{"post_id":"cl9xltbfj00140k4l5alf6em6","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg1002o0k4lf1rr8fza"},{"post_id":"cl9xltbfj00140k4l5alf6em6","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg2002q0k4lbxpeauys"},{"post_id":"cl9xltbfk00170k4lc0es21sw","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg2002s0k4l8uvwcqqd"},{"post_id":"cl9xltbfk00170k4lc0es21sw","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg2002u0k4l18hyc6bz"},{"post_id":"cl9xltbfa000d0k4l2ctdaudh","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg3002w0k4le3mr48k3"},{"post_id":"cl9xltbfa000d0k4l2ctdaudh","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg3002y0k4lg6nne7ri"},{"post_id":"cl9xltbfk00190k4l00no69ho","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg400300k4lg7y82qci"},{"post_id":"cl9xltbfk00190k4l00no69ho","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg400320k4lhongd5wy"},{"post_id":"cl9xltbfl001c0k4l8ugd1k0z","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg400330k4l16p0gsxk"},{"post_id":"cl9xltbfl001c0k4l8ugd1k0z","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg400340k4l9z6q6gh6"},{"post_id":"cl9xltbf400060k4l04ec24vy","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg400350k4lfd3ych81"},{"post_id":"cl9xltbf400060k4l04ec24vy","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg500360k4lfk8x7tre"},{"post_id":"cl9xltbfl001e0k4l03091tlr","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg500370k4lar5z45lx"},{"post_id":"cl9xltbfl001e0k4l03091tlr","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg500380k4l4cglgy9s"},{"post_id":"cl9xltbfo001h0k4l4ceab3by","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg500390k4l7nywdfvo"},{"post_id":"cl9xltbfo001h0k4l4ceab3by","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg5003a0k4lhww05jco"},{"post_id":"cl9xltbfb000e0k4l2otp9tzv","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg5003b0k4l7t1h6mqz"},{"post_id":"cl9xltbfb000e0k4l2otp9tzv","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg5003c0k4l8coygf23"},{"post_id":"cl9xltbfo001j0k4l5gqhhzm7","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg5003d0k4l8ueoa5zp"},{"post_id":"cl9xltbfo001j0k4l5gqhhzm7","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg5003e0k4l9pel5q0q"},{"post_id":"cl9xltbfp001l0k4l3q6e08de","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg5003f0k4l54kihfwz"},{"post_id":"cl9xltbfp001l0k4l3q6e08de","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg5003g0k4lc9jjakkf"},{"post_id":"cl9xltbfp001n0k4lhvxpbgy2","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg5003h0k4l7sxz1xzc"},{"post_id":"cl9xltbfp001n0k4lhvxpbgy2","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg5003i0k4lak1b2rvj"},{"post_id":"cl9xltbfp001p0k4l61r775p5","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg5003j0k4lbwd02y5y"},{"post_id":"cl9xltbfp001p0k4l61r775p5","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg5003k0k4l813dfbvl"},{"post_id":"cl9xltbfq001r0k4lakbs9j3f","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg5003l0k4lat21clzu"},{"post_id":"cl9xltbfq001r0k4lakbs9j3f","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg5003m0k4lh8v47tuo"},{"post_id":"cl9xltbfq001t0k4lgvw6cc61","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg5003n0k4l3ydf25jg"},{"post_id":"cl9xltbfq001t0k4lgvw6cc61","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg6003o0k4l4d844v7t"},{"post_id":"cl9xltbfr001v0k4l22dc9ain","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg6003p0k4lavl41xxx"},{"post_id":"cl9xltbfr001v0k4l22dc9ain","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg6003q0k4l0qnhe0xt"},{"post_id":"cl9xltbfr001x0k4l02p11p5p","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg6003r0k4l2nucc2k1"},{"post_id":"cl9xltbfr001x0k4l02p11p5p","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg6003s0k4l8rtggumu"},{"post_id":"cl9xltbfs001z0k4lhiwzfty3","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg6003t0k4l1ghp83f6"},{"post_id":"cl9xltbfs001z0k4lhiwzfty3","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg6003u0k4la5uy8t9e"},{"post_id":"cl9xltbfs00210k4laipc9htu","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg6003v0k4lfklxc7gb"},{"post_id":"cl9xltbfs00210k4laipc9htu","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg6003w0k4l4yvibk8y"},{"post_id":"cl9xltbft00230k4lg6ebhcbk","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg6003x0k4lbux67v6v"},{"post_id":"cl9xltbft00230k4lg6ebhcbk","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg6003y0k4lh9648dj1"},{"post_id":"cl9xltbfu00250k4l91ux3ydc","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg6003z0k4lcgrpayp3"},{"post_id":"cl9xltbfu00250k4l91ux3ydc","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg600400k4l2znd64b5"},{"post_id":"cl9xltbfw00270k4lfags2i8d","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg600410k4l6qxd3k9v"},{"post_id":"cl9xltbfw00270k4lfags2i8d","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg600420k4l2j4w1jnw"},{"post_id":"cl9xltbfx00290k4l6fj12p73","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg600430k4lckrw8e29"},{"post_id":"cl9xltbfx00290k4l6fj12p73","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg600440k4l7gfsd8es"},{"post_id":"cl9xltbfz002b0k4lg23xgr9s","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg600450k4lb29a7rue"},{"post_id":"cl9xltbfz002b0k4lg23xgr9s","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg600460k4lhqxudnsc"},{"post_id":"cl9xltbfz002d0k4l7q1ddf7r","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg600470k4lgrr44le2"},{"post_id":"cl9xltbfz002d0k4l7q1ddf7r","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg600480k4lh2yw44sz"},{"post_id":"cl9xltbfz002f0k4l5afle1ii","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg600490k4l1ap4bpuv"},{"post_id":"cl9xltbfz002f0k4l5afle1ii","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg6004a0k4l3zbc7gr1"},{"post_id":"cl9xltbg0002h0k4l4x9d7oy4","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg6004b0k4lg7fl3xxy"},{"post_id":"cl9xltbg0002h0k4l4x9d7oy4","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004c0k4l6ed4gwvg"},{"post_id":"cl9xltbg0002j0k4lfhtj7odp","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004d0k4ldqeke99t"},{"post_id":"cl9xltbg0002j0k4lfhtj7odp","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004e0k4lhzjt13tm"},{"post_id":"cl9xltbg1002l0k4lhyd3389a","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004f0k4la8o4g9ik"},{"post_id":"cl9xltbg1002l0k4lhyd3389a","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004g0k4l15ni2u13"},{"post_id":"cl9xltbg1002n0k4l6lbhfn98","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004h0k4l1uwldu8i"},{"post_id":"cl9xltbg1002n0k4l6lbhfn98","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004i0k4leyskgex2"},{"post_id":"cl9xltbg1002p0k4l69vkfky0","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004j0k4l81lie3eg"},{"post_id":"cl9xltbg1002p0k4l69vkfky0","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004k0k4l469wf3gt"},{"post_id":"cl9xltbg2002r0k4l0yoya36z","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004l0k4lc1dxdjat"},{"post_id":"cl9xltbg2002r0k4l0yoya36z","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004m0k4l026n7l50"},{"post_id":"cl9xltbg2002t0k4lexaihbcx","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004n0k4l23ljexs5"},{"post_id":"cl9xltbg2002t0k4lexaihbcx","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004o0k4l8yup6vs8"},{"post_id":"cl9xltbg3002v0k4l7zezeukg","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004p0k4lg01628lk"},{"post_id":"cl9xltbg3002v0k4l7zezeukg","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004q0k4l09lsbh6i"},{"post_id":"cl9xltbg3002x0k4l8w8vfy2d","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004r0k4legyhdy5z"},{"post_id":"cl9xltbg3002x0k4l8w8vfy2d","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004s0k4lfgho9kwt"},{"post_id":"cl9xltbg3002z0k4l7411ab0c","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004t0k4laxwgaqtn"},{"post_id":"cl9xltbg3002z0k4l7411ab0c","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004u0k4lcccv4ld7"},{"post_id":"cl9xltbg400310k4lc63d747z","category_id":"cl9xltbf300050k4ldge635he","_id":"cl9xltbg7004v0k4l2qm852mq"},{"post_id":"cl9xltbg400310k4lc63d747z","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cl9xltbg7004w0k4l7eip3a5f"},{"post_id":"cla9s65sz00025n4l0ebvbeui","category_id":"cl9xltbf300050k4ldge635he","_id":"cla9s65t000045n4lcz7l50tu"},{"post_id":"cla9s65sz00035n4lgw5ug7me","category_id":"cl9xltbf300050k4ldge635he","_id":"cla9s65t000055n4l02ox10rm"},{"post_id":"cla9s65sz00025n4l0ebvbeui","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cla9s66r900005q4l29u7caia"},{"post_id":"cla9s65sz00035n4lgw5ug7me","category_id":"cl9xltbfb000f0k4l4v1a1qd8","_id":"cla9s66r900015q4l7miyf5l3"}],"PostTag":[{"post_id":"cl9xltbeg00000k4lgqln2oh4","tag_id":"cl9xltbem00010k4l1jufeq8q","_id":"cl9xltbep00020k4l1jas4sin"}],"Tag":[{"name":"网络","_id":"cl9xltbem00010k4l1jufeq8q"}]}}