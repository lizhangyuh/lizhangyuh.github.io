<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>212.单词搜索 II</title>
    <link href="/2021/11/076d3cc23016.html"/>
    <url>/2021/11/076d3cc23016.html</url>
    
    <content type="html"><![CDATA[<p>字典树 + DFS</p><p>使用字典树来存储要查找的单词，字典树的节点中记录单词的搜索路径。</p><p>DFS每层把字典树节点传入，就只用在当前节点检查相邻单元格是否在字典树节点的子节点中。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br>    Count <span class="hljs-type">int</span><br>    Prefix <span class="hljs-type">string</span><br>    Edges <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]*Trie<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>)  &#123;<br>    curr := this<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(word); i++ &#123;<br>        next, ok := curr.Edges[word[i]]<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            next = &amp;Trie&#123;<br>                Count: <span class="hljs-number">0</span>,<br>                Prefix: curr.Prefix + <span class="hljs-type">string</span>(word[i]),<br>                Edges: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]*Trie),<br>            &#125;<br>            curr.Edges[word[i]] = next<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span> &#123;<br>            next.Count++<br>        &#125;<br><br>        curr = next<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findWords</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, words []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(board)<br>    n := <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>    ans := []<span class="hljs-type">string</span>&#123;&#125;<br><br>    tire := &amp;Trie&#123;<br>        Count: <span class="hljs-number">0</span>,<br>        Edges: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]*Trie),<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(words); i++ &#123;<br>        tire.Insert(words[i])<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> search <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, *Trie, [][]<span class="hljs-type">bool</span>)</span></span><br><br>    search = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>, t *Trie, visited [][]<span class="hljs-type">bool</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n || visited[i][j]&#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        dx := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;<br>        dy := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;<br><br>        next, ok := t.Edges[board[i][j]]<br>        <span class="hljs-keyword">if</span> !ok&#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> next.Count &gt; <span class="hljs-number">0</span> &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, next.Prefix)<br>            <span class="hljs-comment">// 字典树中删除该词</span><br>            next.Count--<br>        &#125;<br><br>        visited[i][j] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-keyword">for</span> step := <span class="hljs-number">0</span>; step &lt; <span class="hljs-number">4</span>; step++ &#123;<br>            search(i+dy[step], j+dx[step], next, visited)<br>        &#125;<br><br>        visited[i][j] = <span class="hljs-literal">false</span><br>    &#125;<br><br>    visited := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, m)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        visited[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> board &#123;<br>        <span class="hljs-keyword">for</span> j, _ := <span class="hljs-keyword">range</span> row &#123;<br>            search(i, j, tire, visited)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>389.找不同</title>
    <link href="/2021/11/85b6a30b99bb.html"/>
    <url>/2021/11/85b6a30b99bb.html</url>
    
    <content type="html"><![CDATA[<p>利用位运算来找不同。</p><p>一个数两次异或同一个数就是其本身，所以用一个0分别和 <code>s</code> 和 <code>t</code> 中每一位异或，得到的结果就是新增加的值。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>    <span class="hljs-keyword">var</span> diff <span class="hljs-type">byte</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        diff ^= s[i]<br>        diff ^= t[i]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> diff ^ t[<span class="hljs-built_in">len</span>(t) - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>120.三角形最小路径和</title>
    <link href="/2021/09/bc68193ce556.html"/>
    <url>/2021/09/bc68193ce556.html</url>
    
    <content type="html"><![CDATA[<p>动态规划+空间优化</p><p>状态转移方程： <code>dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])</code> </p><p>应该记录一个二维数组dp，来维护每个位置的最小路径。但是由于是三角形结构，<code>dp[i][j]</code> 只跟 <code>dp[i-1][j-1]</code> 和 <code>dp[i-1][j]</code> 有关，使用一个一维数组来记录dp，倒序遍历，则计算<br><code>i</code> 行的 <code>dp[j]</code> 时，<code>dp[j-1]</code> 和 <code>dp[j]</code> 还是 <code>i-1</code> 行的数据，并不影响计算。</p><p>时间复杂度： O(n^2)<br>空间复杂度： O(n)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(triangle [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1])</span><br><br>    n := <span class="hljs-built_in">len</span>(triangle)<br><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    &#125;<br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    dp[<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    ans := math.MaxInt<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> &#123;<br>                dp[j] += triangle[i][j]<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> j == i &#123;<br>                dp[j] = triangle[i][i] + dp[j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[j] &lt; dp[j<span class="hljs-number">-1</span>] &#123;<br>                dp[j] = triangle[i][j] + dp[j]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[j] = triangle[i][j] + dp[j<span class="hljs-number">-1</span>]<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> i == n - <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">if</span> dp[j] &lt; ans &#123;<br>                    ans = dp[j]<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>146.LRU缓存</title>
    <link href="/2021/09/cd7daaeb0f4f.html"/>
    <url>/2021/09/cd7daaeb0f4f.html</url>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>  capacity <span class="hljs-type">int</span><br>  size <span class="hljs-type">int</span><br>  hashMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkNode<br>  head, tail *DLinkNode<br>&#125;<br><br><span class="hljs-keyword">type</span> DLinkNode <span class="hljs-keyword">struct</span> &#123;<br>  key, value <span class="hljs-type">int</span><br>  prev *DLinkNode<br>  next *DLinkNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDLinkNode</span><span class="hljs-params">(key, value <span class="hljs-type">int</span>)</span></span> *DLinkNode &#123;<br>  <span class="hljs-keyword">return</span> &amp;DLinkNode&#123;<br>    key: key,<br>    value: value,<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>  head := NewDLinkNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>  tail := NewDLinkNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>  head.next = tail<br>  tail.prev = head<br><br>  <span class="hljs-keyword">return</span> LRUCache&#123;<br>    capacity: capacity, <br>    hashMap: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkNode),<br>    head: head,<br>    tail: tail,<br>    size: <span class="hljs-number">0</span>,<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">if</span> node, ok := this.hashMap[key]; ok &#123;<br>    this.moveToHead(node)<br>    <span class="hljs-keyword">return</span> node.value<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>  node, ok := this.hashMap[key]<br>  <span class="hljs-keyword">if</span> ok &#123;<br>    node.value = value<br>    this.moveToHead(node)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    node = NewDLinkNode(key, value)<br>    this.addToHead(node)<br>    this.size++<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> this.size &gt; this.capacity &#123;<br>    <span class="hljs-built_in">delete</span>(this.hashMap, this.tail.prev.key)<br>    this.removeFromTail()<br>    this.size--<br>  &#125;<br><br>  this.hashMap[key] = node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeNode(node *DLinkNode) &#123;<br>  node.prev.next = node.next<br>  node.next.prev = node.prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> moveToHead(node *DLinkNode) &#123;<br>  this.removeNode(node)<br>  this.addToHead(node)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> addToHead(node *DLinkNode) &#123;<br>  node.prev = this.head<br>  node.next = this.head.next<br>  this.head.next.prev = node<br>  this.head.next = node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeFromTail() &#123;<br>  this.removeNode(this.tail.prev)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(capacity);</span><br><span class="hljs-comment"> * param_1 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> */</span><br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>198.打家劫舍</title>
    <link href="/2021/09/2c885142f785.html"/>
    <url>/2021/09/2c885142f785.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p>考虑当前房屋偷还是不偷。同时当前房屋的状态只与前一间房屋有关，所以可以用滚动数组进行空间优化。</p><p>时间复杂度：O(N)<br>空间复杂度：O(1)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        temp := dp[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">0</span>] = max(dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>])<br>        dp[<span class="hljs-number">1</span>] = temp + nums[i<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>297.二叉树的序列化与反序列化</title>
    <link href="/2021/09/8cc3eb936545.html"/>
    <url>/2021/09/8cc3eb936545.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/submissions/">leetcode</a></p><p>时间复杂度： O(n)<br>空间复杂度： O(n)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */</span>  <br><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">struct</span> &#123;  <br>   StrArray []<span class="hljs-type">string</span>  <br>   path <span class="hljs-type">int</span>  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Codec &#123;  <br>   <span class="hljs-keyword">return</span> Codec&#123;  <br>      StrArray: []<span class="hljs-type">string</span>&#123;&#125;,  <br>      path: <span class="hljs-number">0</span>,  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// Serializes a tree to a single string.  </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> serialize(root *TreeNode) <span class="hljs-type">string</span> &#123;  <br>   this.SeRecusival(root)  <br>   <span class="hljs-comment">// fmt.Printf(&quot;array: %v\n&quot;, this.StrArray)  </span><br>  <br>   <span class="hljs-keyword">return</span> strings.Join(this.StrArray, <span class="hljs-string">&quot;,&quot;</span>)  <br>&#125;  <br>  <br><span class="hljs-comment">// Deserializes your encoded data to tree.  </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> deserialize(data <span class="hljs-type">string</span>) *TreeNode &#123;  <br>   this.StrArray = strings.Split(data, <span class="hljs-string">&quot;,&quot;</span>)  <br>   this.path = <span class="hljs-number">0</span>  <br>  <br>   <span class="hljs-keyword">return</span> this.DeRecusival()  <br>&#125;  <br>  <br><span class="hljs-comment">// 1 2 nil nil 3 4 nil nil 5 nil nil  </span><br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> DeRecusival() *TreeNode &#123;  <br>   <span class="hljs-keyword">if</span> this.StrArray[this.path] == <span class="hljs-string">&quot;nil&quot;</span> &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>  <br>   &#125;  <br>  <br>   intVar, _ := strconv.Atoi(this.StrArray[this.path])  <br>  <br>   root := &amp;TreeNode&#123;Val: intVar&#125;  <br>   this.path++  <br>   root.Left = this.DeRecusival()  <br>   this.path++  <br>   root.Right = this.DeRecusival()  <br>  <br>   <span class="hljs-keyword">return</span> root  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> SeRecusival(root *TreeNode) &#123;  <br>   <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;  <br>      this.StrArray = <span class="hljs-built_in">append</span>(this.StrArray, <span class="hljs-string">&quot;nil&quot;</span>)  <br>      <span class="hljs-keyword">return</span>  <br>   &#125;  <br>  <br>   <span class="hljs-comment">// fmt.Printf(&quot;val: %v\n&quot;, strconv.Itoa(root.Val))  </span><br>  <br>   this.StrArray = <span class="hljs-built_in">append</span>(this.StrArray, strconv.Itoa(root.Val))  <br>   this.SeRecusival(root.Left)  <br>   this.SeRecusival(root.Right)  <br>&#125;  <br>  <br>  <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* ser := Constructor();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* deser := Constructor();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* data := ser.serialize(root);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* ans := deser.deserialize(data);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span>&lt;!-- more --&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>516.最大回文子序列</title>
    <link href="/2021/09/09f02e1b9f32.html"/>
    <url>/2021/09/09f02e1b9f32.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p><code>dp[i][j]</code> 用来记录从i到j位置的字符串的最大回文子序列长度。</p><p><code>dp[i][i]</code> 都为1。</p><p>状态转移时考虑最左和最右元素是否相等，相等则转移至 <code>dp[i+1][j-1]</code> ，否则考虑 <code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code> 的较大者 。</p><p>注意遍历时，i从右边开始，可以保证每个子问题都计算过了。</p><p>时间复杂度：O(N^2)<br>空间复杂度：O(N^2)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// s[i] != s[j]</span><br><span class="hljs-comment">// dp[i][j] = max(dp[i][j-1], dp[i+1][j])</span><br><span class="hljs-comment">// s[i] == s[j]</span><br><span class="hljs-comment">// dp[i][j] = dp[i+1][j-1] + 2</span><br><br>dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s))<br>dp[i][i] = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(s); j++ &#123;<br><span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dp[i][j] = max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>&#125;<br><span class="hljs-comment">// fmt.Printf(&quot;dp[%v][%v], %v\n&quot;, i, j, dp[i][j])</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8.字符串转换整数 (atoi)</title>
    <link href="/2021/09/510e100f0b5d.html"/>
    <url>/2021/09/510e100f0b5d.html</url>
    
    <content type="html"><![CDATA[<p>自动机</p><p>时间复杂度：O(N)<br>空间复杂度：O(1)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// start signed number end</span><br><span class="hljs-keyword">const</span> MinInt32, MaxInt32 = <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-number">31</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>states := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;start&quot;</span>:  &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br><span class="hljs-string">&quot;signed&quot;</span>: &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br><span class="hljs-string">&quot;number&quot;</span>: &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br><span class="hljs-string">&quot;end&quot;</span>:    &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br>&#125;<br><br>state := <span class="hljs-string">&quot;start&quot;</span><br>ans := <span class="hljs-number">0</span><br>sign := <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>index := get_state(s, i)<br>        curr := states[state][index]<br><br><span class="hljs-comment">//fmt.Printf(&quot;state: %v\n&quot;, state)</span><br><span class="hljs-comment">//fmt.Printf(&quot;curr: %v\n&quot;, curr)</span><br><span class="hljs-keyword">switch</span> curr &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;end&quot;</span>:<br><span class="hljs-comment">//fmt.Printf(&quot;ans: %v\n&quot;, ans)</span><br><span class="hljs-comment">//fmt.Printf(&quot;sign: %v\n&quot;, sign)</span><br><span class="hljs-keyword">return</span> ans * sign<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;number&quot;</span>:<br>ans = ans*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(s[i]) - <span class="hljs-number">48</span><br><span class="hljs-keyword">if</span> ans * sign &gt;= MaxInt32 &#123;<br><span class="hljs-keyword">return</span> MaxInt32<br>&#125;<br><span class="hljs-keyword">if</span> ans * sign &lt;= MinInt32 &#123;<br><span class="hljs-keyword">return</span> MinInt32<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;signed&quot;</span>:<br><span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>sign = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br><br>        state = curr<br><br>&#125;<br><br><span class="hljs-keyword">return</span> ans * sign<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get_state</span><span class="hljs-params">(s <span class="hljs-type">string</span>, i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> s[i] == <span class="hljs-string">&#x27; &#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">case</span> s[i] == <span class="hljs-string">&#x27;+&#x27;</span> || s[i] == <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">case</span> s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1011.D天内送达包裹的能力</title>
    <link href="/2021/09/1ee5da1fe507.html"/>
    <url>/2021/09/1ee5da1fe507.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">leetcode</a></p><p>承载能力的范围：[最大包裹重量，包裹总重量]</p><p>承载能力范围中二分查找，找到让运输天数和需求天数相等的最小承载能力。运输天数小于需求天数时，承载能力可以再减小，反正则应该增大。</p><p>每天包裹重量大于承载能力时需等到第二天继续运输。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(weights []<span class="hljs-type">int</span>, days <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> weights &#123;<br>        right += w<br>        <span class="hljs-keyword">if</span> left &lt; w &#123;<br>            left = w<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> day, sum <span class="hljs-type">int</span><br>    result := right<br><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        day = <span class="hljs-number">1</span><br>        sum = <span class="hljs-number">0</span><br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-comment">// fmt.Printf(&quot;mid: %v\n&quot;, mid)</span><br><br><span class="hljs-comment">// 每天包裹重量大于承载能力时需等到第二天继续运输</span><br>        <span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> weights &#123;<br>            <span class="hljs-keyword">if</span> sum + w &gt; mid &#123;<br>                day++<br>                sum = <span class="hljs-number">0</span><br>            &#125; <br>            sum += w<br>        &#125;<br>        <br>        <span class="hljs-comment">// fmt.Printf(&quot;day: %v\n&quot;, day)</span><br><br>        <span class="hljs-keyword">if</span> day &lt;= days &#123;<br>            <span class="hljs-keyword">if</span> mid &lt; result &#123;<br>                result = mid<br>            &#125;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1091.二进制矩阵中的最短路径</title>
    <link href="/2021/09/ccf6ad58cd8a.html"/>
    <url>/2021/09/ccf6ad58cd8a.html</url>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(grid)<br><span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br>q := [][]<span class="hljs-type">int</span>&#123;&#125;<br>visited := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>visited[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>&#125;<br>visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br><br>ans := <span class="hljs-number">-1</span><br><span class="hljs-keyword">var</span> bfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">var</span> valid <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// row col</span><br>q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;)<br><br>bfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>curr := q[<span class="hljs-number">0</span>]<br>q = q[<span class="hljs-number">1</span>:]<br><br>dx := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>dy := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++ &#123;<br>row := curr[<span class="hljs-number">0</span>] + dy[i]<br>col := curr[<span class="hljs-number">1</span>] + dx[i]<br><br><span class="hljs-keyword">if</span> valid(row, col) &#123;<br>visited[row][col] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> row == n<span class="hljs-number">-1</span> &amp;&amp; col == n<span class="hljs-number">-1</span> &#123;<br>ans = curr[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span><br>&#125;<br>q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;row, col, curr[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>&#125;)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>valid = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(row, col <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span> || row &gt;= n || col &gt;= n || visited[row][col] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">return</span> grid[row][col] == <span class="hljs-number">0</span><br>&#125;<br><br>bfs()<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">powInt</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(math.Pow(<span class="hljs-type">float64</span>(x), <span class="hljs-type">float64</span>(y)))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>122.买卖股票的最佳时机 II</title>
    <link href="/2021/09/8a1aa3ad11a7.html"/>
    <url>/2021/09/8a1aa3ad11a7.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p>考虑两个状态，天数和当天是否持有股票，不同状态下当天持有的最大现金：</p><blockquote><p>当天持有股票：前一天持有并且当天不卖或者前一天没有当天买入。<br>   当天没有持有股票：前一天没有持有并且当天不买或者前一天持有当天卖出。</p></blockquote><p>最后一天不持有股票状态下的现金为最大值。</p><p>由于第n天的现金只与前一天的现金和是否持有股票有关，所以优化空间只用记录前一天持有和不持有股票的现金即可。</p><p>时间复杂度： O(N)<br>空间复杂度：O(1)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// dp[i][1] = max(dp[i-1][1], dp[i][0] - prices[i])</span><br>    <span class="hljs-comment">// dp[i][0] = max(dp[i-1][0], dp[i][1] + prices[i])</span><br>    n := <span class="hljs-built_in">len</span>(prices)<br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>    dp = []<span class="hljs-type">int</span>&#123; <span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>] &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        temp0 := dp[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">0</span>] = max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] + prices[i])<br>        dp[<span class="hljs-number">1</span>] = max(dp[<span class="hljs-number">1</span>], temp0 - prices[i])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>]<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>125. 验证回文串</title>
    <link href="/2021/09/98d75be59f0a.html"/>
    <url>/2021/09/98d75be59f0a.html</url>
    
    <content type="html"><![CDATA[<p>双指针</p><p>时间复杂度： O(N)<br>空间复杂度：O(N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    temp := strings.ToLower(s)<br><br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(temp) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i &lt; j &#123;<br>        <span class="hljs-keyword">for</span> i &lt; j &amp;&amp; !isAllowed(temp[i]) &#123;<br>            i++<br>        &#125;<br>        <span class="hljs-keyword">for</span> i &lt; j &amp;&amp; !isAllowed(temp[j]) &#123;<br>            j--<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> temp[i] != temp[j] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++<br>            j--<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAllowed</span><span class="hljs-params">(ch <span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || (ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>130.被围绕的区域</title>
    <link href="/2021/09/6dfb0c949d97.html"/>
    <url>/2021/09/6dfb0c949d97.html</url>
    
    <content type="html"><![CDATA[<p>广度优先遍历</p><p>时间复杂度：O(n×m)<br>空间复杂度：O(n×m)</p><p>m,n为矩阵的行数和列数。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solve</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>)</span></span>  &#123;<br>    rows := <span class="hljs-built_in">len</span>(board)<br>    cols := <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>    dx := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>    dy := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br><br>    q := [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> bfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span><br><br>    bfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> &#123;<br>        q = q[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>            nx := x + dx[i]<br>            ny := y + dy[i]<br><br>            <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; cols &amp;&amp; board[nx][ny] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>                q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;nx, ny&#125;)<br>                board[nx][ny] = <span class="hljs-string">&#x27;#&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 先处理四周的岛屿</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; rows; i++ &#123;<br>        <span class="hljs-keyword">if</span> board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;i, <span class="hljs-number">0</span>&#125;)<br>            board[i][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;#&#x27;</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> board[i][cols - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;i, cols - <span class="hljs-number">1</span>&#125;)<br>            board[i][cols<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;#&#x27;</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; cols - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, i&#125;)<br>            board[<span class="hljs-number">0</span>][i] = <span class="hljs-string">&#x27;#&#x27;</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> board[rows<span class="hljs-number">-1</span>][i] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;rows - <span class="hljs-number">1</span>, i&#125;)<br>            board[rows<span class="hljs-number">-1</span>][i] = <span class="hljs-string">&#x27;#&#x27;</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// fmt.Printf(&quot;board: %v\n&quot;, board)</span><br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        bfs(q[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], q[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])<br>    &#125;<br><br><span class="hljs-comment">// 剩下的岛屿就是被围绕的岛屿，同时把四周的岛屿还原</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; rows; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; cols; j++ &#123;<br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>                board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>                board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1334.阈值距离内邻居最少的城市</title>
    <link href="/2021/09/e094958da4f3.html"/>
    <url>/2021/09/e094958da4f3.html</url>
    
    <content type="html"><![CDATA[<p>Floyd算法计算所有点对之间最短路径。注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了。</p><p>时间复杂度：O(N^3)<br>空间复杂度：O(N^2)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTheCity</span><span class="hljs-params">(n <span class="hljs-type">int</span>, edges [][]<span class="hljs-type">int</span>, distanceThreshold <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 构建邻接矩阵</span><br>    d := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        d[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++&#123;<br>            <span class="hljs-keyword">if</span> i != j &#123;<br>                d[i][j] = math.MaxInt / <span class="hljs-number">2</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, edge := <span class="hljs-keyword">range</span> edges &#123;<br>        x := edge[<span class="hljs-number">0</span>]<br>        y := edge[<span class="hljs-number">1</span>]<br>        z := edge[<span class="hljs-number">2</span>]<br><br>        d[x][y] = z<br>        d[y][x] = z<br>    &#125;<br><br>    <span class="hljs-comment">// Floyd算法</span><br>    <span class="hljs-comment">// d[i][j] = min(d[i][j], d[i][k] + d[k][j])</span><br>    <span class="hljs-comment">// 注意先遍历k，才能保证计算k之前，k-1的情况都计算完成了</span><br>    <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; n; k++ &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>                <span class="hljs-keyword">if</span> k != i &amp;&amp; k != j &#123;<br>                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// fmt.Printf(&quot;d[i][j]: %v\n&quot;, d)</span><br><br>    minNeighboor := math.MaxInt / <span class="hljs-number">2</span><br>    ans := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        neighboor := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> i != j &amp;&amp; d[i][j] &lt;= distanceThreshold &#123;<br>                neighboor++<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> neighboor &lt; minNeighboor || (neighboor == minNeighboor &amp;&amp; i &gt; ans) &#123;<br>            minNeighboor = neighboor<br>            ans = i<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> (a &gt; b)&#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>136.邻值查找</title>
    <link href="/2021/09/b207d139ad46.html"/>
    <url>/2021/09/b207d139ad46.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/138/">Acwing</a></p><p>双向链表</p><p>用排序后的双向链表维护每个数字前后相邻的两个数字用来计算最大绝对值。</p><p>计算绝对值时根据原数组顺序从后往前遍历，处理完后则在链表中删除当前数字。</p><p>时间复杂度：O(N)<br>空间复杂度：O(N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    Prev *Node<br>    Next *Node<br>    Val <span class="hljs-type">int</span><br>    Index <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>    fmt.Scan(&amp;n)<br>    <br>    nums := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        nums[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>        fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nums[i][<span class="hljs-number">0</span>])<br>        nums[i][<span class="hljs-number">1</span>] = i<br>    &#125;<br>    <br>    sort.Slice(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> nums[i][<span class="hljs-number">0</span>] &lt; nums[j][<span class="hljs-number">0</span>]<br>    &#125;)<br>    <br>    head := &amp;Node&#123;<br>        Index: <span class="hljs-number">-1</span>,<br>    &#125;<br>    prev := head<br>    nodes := <span class="hljs-built_in">make</span>([]*Node, n)<br>    ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        node := &amp;Node&#123;<br>            Prev: prev,<br>            Val: nums[i][<span class="hljs-number">0</span>],<br>            Index: nums[i][<span class="hljs-number">1</span>],<br>        &#125;<br>        <br>        prev.Next = node<br>        prev = node<br>        nodes[nums[i][<span class="hljs-number">1</span>]] = node<br>        <span class="hljs-comment">// fmt.Printf(&quot;%v, %v\n&quot;, nums[i][1], node)</span><br>    &#125;<br>    <br>    prev.Next =  &amp;Node&#123;<br>            Index: n,<br>        &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--&#123;<br>        curr := nodes[i]<br>        pn := nodes[i].Prev<br>        nn := nodes[i].Next<br>        <br><br>        ans[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment">// fmt.Printf(&quot;%v %v %v\n&quot;, p.Val, curr.Val, n.Val)</span><br>        <span class="hljs-keyword">if</span> nn.Index == n || (pn.Index != <span class="hljs-number">-1</span> &amp;&amp; abs(pn.Val - curr.Val) &lt;= abs(nn.Val - curr.Val)) &#123;<br>            ans[i][<span class="hljs-number">0</span>] = abs(pn.Val - curr.Val)<br>            ans[i][<span class="hljs-number">1</span>] = pn.Index + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans[i][<span class="hljs-number">0</span>] = abs(nn.Val - curr.Val)<br>            ans[i][<span class="hljs-number">1</span>] = nn.Index + <span class="hljs-number">1</span><br>        &#125;<br>        <br>        pn.Next = curr.Next<br>        nn.Prev = pn<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%v %v\n&quot;</span>, ans[i][<span class="hljs-number">0</span>], ans[i][<span class="hljs-number">1</span>])<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -a<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>152.乘积最大子数组</title>
    <link href="/2021/09/5c55c968c05f.html"/>
    <url>/2021/09/5c55c968c05f.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p>考虑当前数字为正还是为负，并维护前序乘积最大和最小数组。</p><p>由于当前位置乘积最大值只与前一位置的乘积最大值或最小值有关，则可以优化数组为两个变量。</p><p>时间复杂度： O(N)<br>空间复杂度： O(1)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// nums[i] &gt; 0</span><br>    <span class="hljs-comment">// dpMax[i] = max(dpMax[i-1] * nums[i], nums[i])</span><br>    <span class="hljs-comment">// dpMin[i] = min(dpMin[i-1] * nums[i], nums[i])</span><br>    <span class="hljs-comment">// nums[i] &lt; 0</span><br>    <span class="hljs-comment">// dpMax[i] = max(dpMin[i-1] * nums[i], nums[i])</span><br>    <span class="hljs-comment">// dpMin[i] = min(dpMax[i-1] * nums[i], nums[i])</span><br>    <br>    dpMax := nums[<span class="hljs-number">0</span>]<br>    dpMin := nums[<span class="hljs-number">0</span>]<br>    ans := nums[<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &gt; <span class="hljs-number">0</span> &#123;<br>            dpMax = max(dpMax * nums[i], nums[i])<br>            dpMin = min(dpMin * nums[i], nums[i])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp := dpMax<br>            dpMax = max(dpMin * nums[i], nums[i])<br>            dpMin = min(temp * nums[i], nums[i])<br>        &#125;<br>        ans = max(dpMax, ans)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>154. 寻找旋转排序数组中的最小值 2</title>
    <link href="/2021/09/2428552c6da3.html"/>
    <url>/2021/09/2428552c6da3.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">leetcode</a></p><p>使用二分法可以减少时间复杂度。注意有重复元素，遇到重复元素则可以删除一个，至少留有一个来参与最小值比较。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-comment">// 重复元素则去掉最右端的那个</span><br>        <span class="hljs-keyword">if</span> nums[mid] == nums[right] &#123;<br>            right--<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; nums[right] &#123;<br>            right = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[right]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1584.连接所有点的最小费用</title>
    <link href="/2021/09/fbe38ea3571e.html"/>
    <url>/2021/09/fbe38ea3571e.html</url>
    
    <content type="html"><![CDATA[<p>最小生成树问题，Kruskal 算法</p><p>任意一颗最小生成树一定包含无向图中权值最小的边。</p><p>把任何一个生成森林扩展成最小生成树，一定使用了图中剩余边中权值最小的边。</p><p>证明方法： 树上加一条边成环  + 反证法</p><p>时间复杂度：O(N^2logN)<br>空间复杂度：O(N^2)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(points)<br>    groups := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    edges := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    ans := <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">// 并查集</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        groups[i] = i<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br>    find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> i == groups[i] &#123;<br>            <span class="hljs-keyword">return</span> i<br>        &#125;<br>        groups[i] = find(groups[i])<br>        <span class="hljs-keyword">return</span> groups[i]<br>    &#125;<br><br>    union := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> &#123;<br>        gx := find(x)<br>        gy := find(y)<br><br>        <span class="hljs-keyword">if</span> gx != gy &#123;<br>            groups[gx] = gy<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 构建出边数组</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i ++ &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            xi := points[i][<span class="hljs-number">0</span>]<br>            yi := points[i][<span class="hljs-number">1</span>]<br>            xj := points[j][<span class="hljs-number">0</span>]<br>            yj := points[j][<span class="hljs-number">1</span>]<br><br>            edges = <span class="hljs-built_in">append</span>(edges, []<span class="hljs-type">int</span>&#123;i, j, abs(xi-xj) + abs(yi-yj)&#125;)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据权重排序</span><br>    sort.Slice(edges, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> edges[i][<span class="hljs-number">2</span>] &lt; edges[j][<span class="hljs-number">2</span>]<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 依次链接，计算费用</span><br>    left := n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _, edge := <span class="hljs-keyword">range</span> edges &#123;<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> find(edge[<span class="hljs-number">0</span>]) == find(edge[<span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>])<br>            ans += edge[<span class="hljs-number">2</span>]<br>        &#125;<br>        left--<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> val &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -val<br>    &#125;<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17.电话号码的字母组合</title>
    <link href="/2021/09/59ae4316663b.html"/>
    <url>/2021/09/59ae4316663b.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">leetcode</a></p><p>深度优先遍历，注意这里每次选取数字必定会选取一个对应字母，不存在不选的情况。</p><p>时间复杂度：O(3^m x 4^n)<br>空间复杂度：O(m+n)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(digits <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>    &#125;<br><br>    letterMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;2&quot;</span>: &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;,<br>        <span class="hljs-string">&quot;3&quot;</span>: &#123;<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>&#125;,<br>        <span class="hljs-string">&quot;4&quot;</span>: &#123;<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;,<br>        <span class="hljs-string">&quot;5&quot;</span>: &#123;<span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>&#125;,<br>        <span class="hljs-string">&quot;6&quot;</span>: &#123;<span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>&#125;,<br>        <span class="hljs-string">&quot;7&quot;</span>: &#123;<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>&#125;,<br>        <span class="hljs-string">&quot;8&quot;</span>: &#123;<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>&#125;,<br>        <span class="hljs-string">&quot;9&quot;</span>: &#123;<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>&#125;,<br>    &#125;<br><br>    cur := <span class="hljs-string">&quot;&quot;</span><br>    results := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(digits) &#123;<br>            results = <span class="hljs-built_in">append</span>(results, cur)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        d := <span class="hljs-type">string</span>(digits[i])<br>        letters := letterMap[d]<br><br>        <span class="hljs-keyword">for</span> _, l := <span class="hljs-keyword">range</span> letters &#123;<br>            cur = cur + l<br>            dfs(i + <span class="hljs-number">1</span>)<br>            cur = <span class="hljs-type">string</span>(cur[:<span class="hljs-built_in">len</span>(cur) - <span class="hljs-number">1</span>])<br>        &#125;<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> results<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>18.四数之和</title>
    <link href="/2021/09/c60b74097c6b.html"/>
    <url>/2021/09/c60b74097c6b.html</url>
    
    <content type="html"><![CDATA[<p>排序+双指针，注意剪枝的几种情况。</p><ol><li>最小四个数比target大</li><li>选择的前两个数遇到重复数字时</li><li>剩下两数最大比 <code>target-preSum</code> 小或者最小比 <code>target-preSum</code> 大（也可以不判断）</li><li>剩下两数遇到重复数字时</li></ol><p>时间复杂度：O(n^3)<br>空间复杂度：O(logN)，快排的递归深度</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fourSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    sort.Ints(nums)<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    ans := [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 挑选第一个数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-comment">// 最小四个数比target还大，剪枝</span><br>        <span class="hljs-keyword">if</span> nums[i] + nums[i+<span class="hljs-number">1</span>] + nums[i+<span class="hljs-number">2</span>] + nums[i+<span class="hljs-number">3</span>] &gt; target&#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-comment">// 重复数字跳过</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]&#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-comment">// 挑选第二个数</span><br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++&#123;<br>            preSum := nums[i] + nums[j]<br><br>            <span class="hljs-comment">// 重复数字跳过，从第i+2个数字开始</span><br>            <span class="hljs-keyword">if</span> j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]&#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-comment">// 剩下求两数之和</span><br>            l, r := j + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span><br>            <span class="hljs-comment">// 最大两数和比target小，剪枝</span><br>            <span class="hljs-keyword">if</span> preSum + nums[r] + nums[r<span class="hljs-number">-1</span>] &lt; target&#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-comment">// 最小两数和比target大，剪枝</span><br>            <span class="hljs-keyword">if</span> preSum + nums[l] + nums[l+<span class="hljs-number">1</span>] &gt; target&#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-keyword">for</span> l &lt; r &#123;<br>                <span class="hljs-keyword">if</span> preSum + nums[l] + nums[r] == target &#123;<br>                    ans = <span class="hljs-built_in">append</span>(ans, []<span class="hljs-type">int</span>&#123;nums[i], nums[j], nums[l], nums[r]&#125;)<br>                    <span class="hljs-keyword">for</span> l &lt; r &#123;<br>                        l++<br>                        <span class="hljs-comment">// 当前数字和前一个数字不同则停止右移</span><br>                        <span class="hljs-keyword">if</span> nums[l<span class="hljs-number">-1</span>] != nums[l] &#123;<br>                            <span class="hljs-keyword">break</span><br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">for</span> l &lt; r  &#123;<br>                        r--<br>                        <span class="hljs-comment">// 当前数字和前一个数字不同则停止左移</span><br>                        <span class="hljs-keyword">if</span> nums[r+<span class="hljs-number">1</span>] != nums[j] &#123;<br>                            <span class="hljs-keyword">break</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> preSum + nums[l] + nums[r] &lt; target&#123;<br>                    l++<br>                &#125;<br>                <span class="hljs-keyword">if</span> preSum + nums[l] + nums[r] &gt; target&#123;<br>                    r--<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>200.岛屿数量</title>
    <link href="/2021/09/28c37fe4d19d.html"/>
    <url>/2021/09/28c37fe4d19d.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-islands/">leetcode</a></p><p>深度优先搜索</p><p>时间复杂度：O(MN)<br>空间复杂度：O(MN)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    result := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span><br><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(row <span class="hljs-type">int</span>, col <span class="hljs-type">int</span>, count <span class="hljs-type">int</span>)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span> || row &gt;= <span class="hljs-built_in">len</span>(grid) || col &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-type">string</span>(grid[row][col]) == <span class="hljs-string">&quot;0&quot;</span> || <span class="hljs-type">string</span>(grid[row][col]) == <span class="hljs-string">&quot;2&quot;</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-comment">// if count &gt; 0 &#123;</span><br>        <span class="hljs-comment">//     fmt.Printf(&quot;grid: %v\n&quot;, grid)</span><br>        <span class="hljs-comment">// &#125;</span><br>        grid[row][col] = <span class="hljs-string">&#x27;2&#x27;</span><br>        result += count<br><br>        dfs(row - <span class="hljs-number">1</span>, col, <span class="hljs-number">0</span>) <span class="hljs-comment">//上</span><br>        dfs(row, col + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//右</span><br>        dfs(row + <span class="hljs-number">1</span>, col, <span class="hljs-number">0</span>) <span class="hljs-comment">//下</span><br>        bfs(row, col - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//左</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(grid); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]); j++ &#123;<br>            bfs(i, j, <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>208.实现 Trie (前缀树)</title>
    <link href="/2021/09/9f36be36262a.html"/>
    <url>/2021/09/9f36be36262a.html</url>
    
    <content type="html"><![CDATA[<p>字典树</p><p>树的节点存储两个数据：</p><ol><li>Count作为结束节点的次数（用来标识单词结束以及统计单词出现次数）</li><li>Edges存储从该节点还可以延伸下去的边（指针指向下一个节点），可以是数组也可以是map，map适用性更强。<span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br>    Count <span class="hljs-type">int</span><br>    Edges <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]*Trie<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;<br>    <span class="hljs-keyword">return</span> Trie&#123;<br>        Count: <span class="hljs-number">0</span>,<br>        Edges: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]*Trie),<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>)  &#123;<br>    curr := this<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(word); i++ &#123;<br>        next, ok := curr.Edges[word[i]]<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            next = &amp;Trie&#123;<br>                Count: <span class="hljs-number">0</span>,<br>                Edges: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]*Trie),<br>            &#125;<br>            curr.Edges[word[i]] = next<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span> &#123;<br>            next.Count++<br>        &#125;<br>        <span class="hljs-comment">// fmt.Printf(&quot;curr: %v\n&quot;, curr)</span><br><br>        curr = next<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    curr := this<br>    ok := <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(word); i++ &#123;<br>        <span class="hljs-keyword">if</span> ok &#123;<br>            curr, ok = curr.Edges[word[i]]  <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ok &amp;&amp; curr.Count &gt; <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    curr := this<br>    ok := <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(prefix); i++ &#123;<br>        <span class="hljs-keyword">if</span> ok &#123;<br>            curr, ok = curr.Edges[prefix[i]]  <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ok &amp;&amp; <span class="hljs-literal">true</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Insert(word);</span><br><span class="hljs-comment"> * param_2 := obj.Search(word);</span><br><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>210.课程表2</title>
    <link href="/2021/09/d00c0b25453f.html"/>
    <url>/2021/09/d00c0b25453f.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/course-schedule-ii/">leetcode</a></p><p>建立前序后序邻接表，找到入度为零的节点，然后维护邻接表。</p><p>最后路径长度等于课程总数则表示可以学完所有课程。</p><p>时间复杂度：O(n + m)<br>空间复杂度：O(n + m)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findOrder</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>result := []<span class="hljs-type">int</span>&#123;&#125;<br>pre := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>)<br>post := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">for</span> _, req := <span class="hljs-keyword">range</span> prerequisites &#123;<br>x := req[<span class="hljs-number">0</span>]<br>y := req[<span class="hljs-number">1</span>]<br>pre[x] = <span class="hljs-built_in">append</span>(pre[x], y)<br>post[y] = <span class="hljs-built_in">append</span>(post[y], x)<br>&#125;<br><br><span class="hljs-comment">// fmt.Printf(&quot;pre: %v\n&quot;, pre)</span><br><span class="hljs-comment">// fmt.Printf(&quot;post: %v\n&quot;, post)</span><br><br>queue := []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br><span class="hljs-keyword">if</span> _, ok := pre[i]; !ok &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>cur := queue[<span class="hljs-number">0</span>]<br>result = <span class="hljs-built_in">append</span>(result, cur)<br><span class="hljs-comment">// fmt.Printf(&quot;queue: %v\n&quot;, queue)</span><br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> post[cur] &#123;<br><span class="hljs-keyword">for</span> i, q := <span class="hljs-keyword">range</span> pre[p] &#123;<br><span class="hljs-keyword">if</span> q == cur &#123;<br>pre[p] = <span class="hljs-built_in">append</span>(pre[p][:i], pre[p][i+<span class="hljs-number">1</span>:]...)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pre[p]) == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, p)<br>&#125;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) != numCourses &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>22.括号生成</title>
    <link href="/2021/09/347672d66136.html"/>
    <url>/2021/09/347672d66136.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/generate-parentheses/submissions/">leetcode</a></p><p>先选定一对括号，生成的序列可以写为<code>(left)right</code>，其中 <code>left</code> 和 <code>right</code> 分别为 <code>i</code> 对括号和 <code>n-i-1</code> 对括号的序列。</p><p>再利用递归计算 <code>left</code> 和 <code>right</code> 。</p><p>时间复杂度：O(4n&#x2F;√n)<br>空间复杂度：O(4n&#x2F;√n)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> cache = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">string</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> generate(n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;&quot;</span>&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;()&quot;</span>&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> c, ok := cache[n]; ok &#123;<br>        <span class="hljs-keyword">return</span> c<br>    &#125;<br><br>    result := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        left := generate(i)<br>        right := generate(n - i <span class="hljs-number">-1</span>)<br>        <br>        <span class="hljs-keyword">for</span> _, l := <span class="hljs-keyword">range</span> left &#123;<br>            temp := fmt.Sprintf(<span class="hljs-string">&quot;(%s)&quot;</span>, l)<br>            <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> right &#123;<br>                result = <span class="hljs-built_in">append</span>(result, fmt.Sprintf(<span class="hljs-string">&quot;%s%s&quot;</span>, temp, r))<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    cache[n] = result<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23. 合并K个升序链表</title>
    <link href="/2021/09/aa2dbfd75f0d.html"/>
    <url>/2021/09/aa2dbfd75f0d.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">leetcode</a></p><p>分治思想</p><p>时间复杂度：O(kn * log k)<br>空间复杂度：O(log k)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* Definition for singly-linked list.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* type ListNode struct &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* Val int</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* Next *ListNode</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;<br><br>k := <span class="hljs-built_in">len</span>(lists)<br><br><span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span> &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> &#123;<br><br><span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]<br><br>&#125;<br><br>  <br><br>mid := k / <span class="hljs-number">2</span><br><br>left := lists[<span class="hljs-number">0</span>:mid]<br><br>right := lists[mid:k]<br><br>leftList := mergeKLists(left)<br><br>rightList := mergeKLists(right)<br><br>  <br><br><span class="hljs-keyword">return</span> merge(leftList, rightList)<br><br>&#125;<br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(left *ListNode, right *ListNode)</span></span> *ListNode&#123;<br><br>dummy := &amp;ListNode&#123;&#125;<br><br>result := dummy<br><br><span class="hljs-keyword">for</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br><br><span class="hljs-keyword">if</span> left.Val &lt; right.Val &#123;<br><br>dummy.Next = left<br><br>dummy = left<br><br>left = left.Next<br><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><br>dummy.Next = right<br><br>dummy = right<br><br>right = right.Next<br><br>&#125;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &#123;<br><br>dummy.Next = right<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &#123;<br><br>dummy.Next = left<br><br>&#125;<br><br><br><span class="hljs-keyword">return</span> result.Next<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>239.滑动窗口最大值</title>
    <link href="/2021/09/4dd2603238eb.html"/>
    <url>/2021/09/4dd2603238eb.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">leetcode</a></p><p>使用container.heap包实现大根堆。需要维护数据的index来判断是否在窗口内。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> a []<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    a = nums<br>    h := &amp;Heap&#123;&#125;<br>    heap.Init(h)<br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        heap.Push(h, i)<br>        <span class="hljs-keyword">for</span> h.slice[<span class="hljs-number">0</span>] &lt;= i - k &#123;<br>            heap.Pop(h)<br>        &#125;<br>        <span class="hljs-comment">// fmt.Printf(&quot;h: %v\n&quot;, h)</span><br>        <span class="hljs-keyword">if</span> i &gt;= k - <span class="hljs-number">1</span> &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, nums[h.slice[<span class="hljs-number">0</span>]])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-keyword">type</span> Heap <span class="hljs-keyword">struct</span> &#123;<br>    slice sort.IntSlice<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Heap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h.slice)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Heap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    h.slice[i], h.slice[j] = h.slice[j], h.slice[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Heap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> a[h.slice[i]] &gt; a[h.slice[j]]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Heap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    h.slice = <span class="hljs-built_in">append</span>(h.slice, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Heap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := h.slice<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    h.slice = old[:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><br><br><span class="hljs-keyword">type</span> NodeHeap []Node<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nh NodeHeap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nh)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nh NodeHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>nh[i], nh[j] = nh[j], nh[i]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nh NodeHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> nh[i].count &gt; nh[j].count &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> nh[i].count == nh[j].count &#123;<br><span class="hljs-keyword">if</span> nh[i].x + nh[i].y &lt; nh[j].x + nh[j].y&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> nh[i].x + nh[i].y == nh[j].x + nh[j].y &amp;&amp; nh[i].x &lt; nh[].x&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> nh[i].Area() &lt; nh[j].Area()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nh *NodeHeap)</span></span> Push(h <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>*nh = <span class="hljs-built_in">append</span>(*nh, h.(Node))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nh *NodeHeap)</span></span> Pop() (x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>n := <span class="hljs-built_in">len</span>(*nh)<br>x = (*nh)[n<span class="hljs-number">-1</span>]    <br>*nh = (*nh)[:n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>279.完全平方数</title>
    <link href="/2021/09/c7ddeb838461.html"/>
    <url>/2021/09/c7ddeb838461.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p><code>dp[i]</code>  表示和为i的完全平方数的最少数量。则可以得到状态转移方程： <code>dp[i] = min(dp[i-j^2]) + 1</code> 。</p><p>时间复杂度： O(N√N)。状态转移的时间复杂度为O(√N)，攻击N个状态。<br>空间复杂度：O(N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// dp[i] = min(dp[i-j^2]) + 1</span><br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++&#123;<br>        minDp := math.MaxInt<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j*j &lt;= i; j++ &#123;<br>            minDp = min(minDp, dp[i-j*j])<br>        &#125;<br>        dp[i] = minDp + <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>300.最长递增子序列</title>
    <link href="/2021/09/c34f3fd65725.html"/>
    <url>/2021/09/c34f3fd65725.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p><span id="more"></span><pre><code class="Go">func lengthOfLIS(nums []int) int &#123;    dp := make([]int, len(nums))    ans := 0    for i := 0; i &lt; len(nums); i++ &#123;        dp[i] = 1        for j := 0; j &lt; i; j++ &#123;            if nums[j] &lt; nums[i] &amp;&amp; dp[i] &lt; dp[j] + 1 &#123;                dp[i] = dp[j] + 1            &#125;        &#125;        if ans &lt; dp[i] &#123;            ans = dp[i]        &#125;    &#125;    return ans&#125;```</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>322.零钱兑换</title>
    <link href="/2021/09/91e669f81edd.html"/>
    <url>/2021/09/91e669f81edd.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p>自底向上，计算1~amount每个数作为结果所需要的最小硬币数量。</p><p>时间复杂度：O(Sn)，其中 SS 是金额，nn 是面额数<br>空间复杂度：O(S)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; amount+<span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = amount + <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 计算1~amount的每种情况下所需硬币数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= amount; i++&#123;<br>        <span class="hljs-keyword">for</span> _, coin := <span class="hljs-keyword">range</span> coins &#123;<br>            <span class="hljs-comment">//硬币面额大于amount则跳过</span><br>            <span class="hljs-keyword">if</span> coin &lt;= i &#123;<br>                <span class="hljs-comment">// 求最小dp[i-coin]</span><br>                <span class="hljs-keyword">if</span> dp[i] &gt; dp[i-coin] + <span class="hljs-number">1</span>&#123;<br>                    dp[i] = dp[i-coin] + <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> dp[amount] == amount + <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> dp[amount]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>327.区间的个数</title>
    <link href="/2021/09/1ff751bbb71e.html"/>
    <url>/2021/09/1ff751bbb71e.html</url>
    
    <content type="html"><![CDATA[<p>归并排序，排序时统计符合条件的下标对。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countRangeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, lower <span class="hljs-type">int</span>, upper <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 计算前缀和</span><br>    preSum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        preSum[i + <span class="hljs-number">1</span>] = preSum[i] + v<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> countSum <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">([]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br>    countSum = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        length := <span class="hljs-built_in">len</span>(arr)<br>        <span class="hljs-keyword">if</span> length &lt;= <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br><br>        left := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, arr[:length/<span class="hljs-number">2</span>]...)<br>        right := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, arr[length/<span class="hljs-number">2</span>:]...)<br><br>        count := countSum(left) + countSum(right)<br><br><span class="hljs-comment">// 统计符合条件的下标对</span><br>        l, r := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> left &#123;<br>            <span class="hljs-keyword">for</span> l &lt; <span class="hljs-built_in">len</span>(right) &amp;&amp; right[l] - v &lt; lower &#123;<br>                l++<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> r &lt; <span class="hljs-built_in">len</span>(right) &amp;&amp; right[r] - v &lt;= upper &#123;<br>                r++<br>            &#125;<br><br>            count += r - l<br>        &#125;<br><br>        <span class="hljs-comment">// 合并左右数组</span><br>        p1, p2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> arr &#123;<br>            <span class="hljs-keyword">if</span> p1 &lt; <span class="hljs-built_in">len</span>(left) &amp;&amp; ( p2 == <span class="hljs-built_in">len</span>(right) || left[p1] &lt;= right[p2]) &#123;<br>                arr[i] = left[p1]<br>                p1++<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                arr[i] = right[p2]<br>                p2++<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> countSum(preSum)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>337.打家劫舍 III</title>
    <link href="/2021/09/5b4cb558d58b.html"/>
    <url>/2021/09/5b4cb558d58b.html</url>
    
    <content type="html"><![CDATA[<p>后序遍历+动态规划</p><p>看到树形结构优先考虑root和左右子树的关系。</p><p>使用后序遍历是因为需要得到两个子节点的状态才能计算当前节点。</p><p>时间复杂度：O(N)<br>空间复杂度：O(N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// root[1] = root.left[0] + root.right[0] </span><br>    <span class="hljs-comment">// root[0] = max(root.left[0], root.left[1]) + max(root.right[0], root.right[1])</span><br><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span> []<span class="hljs-type">int</span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>        &#125;<br><br><span class="hljs-comment">// 得到子节点的状态</span><br>        left := dfs(root.Left)<br>        right := dfs(root.Right)<br><br><span class="hljs-comment">// 状态转移</span><br>        selected := root.Val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>]<br>        noSelected := max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>])<br><br><span class="hljs-comment">// 返回状态给上一层使用</span><br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;noSelected, selected&#125;<br>    &#125;<br><br>    temp := dfs(root)<br><br>    <span class="hljs-keyword">return</span> max(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>34.在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="/2021/09/abc5acf8e506.html"/>
    <url>/2021/09/abc5acf8e506.html</url>
    
    <content type="html"><![CDATA[<p>进行两次二分查找</p><p>时间复杂度：O(logN)<br>空间复杂度：O(1)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 手写二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125;<br><br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;<br>            right = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> nums[right] != target &#123;<br>        ans = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>        <span class="hljs-keyword">return</span> ans<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ans = <span class="hljs-built_in">append</span>(ans, right)<br>    &#125;<br><br>    right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        mid := (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt;= target &#123;<br>            left = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> nums[right] == target &#123;<br>        ans = <span class="hljs-built_in">append</span>(ans, right)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ans = <span class="hljs-built_in">append</span>(ans, ans[<span class="hljs-number">0</span>])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br><br>&#125;<br></code></pre></td></tr></table></figure><!-- more --><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 使用标准库</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>leftmost := sort.SearchInts(nums, target)<br><span class="hljs-keyword">if</span> leftmost == <span class="hljs-built_in">len</span>(nums) || nums[leftmost] != target &#123;<br><span class="hljs-comment">// 没有找到target</span><br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// nums中至少有一个target</span><br>rightmost := sort.SearchInts(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;leftmost, rightmost&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>394. 字符串解码</title>
    <link href="/2021/09/45fb9f609987.html"/>
    <url>/2021/09/45fb9f609987.html</url>
    
    <content type="html"><![CDATA[<p>递归处理</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// fmt.Printf(&quot;s: %v\n&quot;, s)</span><br>    ans := <span class="hljs-string">&quot;&quot;</span><br><br>    l, r, lc := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(s)<br>    count := <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>            <span class="hljs-keyword">if</span> lc == <span class="hljs-number">0</span> &#123;<br>                l = i + <span class="hljs-number">1</span><br>            &#125;<br>            lc++<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;]&#x27;</span> &#123;<br>            lc--<br>            <span class="hljs-keyword">if</span> lc == <span class="hljs-number">0</span> &#123;<br>                r = i<br>                temp := decodeString(s[l:r])<br>                <span class="hljs-comment">// fmt.Printf(&quot;temp: %v\n&quot;, s[l:r])</span><br>                cnt, _ := strconv.Atoi(count)<br>                <br>                <br>                <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; cnt; j++ &#123;<br>                    ans += <span class="hljs-type">string</span>(temp)<br>                &#125;<br>                count = <span class="hljs-string">&quot;&quot;</span><br>            &#125;<br><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> lc == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>                ans += <span class="hljs-type">string</span>(s[i])<br>            &#125; <span class="hljs-keyword">else</span>  &#123;<br>                count += <span class="hljs-type">string</span>(s[i])<br>                <span class="hljs-comment">// fmt.Printf(&quot;count: %v\n&quot;, count)</span><br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// fmt.Printf(&quot;ans: %v\n&quot;, ans)</span><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>433.最小基因变化</title>
    <link href="/2021/09/473a1a4615b3.html"/>
    <url>/2021/09/473a1a4615b3.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-genetic-mutation/">leetcode</a></p><p>广度优先搜索</p><p>广度优先搜索的时候，注意要去掉已遍历过的情况，方法是从bankMap中删除已遍历的元素。</p><p>时间复杂度：O(C x n x m)，其中C为基因位的可选项数量（此处为ACGT四种，C为4）， m为bank的长度，n为基因序列的长度。<br>空间复杂度： O(m x n)。合法性的哈希表中一共存有 m个元素，队列中最多有 mm 个元素，每个元素的空间为 O(n)。O(m + n x m) &#x3D; O(m x n)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(start <span class="hljs-type">string</span>, end <span class="hljs-type">string</span>, bank []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> start == end &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(bank) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    bankMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    queue := []<span class="hljs-type">string</span>&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> _, g := <span class="hljs-keyword">range</span> bank &#123;<br>        bankMap[g] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    queue = <span class="hljs-built_in">append</span>(queue, start)<br><br>    <span class="hljs-comment">// 最少也进行了一次变化</span><br>    <span class="hljs-keyword">for</span> count := <span class="hljs-number">1</span>; <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>; count++ &#123;<br>        <span class="hljs-keyword">for</span> _, cur := <span class="hljs-keyword">range</span> queue &#123;<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> cur &#123;<br>                <span class="hljs-keyword">for</span> _, y := <span class="hljs-keyword">range</span> <span class="hljs-string">&quot;ACGT&quot;</span> &#123;<br>                    <span class="hljs-keyword">if</span> y != x &#123;<br>                        cur := cur[:i] + <span class="hljs-type">string</span>(y) + cur[i+<span class="hljs-number">1</span>:]<br>                        <span class="hljs-comment">// fmt.Printf(&quot;index: %v cur: %v\n&quot;, i, cur)</span><br>                        <span class="hljs-keyword">if</span> _, ok := bankMap[cur]; ok &#123;<br>                            <span class="hljs-keyword">if</span> cur == end &#123;<br>                                <span class="hljs-keyword">return</span> count<br>                            &#125;<br>                            queue = <span class="hljs-built_in">append</span>(queue, cur)<br>                        <br>                            <span class="hljs-comment">// 去除已经遍历过的情况 </span><br>                            <span class="hljs-built_in">delete</span>(bankMap, cur)<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>45. 跳跃游戏 II</title>
    <link href="/2021/09/d8e4866d5698.html"/>
    <url>/2021/09/d8e4866d5698.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p>从后往前考虑。</p><p>时间复杂度：O(N^2)<br>空间复杂度：O(1)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-number">0</span><br>    r := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> r &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br>            <span class="hljs-keyword">if</span> nums[i] &gt;= r - i &#123;<br>                r = i<br>                count++<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure><p>从前往后考虑。</p><p>时间复杂度：O(N)<br>空间复杂度：O(1)</p><!-- more --><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    maxPosition := <span class="hljs-number">0</span><br>    end := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// r := len(nums) - 1</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++ &#123;<br>maxPosition = max(maxPosition, i + nums[i])<br><span class="hljs-keyword">if</span> i == end &#123;<br>end = maxPosition<br>count++<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> count<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>450.删除二叉搜索树中的节点</title>
    <link href="/2021/09/192faa59c2cf.html"/>
    <url>/2021/09/192faa59c2cf.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">leetcode</a></p><p>递归方法</p><ol><li>根据二叉搜索树的特性寻找要删除的节点</li><li>如果删除节点就是叶子节点，直接删除</li><li>如果删除节点的左孩子或者有孩子为空，则直接删除当前节点，把非空的孩子节点替换当前节点</li><li>如果删除节点左右孩子都不为空，则寻找大于删除节点的最小节点来替代删除节点，这个节点在删除节点右子树的最左端叶子节点。该节点没有左子树，删除该节点后也比较好处理，且可以保证被删除节点的左子树都小于它，被删除节点的右子树也都大于它。</li><li>特殊情况，若删除节点右子树的最左端叶子节点就是删除节点的右孩子，则只需替换右子树的最左端叶子节点的左孩子为删除节点的左孩子即可。</li></ol><p>时间复杂度：O(N)<br>空间复杂度：O(N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> root.Val &lt; key &#123;<br>        root.Right = deleteNode(root.Right, key)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Val &gt; key &#123;<br>        root.Left = deleteNode(root.Left, key)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> || root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> root.Right<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> root.Left<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tempParent := root<br>            temp := root.Right<br><br>            <span class="hljs-comment">// root.Right 就是右子树的最小值</span><br>            <span class="hljs-keyword">if</span> temp.Left == <span class="hljs-literal">nil</span> &#123;<br>                temp.Left = root.Left<br>                <span class="hljs-keyword">return</span> temp<br>            &#125;<br><br>            <span class="hljs-comment">// 寻找右子树的最小值</span><br>            <span class="hljs-keyword">for</span> temp.Left != <span class="hljs-literal">nil</span> &#123;<br>                tempParent = temp<br>                temp = temp.Left<br>            &#125;<br><br>            temp.Left = root.Left<br>            tempParent.Left = temp.Right<br>            temp.Right = root.Right<br>            <span class="hljs-keyword">return</span> temp<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>47.全排列2</title>
    <link href="/2021/09/a1637c359464.html"/>
    <url>/2021/09/a1637c359464.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/permutations-ii/">leetcode</a></p><p>深度优先搜索</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> ans [][]<span class="hljs-type">int</span><br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permuteUnique</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><br>sort.Ints(nums)<br><br>used := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))<br><br>arr := []<span class="hljs-type">int</span>&#123;&#125;<br><br>ans = [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>  <br><br>dfs(nums, used, arr)<br><br><span class="hljs-keyword">return</span> ans<br><br>&#125;<br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, used []<span class="hljs-type">bool</span>, arr []<span class="hljs-type">int</span>)</span></span> &#123;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-built_in">len</span>(nums) &#123;<br><br>ans = <span class="hljs-built_in">append</span>(ans, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, arr...))<br><br><span class="hljs-keyword">return</span><br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><br><span class="hljs-keyword">if</span> used[i] &#123;<br><br><span class="hljs-keyword">continue</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// 上一个元素如果和当前元素相同且没使用过，则跳过当前元素，防止重复</span><br><br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &amp;&amp; !used[i<span class="hljs-number">-1</span>] &#123;<br><br><span class="hljs-keyword">continue</span><br><br>&#125;<br><br>  <br><br>arr = <span class="hljs-built_in">append</span>(arr, nums[i])<br><br>used[i] = <span class="hljs-literal">true</span><br><br>dfs(nums, used, arr)<br><br>used[i] = <span class="hljs-literal">false</span><br><br>arr = arr[:<span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>]<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>50.x的n次幂</title>
    <link href="/2021/09/2cc51ba2510e.html"/>
    <url>/2021/09/2cc51ba2510e.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/powx-n/submissions/">leetcode</a></p><p>递归<br>时间复杂度 O(log n)<br>空间复杂度O(log n)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myPow</span><span class="hljs-params">(x <span class="hljs-type">float64</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br><br>    <span class="hljs-keyword">var</span> helper <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">float64</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span><br>    helper = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">float64</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br><br>        temp := helper(x, n / <span class="hljs-number">2</span>)<br><br>        <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            temp = temp * temp<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp = temp * temp * x<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> temp<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / helper(x, n)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> helper(x, n)    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>51.N皇后问题</title>
    <link href="/2021/09/310b63774ff8.html"/>
    <url>/2021/09/310b63774ff8.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/">leetcode</a></p><p>回溯法解题。</p><ol><li>考虑给每行设置皇后在哪一列，所以维护一个列数组表示哪些列有皇后了，则这些列不能再分配皇后。</li><li>皇后所在的斜线上也不能有皇后，斜线规律为行数和列数之差相等以及行数和列数之和相等，故维护一个行数列数之差的map以及行数列数之和的map。</li><li>递归遍历每行的列，看是否能够在该行该列防止皇后。</li><li>每层递归结束记得还原现场，即修改列数组和斜线map。<span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    columns := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    crossL := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>    crossR := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br><br>    results := [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span><br><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(queens []<span class="hljs-type">int</span>, row <span class="hljs-type">int</span>)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (row &gt;= n) &#123;<br>        <span class="hljs-comment">// 注意二维数组的slice赋值最好新建对象</span><br>            results = <span class="hljs-built_in">append</span>(results, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, queens...))<br>            <span class="hljs-comment">// fmt.Printf(&quot;results: %v\n&quot;, results)</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>            <span class="hljs-comment">// fmt.Printf(&quot;row: %v col: %v\n&quot;, row, col)</span><br>            <span class="hljs-keyword">if</span> c, ok := crossL[row - col]; ok &amp;&amp; c &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> c, ok := crossR[row + col]; ok &amp;&amp; c &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> !columns[col]  &#123;<br>                columns[col] = <span class="hljs-literal">true</span><br>                crossL[row - col] = <span class="hljs-literal">true</span><br>                crossR[row + col] = <span class="hljs-literal">true</span><br>                queens := <span class="hljs-built_in">append</span>(queens, col)<br>                <span class="hljs-comment">// fmt.Printf(&quot;queens: %v\n&quot;, queens)</span><br>                backtrack(queens, row + <span class="hljs-number">1</span>)<br>                <span class="hljs-comment">// 还原现场</span><br>                columns[col] = <span class="hljs-literal">false</span><br>                crossL[row - col] = <span class="hljs-literal">false</span><br>                crossR[row + col] = <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    backtrack([]<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-number">0</span>)<br>    <br>    ans := [][]<span class="hljs-type">string</span>&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> _, result := <span class="hljs-keyword">range</span> results &#123;<br>        a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, n)<br>        <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; n; row++ &#123;<br>            <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>                <span class="hljs-keyword">if</span> col == result[row] &#123;<br>                    a[row] = a[row] + <span class="hljs-string">&quot;Q&quot;</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    a[row] = a[row] + <span class="hljs-string">&quot;.&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        ans = <span class="hljs-built_in">append</span>(ans, a)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br>&lt;!-- more --&gt;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>518.零钱兑换 II</title>
    <link href="/2021/09/a24932b4a773.html"/>
    <url>/2021/09/a24932b4a773.html</url>
    
    <content type="html"><![CDATA[<p>完全背包</p><p>时间复杂度：O(amount x amount x N)<br>空间复杂度：O(amount x N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-type">int</span>, coins []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(coins)+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(coins); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>        coin := coins[i<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= amount; j++ &#123;<br>        <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k*coin &lt;= j; k++ &#123;<br>    dp[i][j] += dp[i<span class="hljs-number">-1</span>][j-k*coin]     <br>        &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(coins)][amount]<br>&#125;<br></code></pre></td></tr></table></figure><p>完全背包一维优化，即动态规划</p><p>时间复杂度：O(amount x N)<br>空间复杂度：O(amount)</p><!-- more --><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-type">int</span>, coins []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(coins); i++ &#123;<br>        coin := coins[i]<br>        <span class="hljs-keyword">for</span> j := coin; j &lt;= amount; j++ &#123;<br>            dp[j] += dp[j-coin]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>53.最大子序和</title>
    <link href="/2021/09/1f1199041b30.html"/>
    <url>/2021/09/1f1199041b30.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-subarray/">leetcode</a></p><p>思路：动态规划，前缀和。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><br>ans := nums[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-comment">// 当前缀和为正数则累加，否则抛弃</span><br><span class="hljs-keyword">if</span> nums[i<span class="hljs-number">-1</span>] + nums[i] &gt; nums[i] &#123;<br>nums[i] = nums[i<span class="hljs-number">-1</span>] + nums[i]<br>&#125;<br><br><span class="hljs-keyword">if</span> nums[i] &gt; ans &#123;<br>ans = nums[i]<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>547.省份数量</title>
    <link href="/2021/09/d4aa73c2e1fd.html"/>
    <url>/2021/09/d4aa73c2e1fd.html</url>
    
    <content type="html"><![CDATA[<p>深度优先遍历</p><p>找到未访问过的城市，深度优先遍历其所有能联通的城市，并标记为已访问。</p><p>最后统计有几个联通量。</p><p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(isConnected [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    ans := <span class="hljs-number">0</span><br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(isConnected))<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> visited[i] &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        visited[i] = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">for</span> j, connected := <span class="hljs-keyword">range</span> isConnected[i] &#123;<br>            <span class="hljs-keyword">if</span> connected == <span class="hljs-number">1</span> &#123;<br>                dfs(j)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<br>        <span class="hljs-keyword">if</span> !visited[i] &#123;<br>            dfs(i)<br>            ans++<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>56.合并区间</title>
    <link href="/2021/09/372a17b6d909.html"/>
    <url>/2021/09/372a17b6d909.html</url>
    
    <content type="html"><![CDATA[<p>排序，然后逐一合并</p><p>时间复杂度： O(NlogN)<br>空间复杂的： O(logN)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] == intervals[j][<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">1</span>] &lt; intervals[j][<span class="hljs-number">1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br>        &#125;<br>    &#125;)<br><br>    ans := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <br>    l, r := intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(intervals); i++ &#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &lt;= r &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt; r) &#123;<br>                r = intervals[i][<span class="hljs-number">1</span>]<br>            &#125;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        ans = <span class="hljs-built_in">append</span>(ans, []<span class="hljs-type">int</span>&#123;l, r&#125;)<br>        l = intervals[i][<span class="hljs-number">0</span>]<br>        r = intervals[i][<span class="hljs-number">1</span>]<br>    &#125;<br><br>    ans = <span class="hljs-built_in">append</span>(ans, []<span class="hljs-type">int</span>&#123;l, r&#125;)<br>    <br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>560. 和为 K 的子数组</title>
    <link href="/2021/09/ee08e0805982.html"/>
    <url>/2021/09/ee08e0805982.html</url>
    
    <content type="html"><![CDATA[<p>前缀和+哈希</p><p>滚动计算前缀和，同时查找哈希值中有符合前缀和之差等于k的前缀和的出现次数。</p><p>最后累加哈希中前缀和的出现次数。</p><p>时间复杂度：O(N)<br>空间复杂度：O(N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    pre, ans := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        pre += nums[i]<br><br>        <span class="hljs-keyword">if</span> _, ok := m[pre-k]; ok &#123;<br>            ans += m[pre-k]<br>        &#125;<br>        m[pre] += <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>673.最长递增子序列的个数</title>
    <link href="/2021/09/a47563a515f0.html"/>
    <url>/2021/09/a47563a515f0.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p>要注意统计个数的时候，dp相等时要把之前的数量累加上，dp大的时候则是直接继承之前的数量。</p><p>时间复杂度： O(N^2)<br>空间复杂度：O(N)</p><span id="more"></span><pre><code class="Go">func findNumberOfLIS(nums []int) int &#123;    n := len(nums)    dp := make([]int, n)    count := make([]int, n)    maxLength := 0    ans := 0    for i := 0; i &lt; n; i++ &#123;        dp[i] = 1        count[i] = 1        for j := 0; j &lt; i; j++ &#123;            if nums[i] &gt; nums[j] &#123;                if dp[j] + 1 == dp[i] &#123;                    // j位置的所有个数都要加上                    count[i] += count[j]                &#125;                if dp[j] + 1 &gt; dp[i] &#123;                    dp[i] = dp[j] + 1                    // 针对j位置的每一种最长子序列都有一个对应的新序列                    count[i] = count[j]                &#125;            &#125;                    &#125;        // 所有最长的子序和都要考虑        if dp[i] == maxLength &#123;            ans += count[i]        &#125;        if dp[i] &gt; maxLength &#123;            maxLength = dp[i]            ans = count[i]        &#125;    &#125;    return ans&#125;```</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>684.冗余链接</title>
    <link href="/2021/09/4e32b9173bb0.html"/>
    <url>/2021/09/4e32b9173bb0.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/redundant-connection/">leetcode</a></p><p>使用并查集方法，维护联通分量数组，检验每条边的两个节点，如果已经联通了，则当前边导致成环，为冗余链接。</p><p>时间复杂度：<br>空间复杂度：O(n)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(edges [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    group := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(edges) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(edges) + <span class="hljs-number">1</span>; i++ &#123;<br>       group[i] = i<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br>    <span class="hljs-comment">// 查找真正的联通分量</span><br>    find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> group[i] == i &#123;<br>            <span class="hljs-keyword">return</span> i<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> find(group[i])<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个联通分量，返回这个两个联通分量是否本来就联通了</span><br>    union := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(from <span class="hljs-type">int</span>, to <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        from = find(from)<br>        to = find(to)<br><br>        <span class="hljs-keyword">if</span> from == to &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        group[to] = from<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, edge := <span class="hljs-keyword">range</span> edges &#123;<br>        <span class="hljs-comment">// 联通分量事先已经联通则表示有环</span><br>        <span class="hljs-keyword">if</span> union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> edge<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>685.冗余链接2</title>
    <link href="/2021/09/d38dabc86412.html"/>
    <url>/2021/09/d38dabc86412.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/redundant-connection-ii/">leetcode</a></p><p>建立出边邻接表，节点入度数组。</p><p>因为需要返回最后的一个可以去除的边，故倒序删除边，删除后满足树的条件则表明该边为要找的冗余边。</p><p>为树的条件：</p><ol><li>有且只有一个入度大于0的点（防止成环）</li><li>且最长路径的步数和节点数相等（防止有独立的多块不联通的图）<span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRedundantDirectedConnection</span><span class="hljs-params">(edges [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>to := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>)<br>degrees := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(edges)+<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> _, edge := <span class="hljs-keyword">range</span> edges &#123;<br>to[edge[<span class="hljs-number">0</span>]] = <span class="hljs-built_in">append</span>(to[edge[<span class="hljs-number">0</span>]], edge[<span class="hljs-number">1</span>])<br>degrees[edge[<span class="hljs-number">1</span>]]++<br>&#125;<br><br><span class="hljs-comment">// fmt.Printf(&quot;to: %v\n&quot;, to)</span><br><span class="hljs-comment">// fmt.Printf(&quot;degress: %v\n&quot;, degrees)</span><br><br>valid := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> root <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(degrees); i++ &#123;<br><span class="hljs-keyword">if</span> degrees[i] == <span class="hljs-number">0</span> &#123;<br>root = i<br>&#125;<br><br><span class="hljs-comment">// 有入度大于0的点，表示有环</span><br><span class="hljs-keyword">if</span> degrees[i] &gt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 没有入度为0的点，表示有环</span><br><span class="hljs-keyword">if</span> root == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br>seen := []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> bfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><br>bfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root <span class="hljs-type">int</span>)</span></span> &#123;<br>seen = <span class="hljs-built_in">append</span>(seen, root)<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> to[root] &#123;<br>bfs(c)<br>&#125;<br>&#125;<br><br>bfs(root)<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(seen) == <span class="hljs-built_in">len</span>(edges)<br>&#125;<br><br><span class="hljs-comment">// 倒序删除边</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(edges) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>edge := edges[i]<br><span class="hljs-keyword">for</span> j, t := <span class="hljs-keyword">range</span> to[edge[<span class="hljs-number">0</span>]] &#123;<br><span class="hljs-keyword">if</span> t == edge[<span class="hljs-number">1</span>] &#123;<br>to[edge[<span class="hljs-number">0</span>]] = <span class="hljs-built_in">append</span>(to[edge[<span class="hljs-number">0</span>]][:j], to[edge[<span class="hljs-number">0</span>]][j+<span class="hljs-number">1</span>:]...)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>degrees[edge[<span class="hljs-number">1</span>]]--<br><span class="hljs-keyword">if</span> valid() &#123;<br><span class="hljs-keyword">return</span> edges[i]<br>&#125;<br><br><span class="hljs-comment">// 还原</span><br>to[edge[<span class="hljs-number">0</span>]] = <span class="hljs-built_in">append</span>(to[edge[<span class="hljs-number">0</span>]], edge[<span class="hljs-number">1</span>])<br>degrees[edge[<span class="hljs-number">1</span>]]++<br>&#125;<br><br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>699. 掉落的方块</title>
    <link href="/2021/09/c3604616f70c.html"/>
    <url>/2021/09/c3604616f70c.html</url>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Box <span class="hljs-keyword">struct</span> &#123;<br>    Left <span class="hljs-type">int</span><br>    Right <span class="hljs-type">int</span><br>    Height <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fallingSquares</span><span class="hljs-params">(positions [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    boxes := []Box&#123;&#125;<br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br>    max := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> positions &#123;<br>        left := p[<span class="hljs-number">0</span>]<br>        right := p[<span class="hljs-number">0</span>] + p[<span class="hljs-number">1</span>]<br>        height := p[<span class="hljs-number">1</span>]<br>        bottom := <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> _, b := <span class="hljs-keyword">range</span> boxes &#123;<br>            <span class="hljs-keyword">if</span> !(left &gt;= b.Right || right &lt;= b.Left) &amp;&amp; bottom &lt; b.Height &#123;<br>                bottom = b.Height<br>            &#125;<br>        &#125;<br><br>        height += bottom<br>        <span class="hljs-keyword">if</span> height &gt; max &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, height)<br>            max = height<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, max)<br>        &#125;<br><br>        boxes = <span class="hljs-built_in">append</span>(boxes, Box&#123;Left: left, Right: right, Height: height&#125;)<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>704.二分查找</title>
    <link href="/2021/09/06399cba81a2.html"/>
    <url>/2021/09/06399cba81a2.html</url>
    
    <content type="html"><![CDATA[<p>二分查找标准模板</p><p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) <span class="hljs-number">-1</span><br><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br><span class="hljs-comment">// 找到第一个大于等于target的数</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;<br>        right = mid<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 这个数等于target则返回下标</span><br>    <span class="hljs-keyword">if</span> nums[right] == target &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>72.编辑距离</title>
    <link href="/2021/09/6cbf857f7046.html"/>
    <url>/2021/09/6cbf857f7046.html</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p><code>f[i][j]</code> 记录 <code>word1[1..i]</code> 到 <code>word2[1..j]</code> 的最短编辑距离。则考虑三种情况：</p><ol><li>word1插入一个字符和word2相等：<code>f[i][j-1] + 1</code></li><li>word1删除一个字符和word2相等： <code>f[i-1][j] + 1</code></li><li>word1替换一个字符和word2相等：<code>f[i-1]f[j-1] + eq</code> 。其中eq考虑两种状态，如果word1要替换的这个字符和word2的最后一个字符相等，则表示不需要替换已经相等，eq等0，否则eq等于1</li></ol><p>时间复杂度： O(MN)<br>空间复杂度： O(MN)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// f[i][j] = min(f[i][j-1]+1, f[i-1][j]+1, f[i-1][j-1] + eq)</span><br><br>    m := <span class="hljs-built_in">len</span>(word1)<br>    n := <span class="hljs-built_in">len</span>(word2)<br>    f := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        f[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= n; j ++ &#123;<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>                f[i][j] = j<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> &#123;<br>                f[i][j] = i<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            temp := min(f[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, f[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>)<br><br>            eq := <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;<br>                eq = <span class="hljs-number">0</span><br>            &#125;<br>            temp = min(temp, f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+eq)<br><br>            <span class="hljs-comment">// fmt.Printf(&quot;f[%v][%v]: %v\n&quot;, i, j, temp)</span><br><br>            f[i][j] = temp<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> f[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>721.账户合并</title>
    <link href="/2021/09/13597fc24728.html"/>
    <url>/2021/09/13597fc24728.html</url>
    
    <content type="html"><![CDATA[<p>并查集</p><p>注意使用Hashmap来存储邮箱和父节点邮箱。</p><p>时间复杂度： O(NlogN)<br>空间复杂度： O(N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">accountsMerge</span><span class="hljs-params">(accounts [][]<span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br><br>    ans := [][]<span class="hljs-type">string</span>&#123;&#125;<br>    email_to_name := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>    emails_list := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><br><span class="hljs-comment">// 查找</span><br>    <span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br>    find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(email <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>&#123;<br>        <span class="hljs-keyword">if</span> emails_list[email] == email &#123;<br>            <span class="hljs-keyword">return</span> email<br>        &#125;<br><br>        emails_list[email] = find(emails_list[email])<br>        <span class="hljs-keyword">return</span> emails_list[email]<br>    &#125;<br><br><span class="hljs-comment">// 合并</span><br>    union := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(email1 <span class="hljs-type">string</span>,  email2 <span class="hljs-type">string</span>)</span></span> &#123;<br>        e1 := find(email1)<br>        e2 := find(email2)<br><br>        <span class="hljs-comment">// fmt.Printf(&quot;union: %v, %v\n&quot;, email1, email2)</span><br>        emails_list[e1] = e2<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _, account := <span class="hljs-keyword">range</span> accounts &#123;<br>        name := account[<span class="hljs-number">0</span>]<br>        emails := account[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-keyword">for</span> i, email := <span class="hljs-keyword">range</span> emails &#123;<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>                email_to_name[email] = name<br>            &#125;<br>            <span class="hljs-comment">// 没出现过的邮箱关联父节点到当前账号的首个邮箱</span><br>            <span class="hljs-keyword">if</span> _, ok := emails_list[email]; !ok &#123;<br>                emails_list[email] = emails[<span class="hljs-number">0</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 出现过的邮箱则把当前账号和出现过的账号合并</span><br>                union(emails[<span class="hljs-number">0</span>], email)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    group := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">for</span> email, fa := <span class="hljs-keyword">range</span> emails_list &#123;<br>    <span class="hljs-comment">// 获取邮箱的真实父节点邮箱</span><br>        fa = find(fa)<br>        <span class="hljs-keyword">if</span> _, ok := group[fa]; ok &#123;<br>            group[fa] = <span class="hljs-built_in">append</span>(group[fa], email)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            group[fa] = []<span class="hljs-type">string</span>&#123;email&#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> fa, emails := <span class="hljs-keyword">range</span> group &#123;<br>        sort.Strings(emails)<br>        ans = <span class="hljs-built_in">append</span>(ans, <span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>&#123;email_to_name[fa]&#125;, emails...))<br>    &#125;<br><br>    <span class="hljs-comment">// fmt.Printf(&quot;group: %v&quot;, group)</span><br>    <br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>743. 网络延迟</title>
    <link href="/2021/09/ef5132bc327a.html"/>
    <url>/2021/09/ef5132bc327a.html</url>
    
    <content type="html"><![CDATA[<p>Bellman-Ford算法</p><p>最多遍历N-1轮所有边，得到最短或者最长路径。</p><p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(times [][]<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dist := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">const</span> inf = math.MaxInt / <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dist &#123;<br>        <span class="hljs-keyword">if</span> i == k &#123;<br>            dist[i] = <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dist[i] = inf<br>        &#125;<br>    &#125;<br><br>    fmt.Println(dist)<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>        flag := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(times); i++ &#123;<br>            x := times[i][<span class="hljs-number">0</span>]<br>            y := times[i][<span class="hljs-number">1</span>]<br>            z := times[i][<span class="hljs-number">2</span>]<br><br>            <span class="hljs-keyword">if</span> dist[y] &gt; dist[x] + z &#123;<br>                <span class="hljs-comment">// fmt.Printf(&quot;x: %v, y: %v, z: %v\n&quot;, x, y, z)</span><br>                dist[y] = dist[x] + z<br>                <span class="hljs-comment">// fmt.Printf(&quot;dist[x]: %v, dist[y]: %v\n&quot;,dist[x], dist[y])</span><br>                flag = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !flag &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br><br>    ans := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(dist); i++ &#123;<br>        <span class="hljs-keyword">if</span> dist[i] == inf &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ans &lt; dist[i] &#123;<br>            ans = dist[i]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>77.组合</title>
    <link href="/2021/09/0ad8484ad345.html"/>
    <url>/2021/09/0ad8484ad345.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/combinations/">leetcode</a></p><p>递归实现：</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    curr := []<span class="hljs-type">int</span>&#123;&#125;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">//如果剩下的数都取，还不够k，就剪枝</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(curr) + n - i + <span class="hljs-number">1</span> &lt; k &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(curr) == k &#123;<br>            result = <span class="hljs-built_in">append</span>(result, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, curr...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        curr = <span class="hljs-built_in">append</span>(curr, i)<br>        dfs(i + <span class="hljs-number">1</span>)<br><br>        curr = curr[:<span class="hljs-built_in">len</span>(curr) - <span class="hljs-number">1</span>]<br>        dfs(i + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    dfs(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>78.子集</title>
    <link href="/2021/09/5cd8d3141e83.html"/>
    <url>/2021/09/5cd8d3141e83.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/subsets/">leetcode</a></p><p>递归来枚举子集</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    result := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    curr := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-comment">// 合并到答案的时候新开变量</span><br>            result = <span class="hljs-built_in">append</span>(result, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, curr...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        curr = <span class="hljs-built_in">append</span>(curr, nums[i])<br>        dfs(i + <span class="hljs-number">1</span>)<br>        curr = curr[:<span class="hljs-built_in">len</span>(curr)<span class="hljs-number">-1</span>]<br>        dfs(i + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>918.环形子数组的最大和</title>
    <link href="/2021/09/bfe779944b47.html"/>
    <url>/2021/09/bfe779944b47.html</url>
    
    <content type="html"><![CDATA[<p>分为两种情况，最大子数组在中间和最大子数组分散在两边。</p><p>通过计算最大子数组和和最小子数组和来求解。</p><p>时间复杂度：O(N)<br>空间复杂度： O(1)</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    total := nums[<span class="hljs-number">0</span>]<br>    currMax := nums[<span class="hljs-number">0</span>]<br>    currMin := nums[<span class="hljs-number">0</span>]<br>    sumMax := nums[<span class="hljs-number">0</span>]<br>    sumMin := nums[<span class="hljs-number">0</span>]<br><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        total += nums[i]<br>        currMax = max(currMax+nums[i], nums[i])<br>        sumMax  = max(sumMax, currMax)<br>        currMin = min(currMin+nums[i], nums[i])<br>        sumMin  = min(sumMin, currMin)<br>    &#125;<br><br><span class="hljs-comment">// 特殊情况，值全为负数，最大和就是空数组，不符合题意，要特殊处理</span><br>    <span class="hljs-keyword">if</span> sumMin == total &#123;<br>        <span class="hljs-keyword">return</span> sumMax<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> max(total-sumMin, sumMax)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>98.验证二叉搜索树</title>
    <link href="/2021/09/f12d6c038a19.html"/>
    <url>/2021/09/f12d6c038a19.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/submissions/">leetcode</a></p><p>递归实现</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> dfs(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, min <span class="hljs-type">int</span>, max <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 注意和上下边界相等的情况应该返回false</span><br><span class="hljs-keyword">if</span> root.Val &gt;= max || root.Val &lt;= min &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">return</span> dfs(root.Left, min, root.Val) &amp;&amp; dfs(root.Right, root.Val, max)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跨域问题和CORS</title>
    <link href="/2020/10/48fe4bc41aa8.html"/>
    <url>/2020/10/48fe4bc41aa8.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h2><p>所谓跨域，通俗来说就是该网站访问了其他origin（源，由域、协议和端口组成）的资源。</p><p>浏览器发出的 <code>XMLHttpRequest</code> 请求有同源使用限制，默认情况下跨域请求是不被允许的。但是，每个源可以设置哪些其他源可以访问自己的资源，如果一个请求源A在源B的允许请求范围内，那么浏览器就允许请求源A对源B的跨域请求。这种检查机制就是跨源资源共享 (CORS)，是一种基于 HTTP 头的机制。</p><h2 id="简单请求和非简单请求"><a href="#简单请求和非简单请求" class="headerlink" title="简单请求和非简单请求"></a>简单请求和非简单请求</h2><p>在介绍CORS之前，首先要明确两种不同类型的请求，<code>简单请求</code> 和 <code>非简单请求</code>。 </p><p>若请求 满足所有下述条件，则该请求可视为<code>简单请求</code>：</p><p>使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>请求的Headers只包含以下字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type（需要注意额外的限制）</li><li>请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。</li><li>请求中没有使用 ReadableStream 对象。</li></ul><p>Content-Type 的值仅限于下列三者之一：</p><ul><li>text&#x2F;plain</li><li>multipart&#x2F;form-data</li><li>application&#x2F;x-www-form-urlencoded</li></ul><p>而不符合上述条件的则为 <code>非简单请求</code>。</p><h2 id="CORS预检请求（Preflight-request）"><a href="#CORS预检请求（Preflight-request）" class="headerlink" title="CORS预检请求（Preflight request）"></a>CORS预检请求（Preflight request）</h2><p>浏览器会在必要的时候向服务器发送一个 <code>OPTIONS</code> 请求，用来检查服务器是否支持跨域资源共享即CORS。这个请求就叫预检请求（Preflight request）。</p><p>请求通常携带 <code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code>，以及一个 <code>Origin</code>  的首部信息。</p><p>举一个例子，在实际发送 <code>DELETE</code> 请求之前，会先向服务器发起一个预检 <code>OPTIONS</code> 请求：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">OPTIONS /resource/foo<br>Access-Control-Request-<span class="hljs-keyword">Method</span>: DELETE<br>Access-Control-Request-Headers: origin, x-requested-<span class="hljs-keyword">with</span><br>Origin: https:<span class="hljs-comment">//foo.bar.org</span><br></code></pre></td></tr></table></figure><p>如果服务器允许，就会相应这个请求，并在response header里面返回允许的请求源和方法：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>0<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>https://foo.bar.org<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST, GET, OPTIONS, DELETE<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>86400<br></code></pre></td></tr></table></figure><p>这和开头的两种请求类型有什么关系呢？</p><p>简单来说，<code>简单请求</code> 不会触发预检请求，而 <code>非简单请求</code> 则会触发。这么做的原因也很简单，是否允许CORS是在响应的Header里返回的，而<code>非简单请求</code> 都是可能会对服务器数据产生未预期影响的操作，比如删除，修改或者是带有其他Header信息，所以要通过 <code>OPTIONS</code> 预检请求来验证请求是否符合CORS规则，同时又不影响服务端数据。</p><p>需要注意的是，Response Header里的 <code>Access-Control-Max-Age</code> 信息表示在86400秒，也就是24小时内，无需为统一请求再次发起预检请求。当然浏览器也会维护一个最大有效时间，如果Header中的最大有效时间超过了浏览器设置，则不会生效。</p><h2 id="Response-Header"><a href="#Response-Header" class="headerlink" title="Response Header"></a>Response Header</h2><p>跟CORS相关的Response Header，日常工作中注意在服务端，反向代理或者CDN等设置中根据实际情况进行相应设置。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 设置允许访问该资源的外域 URI</span><br>Access-Control-Allow-Origin: &lt;origin&gt; | *<br><br><span class="hljs-comment">// 把允许浏览器访问的头放入白名单</span><br>Access-Control-Allow-Methods: &lt;<span class="hljs-keyword">method</span>&gt;[, &lt;<span class="hljs-title function_">method</span>&gt;]*<br><br>// 用于预检请求的响应，其指明了实际请求所允许使用的 <span class="hljs-title function_">HTTP</span> 方法<br><span class="hljs-title function_">Access</span>-<span class="hljs-title function_">Control</span>-<span class="hljs-title function_">Expose</span>-<span class="hljs-title function_">Headers</span>: X-My-Custom-Header, X-Another-Custom-Header<br><br><span class="hljs-comment">// 指定了 preflight 请求的结果能够被缓存多久</span><br>Access-Control-Max-Age: &lt;delta-seconds&gt;<br><br><span class="hljs-comment">// 一个布尔值，表示是否允许发送Cookie，如果不需要浏览器传递cookie则不设置该值</span><br>Access-Control-Allow-Credentials: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS） - HTTP | MDN</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 - 阮一峰的网络日志</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
